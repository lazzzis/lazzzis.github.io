{"name":"Python","postlist":[{"title":"初看 CPython","slug":"a-glance-at-cpython","date":"2017-01-05T01:24:13.000Z","updated":"2018-04-12T21:41:37.000Z","comments":true,"path":"api/articles/a-glance-at-cpython.json","excerpt":"<h1 id=\"什么是-CPython\"><a href=\"#什么是-CPython\" class=\"headerlink\" title=\"什么是 CPython\"></a>什么是 CPython</h1><p>简单的说, <code>CPython</code> 是 Python 解释器的一个实现。换句话说，Python 解释器是由 C 写的，然后由 GCC 之类的编译器编译而成的可执行文件。除了 CPython，还有 <a href=\"http://pypy.org/\" target=\"_blank\" rel=\"noopener\">PyPy</a>(用 Python 实现的 Python 解释器)，<a href=\"http://www.skulpt.org/\" target=\"_blank\" rel=\"noopener\">Skulpt</a>(用 JavaScript 实现的 Python 解释器) 等等。如果你不知道你用的是哪一个，那么你一定用的就是 CPython。因为 CPython 是 Python 官方的解释器实现，其它均属于第三方实现。</p>\n<h1 id=\"从源码到运行\"><a href=\"#从源码到运行\" class=\"headerlink\" title=\"从源码到运行\"></a>从源码到运行</h1><p>对于从 Python 源码到解释器执行它们的这个过程，我把它分为两大步 —— 编译(Compiling) 与 解释(Interpreting)。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"Python 对函数默认参数的处理","slug":"default-para-in-python","date":"2017-01-17T01:13:49.000Z","updated":"2018-04-12T21:41:58.000Z","comments":true,"path":"api/articles/default-para-in-python.json","excerpt":"<p>Python 对函数默认参数的处理</p>\n<p>一个以可变对象为默认参数的函数:</p>\n<pre><code class=\"Python\">class A:\n    def __init__(self):\n        self.x = 1\n        print(&#39;created&#39;)\n\ndef f(a = A()):\n    a.x += 1\n    print(a.x)\n# output: created\nf() # output: 2\nf() # output: 3\n</code></pre>\n<p>从结果可以看出，Python 在解析时便已经创建好了默认参数 a 的值。函数 f 在调用时采用了同一个对象，而不是每次调用时重新创建新的对象。这一点与 <code>C++</code> 的处理方式不同。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"延迟计算: 关于 Python 的 yield","slug":"python-yield-and-delay","date":"2016-12-13T02:07:06.000Z","updated":"2018-04-12T21:45:51.000Z","comments":true,"path":"api/articles/python-yield-and-delay.json","excerpt":"<p>在 SICP 第 3 章中，有一段部分内容是以 stream 为核心而展开的。而 stream 的特点就是 lazy evaluation / delayed evaluation （惰性求值 / 延迟计算）。在接触 stream 之时，我便立即联想到 Python 具有类似的功能 — <code>yield</code>。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"SICP","path":"api/tags/SICP.json"}]},{"title":"howdoi 源码阅读与分析","slug":"source-code-of-howdoi","date":"2017-03-05T02:49:27.000Z","updated":"2018-04-12T21:44:04.000Z","comments":true,"path":"api/articles/source-code-of-howdoi.json","excerpt":"<p><a href=\"https://github.com/gleitz/howdoi\" target=\"_blank\" rel=\"noopener\">howdoi</a> – 一款通过命令行帮你从 stackoverflow 中寻找答案的工具，其源代码部分不足 300 行。同时，这份代码被 <a href=\"http://docs.python-guide.org/en/latest/writing/reading/\" target=\"_blank\" rel=\"noopener\">The Hitchhiker’s Guide to Python!</a> 推荐为适合新手源码阅读的代码。因此，在读完源码后，我分享一下我对这份代码的理解。</p>\n<p>这里采用的版本是 tree 中标号为 <a href=\"https://github.com/gleitz/howdoi/tree/d84afdee603dbe699153e35650d46ddd734337d1\" target=\"_blank\" rel=\"noopener\">d84afdee60</a> 的那一版</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"Python @staticmethod 与 @classmethod 的区别分析","slug":"staticmethod-and-classmethod-in-Python","date":"2016-02-04T02:33:09.000Z","updated":"2018-04-12T21:44:17.000Z","comments":true,"path":"api/articles/staticmethod-and-classmethod-in-Python.json","excerpt":"<p>乍一看之下，@staticmethod 与 @classmethod 真的很相似，貌似都可以看作是静态函数，除了后者必须有一个传入参数外就貌似没区别了。但既然加入了，那也一定有开发者的考虑了。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}]}