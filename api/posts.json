[{"title":"为什么 Vue 组件需要一个 name","slug":"name-attribute-in-vue-component","date":"2018-04-11T01:37:58.000Z","updated":"2018-04-12T19:39:00.000Z","comments":true,"path":"api/articles/name-attribute-in-vue-component.json","excerpt":"<p>无论是通过 <code>Vue.component</code> 的方式，还是在写 <code>.vue</code> 文件的方式，官方都会推荐你写一个 <code>name</code> 属性。但是好像这个 name 在渲染时又几乎用不到，那么它实际能干嘛呢?</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"用 vue 写一个单页的 hexo 主题","slug":"hexo-theme-of-spa-in-vue","date":"2018-04-06T01:51:32.000Z","updated":"2018-04-12T19:40:01.000Z","comments":true,"path":"api/articles/hexo-theme-of-spa-in-vue.json","excerpt":"<p>大概一年以前，我发布过一个主题，名为 <a href=\"https://github.com/lazzzis/hexo-theme-mls\" target=\"_blank\" rel=\"noopener\">hexo-theme-mls</a>。这个主题是我当时在学完如何写一个 hexo 主题后完成的。后来在学了 vue 之后，构思着再写一个主题。我非常想把它写成一个单页应用，可是一直没有思绪。直到后来看到了 <a href=\"https://github.com/EYHN/hexo-theme-one\" target=\"_blank\" rel=\"noopener\">hexo-theme-one</a>，我才有了思绪，于是开始写一个单页的主题。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"联系 Koa.js 和 requests 看 HTTP 协议中的重定向","slug":"http-protocol-redirecting","date":"2018-01-04T21:29:09.000Z","updated":"2018-04-12T19:40:29.000Z","comments":true,"path":"api/articles/http-protocol-redirecting.json","excerpt":"<p>在 HTTP 协议中，一般 3 开头的状态码，都用于表示 <code>重定向</code>：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"2017 -> 2018","slug":"the-end-of-2017","date":"2017-12-29T19:31:46.000Z","updated":"2018-04-12T19:41:10.000Z","comments":true,"path":"api/articles/the-end-of-2017.json","excerpt":"<p>上一年差不多在这时也写了这么一个年终总结，今年也写一个吧。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[]},{"title":"HTTP 协议中的 ETag 与 If-None-Match","slug":"http-protocol-etag-if-none-match","date":"2017-12-28T22:26:57.000Z","updated":"2018-04-12T19:40:46.000Z","comments":true,"path":"api/articles/http-protocol-etag-if-none-match.json","excerpt":"<p>ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。</p>\n<p>软件开发常常有版本号的概念，比如 <code>1.0</code>, <code>1.1</code>, <code>2.0</code> 等等。软件使用者通常会在客户端版本落后于服务器最新版本时才会去服务器获取新的软件。</p>\n<p>这一理念也用于了浏览器缓存策略中。结合下面这张图为例，浏览器已经缓存了 <code>foo.jpg</code> 且已记录版本号为<code>1.2</code> (这个版本号由服务器生成并告诉浏览器)，那么当浏览器再次请求 <code>foo.jpg</code> 时，就会同时把版本号也放在请求头中。这样，服务器收到请求时，就知道了客户端已缓存的文件的版本。如果服务器中的 <code>foo.jpg</code> 版本也是 <code>1.2</code>，那么服务器就可以说 <code>304 Not Modified</code>，不用再将 <code>foo.jpg</code> 传给了浏览器，因此就节省了带宽。反之，如果服务器端的 <code>foo.jpg</code> 已经 <code>1.3</code> 了，那么就要将新的文件传给浏览器，也同时告诉它版本号为 <code>1.3</code>，浏览器收到后，缓存文件，并记录版本号为 <code>1.3</code>。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"HTTP 协议中的 URL","slug":"http-protocol-url","date":"2017-12-16T20:22:33.000Z","updated":"2018-04-12T19:40:36.000Z","comments":true,"path":"api/articles/http-protocol-url.json","excerpt":"<h1 id=\"URL-概念\"><a href=\"#URL-概念\" class=\"headerlink\" title=\"URL 概念\"></a>URL 概念</h1><blockquote>\n<p>全称 Uniform Resource Locator (统一资源定位符)，是一种 URI (Uniform Resource Identifier, 统一资源标识符)</p>\n</blockquote>\n<h1 id=\"URL-作用\"><a href=\"#URL-作用\" class=\"headerlink\" title=\"URL 作用\"></a>URL 作用</h1><p>主要用于网络资源的定位。换句话说，当你想告诉 Alice 你的服务器上有一个有趣的文件想要分享时，你就可以告诉这个文件对应的 URL。那么 Alice 就可以根据这个 URL 找到你要分享的文件。而目前 URL 更通俗的被称为网址。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"}]},{"title":"拓扑排序 / topological sort","slug":"intro-of-topological-sort","date":"2017-11-23T01:42:24.000Z","updated":"2018-04-12T21:43:09.000Z","comments":true,"path":"api/articles/intro-of-topological-sort.json","excerpt":"<p>问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png\" alt=\"\"></p>\n<p>其中, <code>1 -&gt; 3</code> 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。</p>\n<p>而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 <code>[1, 2, 4, 3, 5, 7, 6]</code>。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"ACM","path":"api/tags/ACM.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"思考为什么要用工厂模式","slug":"why-factory-method-pattern","date":"2017-11-09T18:01:59.000Z","updated":"2018-04-12T21:44:45.000Z","comments":true,"path":"api/articles/why-factory-method-pattern.json","excerpt":"<p>以 JavaScript 为例子发表一下我对工厂模式 (Factory Pattern) 的看法</p>\n<p><strong>为什么不直接 new 呢? 我自己写代码直接 new 自己写的类不就好了么?</strong></p>\n<p>这里不得不提一下设计模式的意义。设计模式并不是凭空捏造的，而是长期开发所形成的经验之谈，当然这些经验自然是成功的，被认可的经验，否则设计模式就不会被那么多人认可和推崇了。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[]},{"title":"简单谈谈 Node.js 对 ESM 的几种支持方案","slug":"words-on-the-support-of-esm-in-node","date":"2017-10-18T03:18:10.000Z","updated":"2018-04-12T21:44:51.000Z","comments":true,"path":"api/articles/words-on-the-support-of-esm-in-node.json","excerpt":"<p>简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。</p>\n<h1 id=\"主流的方案\"><a href=\"#主流的方案\" class=\"headerlink\" title=\"主流的方案\"></a>主流的方案</h1><ol>\n<li>在文件开头添加 <code>&quot;use module&quot;;</code> 或类似字段</li>\n<li>新的文件后缀名，如 <code>.mjs</code></li>\n<li>通过源代码内容自动区分</li>\n<li>在 <code>package.json</code> 指明采用 <code>ESM</code> 的文件</li>\n</ol>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"借助 Proxy 实现一个 DefaultDict","slug":"defaultdict-in-js","date":"2017-10-01T02:44:12.000Z","updated":"2018-04-12T21:42:03.000Z","comments":true,"path":"api/articles/defaultdict-in-js.json","excerpt":"<p>这里的 <code>DefaultDict</code> 指的是类似于 Python 中的 <a href=\"https://docs.python.org/3/library/collections.html#collections.defaultdict\" target=\"_blank\" rel=\"noopener\"><code>defaultdict</code></a> 的一种类。其基本特点就是当某个属性不存在于该对象中时，该对象会自动为这个属性创建一个默认值。这个默认值是由用户在创建 <code>DefaultDict</code> 时指定的。</p>\n<p>举个例子，现在需要一个对象，如果某个属性不在这个对象时，在为这个属性赋值为 0.</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"node-thunkify 的实现及源码阅读","slug":"source-code-of-thunkify","date":"2017-06-29T19:52:32.000Z","updated":"2018-04-12T21:44:09.000Z","comments":true,"path":"api/articles/source-code-of-thunkify.json","excerpt":"<p>最近看了些项目的源码，其中就包括 <code>thunkify</code>。虽然 <code>thunkify</code> 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 <a href=\"https://github.com/tj/node-thunkify/tree/0bd83e29df1bb0653230724f072cff96b0ab684e\" target=\"_blank\" rel=\"noopener\">0bd83e</a>。</p>\n<h1 id=\"功能陈述\"><a href=\"#功能陈述\" class=\"headerlink\" title=\"功能陈述\"></a>功能陈述</h1><p>将一个函数转换为一个为 Thunk 函数，这个函数被调用后会返回一个以回调函数为参数的函数。可以参考 <a href=\"http://es6.ruanyifeng.com/#docs/generator-async#Thunk-函数\" target=\"_blank\" rel=\"noopener\">Thunk 函数</a>。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"终于完成了一个 OJ -- Putong OJ","slug":"notes-of-putongoj","date":"2017-06-02T03:53:12.000Z","updated":"2018-04-12T21:43:45.000Z","comments":true,"path":"api/articles/notes-of-putongoj.json","excerpt":"<p><strong>Putong OJ</strong> – 一个看上去很普通的 Online Judge，现已<a href=\"http://acm.cjlu.edu.cn\" target=\"_blank\" rel=\"noopener\">上线</a></p>\n<h1 id=\"Features\"><a href=\"#Features\" class=\"headerlink\" title=\"Features\"></a>Features</h1><p>说一些我自认为可以称得上特性的”特性”</p>\n<h2 id=\"单页应用\"><a href=\"#单页应用\" class=\"headerlink\" title=\"单页应用\"></a>单页应用</h2><p>估计现在没有一个 OJ 采用的是单页应用吧。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"Projects","path":"api/tags/Projects.json"}]},{"title":"杭州白马湖漫展一行","slug":"anime-convention-in-hangzhou","date":"2017-04-29T01:51:02.000Z","updated":"2018-04-12T21:41:52.000Z","comments":true,"path":"api/articles/anime-convention-in-hangzhou.json","excerpt":"<p>作为一名在杭州读书的学生，其实从大一开始，我就一直想去这个展会了。第一次和第二次“太乖”，遇上了点学院的事，听了辅导员和学生会的建议，给他们做苦力去了。第三次正忙于升学考试，故自愿放弃了那次机会。但今年，我在杭州，又没有理由不去，所以还是去了。之所以选择这个日子（4月28日），主要还是因为听说“山下智博”也会来展，想去见见，所以选择了今天。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"ACG","path":"api/tags/ACG.json"}]},{"title":"一周面试小结","slug":"recent-interviews-in-march-2017","date":"2017-03-25T01:38:09.000Z","updated":"2018-04-12T21:43:52.000Z","comments":true,"path":"api/articles/recent-interviews-in-march-2017.json","excerpt":"<h1 id=\"背景及摘要\"><a href=\"#背景及摘要\" class=\"headerlink\" title=\"背景及摘要\"></a>背景及摘要</h1><p>3 月 15 日，浙大玉泉校区举办了一场招聘会，近几百家单位参加。虽然我不是浙大本校生，但是外校学生若携带学生证件也是可以进入的。我总共带了 12 份简历前往，并全部投出。我的目标岗位为 Web 前端开发，但也对 Python / Node.js 后端有意向。目前我已进行了 3 次面试，分别是 <a href=\"https://www.lagou.com/gongsi/137471.html\" target=\"_blank\" rel=\"noopener\">数聚科技</a>, <a href=\"https://www.lagou.com/gongsi/178043.html\" target=\"_blank\" rel=\"noopener\">谷神星</a>, <a href=\"https://www.lagou.com/gongsi/210.html\" target=\"_blank\" rel=\"noopener\">企朋</a> （点击可查看拉钩网上的信息）。我想在这篇文章里分享一下我这几次的面试过程，谈谈我的一些想法，希望对大家有帮助。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[]},{"title":"howdoi 源码阅读与分析","slug":"source-code-of-howdoi","date":"2017-03-05T02:49:27.000Z","updated":"2018-04-12T21:44:04.000Z","comments":true,"path":"api/articles/source-code-of-howdoi.json","excerpt":"<p><a href=\"https://github.com/gleitz/howdoi\" target=\"_blank\" rel=\"noopener\">howdoi</a> – 一款通过命令行帮你从 stackoverflow 中寻找答案的工具，其源代码部分不足 300 行。同时，这份代码被 <a href=\"http://docs.python-guide.org/en/latest/writing/reading/\" target=\"_blank\" rel=\"noopener\">The Hitchhiker’s Guide to Python!</a> 推荐为适合新手源码阅读的代码。因此，在读完源码后，我分享一下我对这份代码的理解。</p>\n<p>这里采用的版本是 tree 中标号为 <a href=\"https://github.com/gleitz/howdoi/tree/d84afdee603dbe699153e35650d46ddd734337d1\" target=\"_blank\" rel=\"noopener\">d84afdee60</a> 的那一版</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"Python 对函数默认参数的处理","slug":"default-para-in-python","date":"2017-01-17T01:13:49.000Z","updated":"2018-04-12T21:41:58.000Z","comments":true,"path":"api/articles/default-para-in-python.json","excerpt":"<p>Python 对函数默认参数的处理</p>\n<p>一个以可变对象为默认参数的函数:</p>\n<pre><code class=\"Python\">class A:\n    def __init__(self):\n        self.x = 1\n        print(&#39;created&#39;)\n\ndef f(a = A()):\n    a.x += 1\n    print(a.x)\n# output: created\nf() # output: 2\nf() # output: 3\n</code></pre>\n<p>从结果可以看出，Python 在解析时便已经创建好了默认参数 a 的值。函数 f 在调用时采用了同一个对象，而不是每次调用时重新创建新的对象。这一点与 <code>C++</code> 的处理方式不同。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"初看 CPython","slug":"a-glance-at-cpython","date":"2017-01-05T01:24:13.000Z","updated":"2018-04-12T21:41:37.000Z","comments":true,"path":"api/articles/a-glance-at-cpython.json","excerpt":"<h1 id=\"什么是-CPython\"><a href=\"#什么是-CPython\" class=\"headerlink\" title=\"什么是 CPython\"></a>什么是 CPython</h1><p>简单的说, <code>CPython</code> 是 Python 解释器的一个实现。换句话说，Python 解释器是由 C 写的，然后由 GCC 之类的编译器编译而成的可执行文件。除了 CPython，还有 <a href=\"http://pypy.org/\" target=\"_blank\" rel=\"noopener\">PyPy</a>(用 Python 实现的 Python 解释器)，<a href=\"http://www.skulpt.org/\" target=\"_blank\" rel=\"noopener\">Skulpt</a>(用 JavaScript 实现的 Python 解释器) 等等。如果你不知道你用的是哪一个，那么你一定用的就是 CPython。因为 CPython 是 Python 官方的解释器实现，其它均属于第三方实现。</p>\n<h1 id=\"从源码到运行\"><a href=\"#从源码到运行\" class=\"headerlink\" title=\"从源码到运行\"></a>从源码到运行</h1><p>对于从 Python 源码到解释器执行它们的这个过程，我把它分为两大步 —— 编译(Compiling) 与 解释(Interpreting)。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"2016 -> 2017","slug":"the-end-of-2016","date":"2016-12-21T02:12:15.000Z","updated":"2018-04-12T21:45:31.000Z","comments":true,"path":"api/articles/the-end-of-2016.json","excerpt":"<p>（叹气）又是一年。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"kny","path":"api/categories/kny.json"}],"tags":[]},{"title":"延迟计算: 关于 Python 的 yield","slug":"python-yield-and-delay","date":"2016-12-13T02:07:06.000Z","updated":"2018-04-12T21:45:51.000Z","comments":true,"path":"api/articles/python-yield-and-delay.json","excerpt":"<p>在 SICP 第 3 章中，有一段部分内容是以 stream 为核心而展开的。而 stream 的特点就是 lazy evaluation / delayed evaluation （惰性求值 / 延迟计算）。在接触 stream 之时，我便立即联想到 Python 具有类似的功能 — <code>yield</code>。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"SICP","path":"api/tags/SICP.json"}]},{"title":"对 SICP Chapter 2 的一些理解","slug":"sicp-chapter-2-summary","date":"2016-12-04T04:01:22.000Z","updated":"2018-04-12T21:43:56.000Z","comments":true,"path":"api/articles/sicp-chapter-2-summary.json","excerpt":"<p>SICP 第二章的标题为 <em>“Building Abstractions with Data”</em>。与第一章标题<em>“Building Abstractions with Procedures”</em> 相比，这一章明显注重于在数据上的抽象。因此，在本章中所采用的例子中，会有多种数据类型被抽象出来，而每种数据类型又会对应着多种操作，那么随着代码量的增多，如何在不减少需求的情况下正确的对数据的抽象将直接影响开发者编码时的难度以及后期维护的成本。</p>\n<p>在阅读和练习完 Chapter 2 之后，我想谈一下对我思维冲击比较大的几个点。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"SICP","path":"api/tags/SICP.json"},{"name":"Scheme","path":"api/tags/Scheme.json"}]},{"title":"创建了适用于 hexo 的一个主题 mls","slug":"new-blog-theme-mls","date":"2016-11-11T00:46:55.000Z","updated":"2018-04-12T21:43:40.000Z","comments":true,"path":"api/articles/new-blog-theme-mls.json","excerpt":"<p>之前用的主题是基于 <a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">landscape</a>, 虽然这确实是一个不错的主题，使用上也没什么不便，但毕竟这是一个他人贡献的主题。我一直想试着自己做一个主题。之前也尝试在 landscape 上改，修改了一些颜色，对 CSS 做了一些简单修改，但布局没变，整体一眼还是能看出这是 landscape，并且因为我当时不熟悉 EJS 模板，对 Sass 及 CSS3 不是特别熟悉，所以有些功能的实现也完全不知道怎么做，比如一些透明效果的动画。</p>\n<p>最近一段时间，相对以前来说稍微不忙了点，所以趁这个机会试着做一个主题了。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"},{"name":"CSS","path":"api/tags/CSS.json"},{"name":"Sass","path":"api/tags/Sass.json"}]},{"title":"晴天 — TOEFL @ ZJU","slug":"toefl-10-29-zju","date":"2016-10-30T03:37:57.000Z","updated":"2018-04-12T21:44:29.000Z","comments":true,"path":"api/articles/toefl-10-29-zju.json","excerpt":"<h1 id=\"考前\"><a href=\"#考前\" class=\"headerlink\" title=\"考前\"></a>考前</h1><p>上一次考托福，考了 93。 这分数明显不够，上次出分立即报了一次。故意选择了跟上次一样的考场 — 浙大 E 考场，原因是不想去熟悉新考场了，找个已经去过的考场吧。</p>\n<p>在酒店里发生了一件小插曲，隔壁间的客户发现他们的卡不能打开房门，于是用我房间里的电话向前台求助。关键是这两位，同时也是一对情侣，也是到浙大考托福的，而且是从上海交大来的。女生表现比较开朗，在过程中了解到女生已经考出来了，而男生的成绩不理想，所以她只是陪男生来考试的。短暂的聊天中，并没提到女生的具体分数，但我猜她的分数应该还是比较不错的，因为她说了一句：“TOEFL 分数不需要很高，105 就已经足够了”。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"TOEFL","path":"api/categories/TOEFL.json"}],"tags":[{"name":"TOEFL","path":"api/tags/TOEFL.json"}]},{"title":"考 GRE @ Ningbo University","slug":"gre-at-ningbo-university","date":"2016-08-27T01:24:52.000Z","updated":"2018-04-12T21:42:13.000Z","comments":true,"path":"api/articles/gre-at-ningbo-university.json","excerpt":"<p>大约两个月前报名了在宁波大学的这场 GRE 考试。之所以选择宁波的这场考试，一是因为 8 月份杭州没有考位，只能另寻它处，二是相比与周围的考点（如苏州，南京等），宁波更近，方便我的来回。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"GRE","path":"api/categories/GRE.json"}],"tags":[{"name":"GRE","path":"api/tags/GRE.json"}]},{"title":"写在 TFT 小组 第 35 期 之后","slug":"after-tft-25","date":"2016-06-29T00:51:02.000Z","updated":"2018-04-12T21:41:48.000Z","comments":true,"path":"api/articles/after-tft-25.json","excerpt":"<p>在同学的介绍下，我报名了 <em>刘功勋</em> 老师的 TFT 35 期口语小组。之所以报名这个小组，理由也很简单 —— 就是为了学习口语，为 TOEFL 做准备。在昨天，小组正式结束，感觉收获颇多。同时，这几天又有一些其它想法涌上心头。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"TOEFL","path":"api/categories/TOEFL.json"}],"tags":[{"name":"TOEFL","path":"api/tags/TOEFL.json"},{"name":"TFT","path":"api/tags/TFT.json"}]},{"title":"Java 中 wait 与 notify 的简单操作","slug":"java-wait-notify-usage","date":"2016-02-16T03:05:51.000Z","updated":"2018-04-12T21:43:19.000Z","comments":true,"path":"api/articles/java-wait-notify-usage.json","excerpt":"<p>在我知道wait() 与 notify() 以前，我常常用一种看似很 low 的方式控制线程同步</p>\n<pre><code class=\"java\">while(condition) {\n  return ;\n}\n</code></pre>\n<p>实际上这个线程是一直在运行的，并没有操作系统概念中的阻塞（Block）。而要实现阻塞（Block）则要借助 Java 线程中的 wait() 操作 与 notify() 操作。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Thread","path":"api/tags/Thread.json"}]},{"title":"Java Arrays.asList 转化 int 数组为 List","slug":"java-arrays-aslist-int-array","date":"2016-02-10T03:40:01.000Z","updated":"2018-04-12T21:46:32.000Z","comments":true,"path":"api/articles/java-arrays-aslist-int-array.json","excerpt":"<h1 id=\"问题的发现\"><a href=\"#问题的发现\" class=\"headerlink\" title=\"问题的发现\"></a>问题的发现</h1><p>用 Arrays.asList 方法转化一 int 型数组为 List 类型</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"}]},{"title":"Python @staticmethod 与 @classmethod 的区别分析","slug":"staticmethod-and-classmethod-in-Python","date":"2016-02-04T02:33:09.000Z","updated":"2018-04-12T21:44:17.000Z","comments":true,"path":"api/articles/staticmethod-and-classmethod-in-Python.json","excerpt":"<p>乍一看之下，@staticmethod 与 @classmethod 真的很相似，貌似都可以看作是静态函数，除了后者必须有一个传入参数外就貌似没区别了。但既然加入了，那也一定有开发者的考虑了。</p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Python","path":"api/tags/Python.json"}]},{"title":"UVa1395 - Slim Span","slug":"uva1395","date":"2016-01-25T19:05:41.000Z","updated":"2018-04-12T21:44:33.000Z","comments":true,"path":"api/articles/uva1395.json","excerpt":"<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>首先有一点是可以确定的：对于任何一连通图，必有一生成树（简直废话）。<br>对于这一题，关键的问题是确定最大与最小。对于这种寻找两个相关变量的题，其实一般可以先试着确定一个，然后再去寻找另一个。<br>比如在这题中，可以迭代每一个边 L，同时把这条边 L 当做最小的边，用比它大的边去试着连同一幅图，知道找到边 R， 使得加上这条边 R 后刚好可以凑成一幅联通图。<br>因此，从上述思路可以看出，排序是必不可少了。所有排序是第一步。<br>排序好后进行遍历 L，建立 N （顶点数） 个并查集 S，每加入一条边就将该边的端点对应的并查集合并（前提是两个端点对应不同的并查集）。<br>直到刚好加入边 R 后，并查集只剩一个，且大小刚好与顶点数相等。此时对于 L 来说，R － L 极为其 “苗条度”。<br>因此对所有求得的“苗条度”求一个最小值即可。如果连一个“苗条度”都没有，那结果自然就是找不到合适的答案了。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","path":"api/tags/UVaOJ.json"}]},{"title":"修改 grub2 的启动主题以及等待时间","slug":"grub-theme","date":"2015-12-29T02:15:43.000Z","updated":"2018-04-12T21:42:21.000Z","comments":true,"path":"api/articles/grub-theme.json","excerpt":"<h1 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h1><p>已防万一，最好还是先做好备份:</p>\n<pre><code class=\"bash\">sudo cp -R /boot ~/\n</code></pre>\n<p>这里将 /boot 备份在了自己的 home 目录下， 需要的话，保存在其它地方也是一样的</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Operating System","path":"api/categories/Operating System.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"}]},{"title":"这一年就这样过去了","slug":"goodbye-2015","date":"2015-12-24T22:04:32.000Z","updated":"2018-04-12T21:42:10.000Z","comments":true,"path":"api/articles/goodbye-2015.json","excerpt":"<h1 id=\"Merry-Xmas\"><a href=\"#Merry-Xmas\" class=\"headerlink\" title=\"Merry Xmas\"></a>Merry Xmas</h1><p><strong>Merry Xmas!</strong><br><br>圣诞节悄然而至，再过几天就是2016了。已经不止一次这么感叹了：时间过得太快，总感觉这一年就这么没了。<br><br>对于2015年，总想写下一点内容，毕竟有些事情一直释怀不下，可能说出来会好一点。<br><img src=\"https://c.hime.io/images/R9k6.jpg\" alt=\"Pixiv Id 54204715\"></p>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[]},{"title":"UVa10285 - Longest Run on a Snowboard","slug":"uva10285","date":"2015-11-29T15:22:47.000Z","updated":"2018-04-12T21:44:37.000Z","comments":true,"path":"api/articles/uva10285.json","excerpt":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>假设从( x, y )出发，并且从( x, y )出发所能走的最长路为 d[x][y]，那么设想如果( x  - 1, y )的值（即题目所给的高度）要小于(x，y)，那么d[x-1][y] + 1 有可能就是我们所要求的d[x][y]，因为这条路是单向的，只可能从较小的(x-1， y)走向(x，y)。如果考虑四个方向，用(x’， y’)表示(x ， y)上下左右四个方向，那么d[x][y] = max(d[x’][y’]) + 1，且 (x’, y’)上的值要小于(x, y)。那么从这个方程可以看出这实际上可以采用 DFS 加上 dp 的做法，或者称之为记忆化搜索。而 搜索 的终点则是某点(x, y)的四周都比他大，则返回 1。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","path":"api/tags/UVaOJ.json"}]},{"title":"sort some list elements into an descreasing ones in js","slug":"list-sort-in-js","date":"2015-11-18T01:35:40.000Z","updated":"2018-04-12T21:43:27.000Z","comments":true,"path":"api/articles/list-sort-in-js.json","excerpt":"<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><p>Sort is a prevalent topic in programing. Although the sort operation mostly is handled by the back-end like PHP, Java and so on, occasionaly some are occured in front-end. Here are some simple instances I dealt with recently.</p>\n<h2 id=\"Bubble-like-Sort\"><a href=\"#Bubble-like-Sort\" class=\"headerlink\" title=\"Bubble-like Sort\"></a>Bubble-like Sort</h2><p>Suppose some list elements ordered as follows:</p>\n<pre><code class=\"html\">&lt;ul id=&quot;demo&quot;&gt;\n    &lt;li&gt;2&lt;/li&gt;\n    &lt;li&gt;1&lt;/li&gt;\n    &lt;li&gt;4&lt;/li&gt;\n    &lt;li&gt;3&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>Every time I filter through the nodes to get the smallest-value one from 1st one to 4nd one, and then I put it to the tail of lists. Next, I still filter to get the smallest-value one but from 1st one to 3nd one, and still put it to the tail to the lists. Now, two elements are sorted, and still two ones stay idle. The operation continues until all the elements have been sorted.<br>The produceres can be illustrated as follows:</p>\n<blockquote>\n<p>2 1 4 3 -&gt; 2 4 3 1 -&gt; 4 3 1 2 -&gt; 4 1 2 3 -&gt; 1 2 3 4</p>\n</blockquote>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"Copy the Command Line Outputs to Clipbord in Bash","slug":"xclip-intro","date":"2015-11-10T23:16:11.000Z","updated":"2018-04-12T21:44:54.000Z","comments":true,"path":"api/articles/xclip-intro.json","excerpt":"<h2 id=\"Preparation\"><a href=\"#Preparation\" class=\"headerlink\" title=\"Preparation\"></a>Preparation</h2><p>The involved tool is called <strong>xclip</strong>. So check whether the xclip had been installed or not.<br>If not, install it fitst:</p>\n<ul>\n<li>Fedora:<pre><code class=\"bash\">sudo dnf install xclip\n</code></pre>\n</li>\n</ul>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[{"name":"Linux","path":"api/tags/Linux.json"}]},{"title":"在JS中实现静态变量/函数","slug":"static-in-js","date":"2015-10-30T16:54:13.000Z","updated":"2018-04-12T21:44:13.000Z","comments":true,"path":"api/articles/static-in-js.json","excerpt":"<h2 id=\"静态变量-方法\"><a href=\"#静态变量-方法\" class=\"headerlink\" title=\"静态变量/方法\"></a>静态变量/方法</h2><p>静态变量/方法，一般来说是独立於对象的存在，它不属於任何一个具体的对象，它属於每一特定类的所有对象。也可以认为是属於一个类的。静态变量一般用於常数，或者存储某一类的所有对象需要共有的变量。<br>学JS的时候发现，与JAVA，C++相比，JS并没有明确定义静态的声明或使用方法。虽然没有说，但仍然需要，比如一个很经典的需要就时用静态变量统计一个类被实例化了几次。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"在初学JS时犯的一些错误","slug":"mis-in-js","date":"2015-10-25T00:18:27.000Z","updated":"2018-04-12T21:43:34.000Z","comments":true,"path":"api/articles/mis-in-js.json","excerpt":"<p>表示最近在学JS, 相对个人以前学的Python, JAVA之类的语言, JS的语言确实有一些”奇葩”. 把初学时的一些语法错误记录下来,方便自己以后查阅, 如果能帮助到读这篇文章的你自然就更好了.</p>\n<h2 id=\"number-与-string-相加-减-乘-除\"><a href=\"#number-与-string-相加-减-乘-除\" class=\"headerlink\" title=\"number 与 string 相加/减/乘/除\"></a>number 与 string 相加/减/乘/除</h2><h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example 1:\"></a>Example 1:</h3><pre><code class=\"js\">var a  = &quot;5&quot; + 2;   // the result is &quot;52&quot;\nvar b = 2 + &quot;5&quot;;    // the result is &quot;25&quot;\n</code></pre>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Front-end","path":"api/categories/Front-end.json"}],"tags":[{"name":"JavaScript","path":"api/tags/JavaScript.json"}]},{"title":"simulation of langton's ant","slug":"simulation-of-langton-s-ant","date":"2015-10-19T22:06:12.000Z","updated":"2018-04-12T21:43:59.000Z","comments":true,"path":"api/articles/simulation-of-langton-s-ant.json","excerpt":"<h2 id=\"Introduction-to-Langton’s-Ant\"><a href=\"#Introduction-to-Langton’s-Ant\" class=\"headerlink\" title=\"Introduction to Langton’s Ant\"></a>Introduction to Langton’s Ant</h2><p>简单来说 Langton’s ant 就是一个简单的数学游戏.</p>\n<p>在一平面上，存在无限的等大小的正方形方格，每一个方格要么是白色，要么是黑色. 我们在某一个上放了一只蚂蚁（Ant）. 这只蚂蚁每一步可以朝四个方向行走，并且每步行走遵从以下两条规则:</p>\n<ul>\n<li>如果蚂蚁在<strong>白</strong>色格子时，就会向<strong>右</strong>转90°，同时颠倒该格子的颜色（变为黑色），最后再向前走一步。</li>\n<li>如果蚂蚁在<strong>黑</strong>色格子时，就会向<strong>左</strong>转90°，同时颠倒该格子的颜色（变为白色），最后再向前走一步。</li>\n</ul>","keywords":null,"content":null,"raw":null,"categories":[{"name":"Math","path":"api/categories/Math.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"Math","path":"api/tags/Math.json"}]},{"title":"test","slug":"test","date":"2015-10-18T19:11:03.000Z","updated":"2018-04-12T20:46:47.000Z","comments":true,"path":"api/articles/test.json","excerpt":"<pre><code class=\"less\">// Colors\n@black: #414141;\n@white: #ffffff;\n@text-color:       @black;\n@background-color: #EBECEE;\n@brand-color:      @material-teal;\n@accent-color:         @material-orange;\n@grey-color:       #828282;\n</code></pre>","keywords":null,"content":null,"raw":null,"categories":[],"tags":[]},{"title":"（旧文）2015省赛小感想","slug":"acm-contest-in-zj-2015","date":"2015-05-02T15:52:32.000Z","updated":"2018-04-12T21:41:43.000Z","comments":true,"path":"api/articles/acm-contest-in-zj-2015.json","excerpt":"<p><strong>注意</strong>: 这篇文章我曾于 2015 年 5 月 2 日发表在 <a href=\"http://www.cnblogs.com/Emerald/p/4471775.html\" target=\"_blank\" rel=\"noopener\">CnBlog</a> 上。因为那个 blog 我已经几乎不维护，所以准备把部分文章转移至这里。另外，因为那时我还没有在 GitHub 上建立站点，所以这篇文章的发表时间早于这个站点的最早搭建时间。</p>\n<p>上个月26号，我有幸参加了今年的浙江省省赛。第一次参加正式的ACM比赛，心里略有点小激动。我的队友们也是第一次参加，还好同行的还有学长学姐们的队伍。</p>","keywords":null,"content":null,"raw":null,"categories":[{"name":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","path":"api/tags/ACM.json"}]}]