{"title":"联系 Koa.js 和 requests 看 HTTP 协议中的重定向","slug":"http-protocol-redirecting","date":"2018-01-04T21:29:09.000Z","updated":"2018-01-05T21:48:50.000Z","comments":true,"excerpt":"","content":"<p>在 HTTP 协议中，一般 3 开头的状态码，都用于表示 <code>重定向</code>：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。</p>\n<h1 id=\"Location\"><a href=\"#Location\" class=\"headerlink\" title=\"Location\"></a>Location</h1><p>为了告诉客户端应改前往哪一个页面，服务器在返回的响应 (response) 的 headers 中用 <code>Location</code> 字段标明具体应该访问的页面。</p>\n<p>例如，访问 <code>http://example.com</code> 时，如果服务器想让浏览器跳转到 <code>http://google.com</code>，可以在 response 中写:</p>\n<pre><code>HTTP/1.0 302 Redirect\nLocation: http://google.com\n</code></pre><p>一般浏览器收到后，会自动跳转。</p>\n<p>另外，URL 也可以标明为相对路径，比如，在上个例子中，如果跳转到 <code>http://example.com/hello.html</code>，则可以标记为:</p>\n<pre><code>HTTP/1.0 302 Redirect\nLocation: hello.html\n</code></pre><h1 id=\"Koa-js\"><a href=\"#Koa-js\" class=\"headerlink\" title=\"Koa.js\"></a>Koa.js</h1><p>在 Koa.js 中，context 有一个方法为 <code>redirect</code>，专门用于定向，而这个方法实际委托给了 <code>lib/response.js</code>。</p>\n<p>其具体代码为:</p>\n\n    <pre><code class=\"lang-js\">redirect(url, alt) {\n  <span class=\"hljs-comment\">// location</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'back'</span> == url) url = <span class=\"hljs-keyword\">this</span>.ctx.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">'Referrer'</span>) || alt || <span class=\"hljs-string\">'/'</span>;\n  <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">set</span>(<span class=\"hljs-string\">'Location'</span>, url);\n\n  <span class=\"hljs-comment\">// status</span>\n  <span class=\"hljs-keyword\">if</span> (!statuses.redirect[<span class=\"hljs-keyword\">this</span>.status]) <span class=\"hljs-keyword\">this</span>.status = <span class=\"hljs-number\">302</span>;\n\n  <span class=\"hljs-comment\">// html</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.ctx.accepts(<span class=\"hljs-string\">'html'</span>)) {\n    url = escape(url);\n    <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'text/html; charset=utf-8'</span>;\n    <span class=\"hljs-keyword\">this</span>.body = `Redirecting to &lt;a href=<span class=\"hljs-string\">\"<span class=\"hljs-subst\">${url}</span>\"</span>&gt;${url}&lt;/a&gt;.`;\n    <span class=\"hljs-keyword\">return</span>;\n  }\n\n  <span class=\"hljs-comment\">// text</span>\n  <span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'text/plain; charset=utf-8'</span>;\n  <span class=\"hljs-keyword\">this</span>.body = `Redirecting to ${url}.`;\n},\n</code></pre>\n<p>如果 URL 为 <code>back</code>，那么会跳转回请求来源的方向，比如你在 <code>http://github.com/lazzzis</code> 点击了 <code>lazzzis.github.io</code>，那么在请求 <code>lazzzis.github.io</code> 的 request 的头部中，字段为 <code>Referrer: http://github.com/lazzzis</code>。换句话说，<code>back</code> 的意思就是 “从哪里来，就回哪里去”。</p>\n<p>而 <code>this.set(&#39;Location&#39;, url)</code> 作用则就是之前说的，将头部 headers 中 <code>Location</code> 设置为客户端应该去访问的那个 URL。之后，便是将状态码设置为 302。</p>\n<p>这边，Koa.js 怕浏览器不会自动跳转，因此将也设置了消息主体部分，通知用户应该跳转。</p>\n<h1 id=\"requests\"><a href=\"#requests\" class=\"headerlink\" title=\"requests\"></a>requests</h1><p>接下来用 Python 的 requests 做实验。我们先用 Koa.js 写一个简单的服务端:</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">'koa'</span>)\n<span class=\"hljs-keyword\">const</span> koaLogger = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">'koa-logger'</span>)\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa()\n\napp.<span class=\"hljs-keyword\">use</span>(koaLogger())\n\napp.<span class=\"hljs-keyword\">use</span>(async (ctx, next) =&gt; {\n  ctx.redirect(<span class=\"hljs-string\">'http://lazzzis.github.io'</span>)\n})\n\napp.listen(<span class=\"hljs-number\">5000</span>)\n</code></pre>\n<p>然后发起请求:</p>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-keyword\">import</span> requests\n\nr = requests.post(<span class=\"hljs-string\">\"http://localhost:5000\"</span>)\n<span class=\"hljs-built_in\">print</span>(r.url)\n<span class=\"hljs-meta\"># http:<span class=\"hljs-comment\">//lazzzis.github.io</span></span>\n</code></pre>\n<p>可以发现，requests 已经帮我们做了自动跳转。如果不想让它跳转的话，可以设置 <code>allow_redirects</code> 参数（默认为 True）：</p>\n\n    <pre><code class=\"lang-python\">r = requests.post(<span class=\"hljs-string\">\"http://localhost:5000\"</span>, <span class=\"hljs-attribute\">allow_redirects</span>=<span class=\"hljs-literal\">False</span>)\n<span class=\"hljs-builtin-name\">print</span>(r.url)\n<span class=\"hljs-comment\"># http://localhost:5000/</span>\n<span class=\"hljs-builtin-name\">print</span>(r.text)\n<span class=\"hljs-comment\"># Redirecting to &lt;a href=\"http://lazzzis.github.io\"&gt;http://lazzzis.github.io&lt;/a&gt;.</span>\n</code></pre>\n<p>取消跳转后，可以看到它这次停止了跳转。关于限制跳转的相关源码在 <a href=\"https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py\" target=\"_blank\" rel=\"external\">requests.py</a> (代码太长，所以就不粘贴了)。</p>\n<p>在 653 行: <code>yield_requests=True</code> 使得在 resolve_redirects 中时，不会进入下一步的 send：在 206 - 225 的分支可以看到， 如果 <code>yield_requests=True</code>，那么 requests 会做接下来的请求。</p>\n<h2 id=\"获取下一个请求的-URL\"><a href=\"#获取下一个请求的-URL\" class=\"headerlink\" title=\"获取下一个请求的 URL\"></a>获取下一个请求的 URL</h2><p>在 <a href=\"https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py\" target=\"_blank\" rel=\"external\">requests.py</a> 的 98 行的 get_redirect_target 的实现中，<code>location = resp.headers[&#39;location&#39;]</code> 表明了这里的处理和 <code>Koa.js</code> 是一样的，也是从 <code>location</code> 字段获取。</p>\n<h2 id=\"更改请求方式\"><a href=\"#更改请求方式\" class=\"headerlink\" title=\"更改请求方式\"></a>更改请求方式</h2><p>另外，还有一个有意思的事情，我在请求的时候，发的是 <code>POST</code> 请求，可是 GitHub Pages 不支持 POST 的呀，那么 requests 一定换了另一种方法:</p>\n\n    <pre><code class=\"lang-python\">r = requests.post(<span class=\"hljs-string\">\"http://localhost:5000\"</span>)\nprint(r.request.method)\n<span class=\"hljs-comment\"># GET</span>\n</code></pre>\n<p>看的出来，requests 使其变为了 GET。这里的实现在于: <a href=\"https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py\" target=\"_blank\" rel=\"external\">requests.py</a> 的 164 行 <code>self.rebuild_method(prepared_request, resp)</code> 和 292 行开始的 <code>rebuild_method</code> 的实现。尤其是 304 行和 309 行，将请求方法改为了 <code>GET</code>。</p>\n<h2 id=\"递归请求\"><a href=\"#递归请求\" class=\"headerlink\" title=\"递归请求\"></a>递归请求</h2><p>这里想象两种极端情况。</p>\n<p>一是如果服务端 A 实现出错，使得要求客户端依旧跳到 A。那么，requests 请求 A, 而之后有继续请求 A。这样，陷入了一个死循环。</p>\n<p>第二种，类似，但不只一个服务器出错: A 要求跳转到 B，而 B 要求跳转到 C，可是 C 又要求跳转到 A，那么，这里也同样陷入了一个死循环。</p>\n<p>requests 考虑到了这点，做了限制，避免一直跳转:</p>\n<p>先对上面的服务端做一点修改:</p>\n\n    <pre><code class=\"lang-js\">app.use(<span class=\"hljs-keyword\">async</span> (ctx, next) =&gt; {\n  ctx.redirect(<span class=\"hljs-string\">'http://localhost:5000'</span>)\n})\n</code></pre>\n\n    <pre><code class=\"lang-python\"><span class=\"hljs-attr\">r</span> = requests.post(<span class=\"hljs-string\">\"http://localhost:5000\"</span>)\n<span class=\"hljs-comment\"># requests.exceptions.TooManyRedirects: Exceeded 30 redirects.</span>\n</code></pre>\n<p>python 自定义了一个异常，用于说明引起的原因是过多的重定向，并且说明了 requests 最先跳转次数为 30 次。</p>\n<p>可以看到在 <a href=\"https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py\" target=\"_blank\" rel=\"external\">requests.py</a> 的第 139 行处，requests 本身记录了请求的历史，如果历史条数，也就是请求的次数，大于限制时会抛出异常。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li><a href=\"http://shop.oreilly.com/product/9781565925090.do\" target=\"_blank\" rel=\"external\">HTTP: The Definitive Guide</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections\" target=\"_blank\" rel=\"external\">Redirections in HTTP</a></li>\n</ol>\n","categories":[],"tags":[{"name":"HTTP","path":"api/tags/HTTP.json"}]}