{"title":"拓扑排序 / topological sort","slug":"intro-of-topological-sort","date":"2017-11-23T01:42:24.000Z","updated":"2018-04-12T21:43:09.000Z","comments":true,"excerpt":"<p>问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png\" alt=\"\"></p>\n<p>其中, <code>1 -&gt; 3</code> 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。</p>\n<p>而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 <code>[1, 2, 4, 3, 5, 7, 6]</code>。</p>","content":"<p>问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png\" alt=\"\"></p>\n<p>其中, <code>1 -&gt; 3</code> 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。</p>\n<p>而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 <code>[1, 2, 4, 3, 5, 7, 6]</code>。</p>\n<a id=\"more\"></a>\n<h1 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h1><p>一个显然可以得到的观点就是，对于没有依赖的任务，可以直接将其放入所求的序列中， 比如上图中的 <code>[1, 2]</code>。</p>\n<p>那算法的第一步就是找出所有没有被依赖的任务，并将其移除，此时可以得到一个新的图:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo2.png\" alt=\"\"></p>\n<p>显然又可以发现，又出现了没有依赖的任务 <code>[4]</code>，那我们继续把它放入所求的序列中，并将其移除，得到的新的图:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo3.png\" alt=\"\"></p>\n<p>此时又得到新的图，而且同样出现了没有依赖的任务，所以继续把它放入序列中，将其移除。。。以此类推，每次移除没有依赖的点，得到新的图，继续移除没有依赖的点，直到所有的点都被移除了。</p>\n<p>我们首先需要用一种数据结构表示一点任务是否有依赖。那我们可以发现，用依赖的数量来表示是否有依赖非常合适。如最开始的图中:</p>\n<p>方块中的数字即表示旁边的任务的依赖数，如果数字为 0 即表示依赖为 0。而当我们把<code>[1, 2]</code> 移除后，相连的 <code>[3, 4]</code> 的依赖数必定会减少，变成如图所示:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo4.png\" alt=\"\"></p>\n<p>此时任务 4 的依赖数为 0，将其移除后，任务 3 的依赖数变为 0，任务 6 的依赖变为 2。所有下一次又移除 3。</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo5.png\" alt=\"\"></p>\n<p>而实际上，这里的依赖数有一个更专业的名词叫 <code>入度</code>。如其字面意思一样，对于某个点，有多少箭头指向它。</p>\n<p>主流的实现方法有两种，BFS 和 DFS 。因为我更喜欢 BFS，所以这里用 BFS 解释。其中 Queue 的实现可以参照<a href=\"https://gist.github.com/lazzzis/e07499c379bf9ec43066cc6c66b091f0\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n\n    <pre><code class=\"lang-js\"><span class=\"hljs-comment\">/**\n * numTasks 表示任务的数量，这里假设任务的 id 从 0 ~ numTasks\n *\n * prerequisites 是一个二维数组\n * 例如 [[3, 1], [4, 2], [3, 4]] 表示:\n * 任务 3 必须在任务 1 之后，任务 4 必须在任务 2 之后，任务 3 必须在任务 4 之后\n * 换言之，1 指向 3，2 指向 4，4 指向 1\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">topo</span> (<span class=\"hljs-params\">numTasks, prerequisites</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> indegrees = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(numTasks).fill(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 入度</span>\n\n  <span class=\"hljs-keyword\">const</span> links = <span class=\"hljs-built_in\">Array</span>.from({ <span class=\"hljs-attr\">length</span>: numTasks }).map(<span class=\"hljs-function\"><span class=\"hljs-params\">_</span> =&gt;</span> [])\n  <span class=\"hljs-comment\">// 用一个二维数组表示图</span>\n  <span class=\"hljs-comment\">// 比如数组 links[5] = [6, 7] 表示 5 指向 6 与 7</span>\n\n  prerequisites.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">[second, first]</span>) =&gt;</span> {\n    indegrees[second]++\n    links[first].push(second)\n  })\n\n  <span class=\"hljs-keyword\">const</span> q = <span class=\"hljs-keyword\">new</span> Queue()\n  <span class=\"hljs-keyword\">const</span> ans = []\n  <span class=\"hljs-comment\">// 寻找 入度 为 0 的点</span>\n  ;[...Array(numTasks).keys()].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">i</span> =&gt;</span> !indegrees[i]).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> q.push(x))\n  <span class=\"hljs-keyword\">while</span> (!q.empty()) {\n    <span class=\"hljs-keyword\">const</span> top = q.pop()\n    ans.push(top)\n    <span class=\"hljs-comment\">// 移除这个点的对应的边，所以相连的任务的入度都减一</span>\n    links[top].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> indegrees[x]--)\n    <span class=\"hljs-comment\">// 入度减小的这些任务中是否有入度为 0 的点</span>\n    links[top].filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> !indegrees[x]).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> q.push(x))\n  }\n  <span class=\"hljs-keyword\">return</span> ans\n</code></pre>\n<p>对于此图的运行结果:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo7.png\" alt=\"\"></p>\n\n    <pre><code class=\"lang-js\">&gt; topo(<span class=\"hljs-number\">7</span>, [[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]])\n[ <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span> ]\n</code></pre>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><p>假设顶点数为 V，边的数目为 E，时间复杂度上讲，应该为 O(V + E)。</p>\n<p>因为每一个点仅仅被访问一次，而每条边也都会被移除一次。</p>\n<h2 id=\"存在环\"><a href=\"#存在环\" class=\"headerlink\" title=\"存在环\"></a>存在环</h2><p>如果存在环，那么在某个时刻存在入度不为 0 的点，如下图所示:</p>\n<p><img src=\"https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo6.png\" alt=\"\"></p>\n<p>这种情况下，一般需要判断最后的序列长度是否为 <code>numTasks</code>。如果不是，则存在环。所以，这个算法也可以用于判断环的存在与否。</p>\n<p>特别注意的是，即使存在环，上述代码中 <code>while (!q.empty())</code> 也不会陷入死循环，原因是 <code>q</code> 包含的是入度为 0 的点，如果不存在了入度为 0 的点，那么就会终止循环。</p>\n<h1 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h1><ol>\n<li><a href=\"https://leetcode.com/problems/course-schedule/description/\" target=\"_blank\" rel=\"noopener\">LeetCode 207. Course Schedule</a></li>\n<li><a href=\"https://leetcode.com/problems/course-schedule-ii/description/\" target=\"_blank\" rel=\"noopener\">LeetCode 210. Course Schedule II</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=1285\" target=\"_blank\" rel=\"noopener\">HDU 1285 确定比赛名次</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2094\" target=\"_blank\" rel=\"noopener\">HDU 2094 产生冠军</a></li>\n</ol>\n<h1 id=\"最后再说几句\"><a href=\"#最后再说几句\" class=\"headerlink\" title=\"最后再说几句\"></a>最后再说几句</h1><p>最初这题是一位 FaceBook 的学长给我做 mock interview 出的题目。当时我知道这是拓扑排序，但没想到的是，我因为长期没有做这类题，已经完全忘记了它的具体做法。在当时的情况下，我并没有想起来怎么去做这题。所以说，平时偶尔还是要刷一些已经刷过的题呀。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://en.wikipedia.org/wiki/Topological_sorting\" target=\"_blank\" rel=\"noopener\">Wiki Topological Sorting</a></li>\n</ol>\n","categories":[],"tags":[{"name":"ACM","path":"api/tags/ACM.json"},{"name":"JavaScript","path":"api/tags/JavaScript.json"}]}