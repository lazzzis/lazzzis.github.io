<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lazzzis</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lazzzis.moe/"/>
  <updated>2018-04-07T20:11:24.000Z</updated>
  <id>https://lazzzis.moe/</id>
  
  <author>
    <name>lazzzis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 vue 写一个单页的 hexo 主题</title>
    <link href="https://lazzzis.moe/2018/04/05/hexo-theme-of-spa-in-vue/"/>
    <id>https://lazzzis.moe/2018/04/05/hexo-theme-of-spa-in-vue/</id>
    <published>2018-04-06T01:51:32.000Z</published>
    <updated>2018-04-07T20:11:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概一年以前，我发布过一个主题，名为 <a href="https://github.com/lazzzis/hexo-theme-mls" target="_blank" rel="noopener">hexo-theme-mls</a>。这个主题是我当时在学完如何写一个 hexo 主题后完成的。后来在学了 vue 之后，构思着再写一个主题。我非常想把它写成一个单页应用，可是一直没有思绪。直到后来看到了 <a href="https://github.com/EYHN/hexo-theme-one" target="_blank" rel="noopener">hexo-theme-one</a>，我才有了思绪，于是开始写一个单页的主题。</p><h1 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h1><p>首先一个问题就是，如何生成 json 文件，用于前端的异步数据请求。<a href="https://github.com/yscoder/hexo-generator-restful" target="_blank" rel="noopener">hexo-generator-restful</a> 提供了很好的思路，hexo 在执行的时候，会载入主题文件夹下的 scripts 下的文件并执行。而 hexo 提供了一个接口，可以用于在读取所有博客内容之后，生成所有文件之前，添加需要生成的文件。</p><p><a href="https://hexo.io/api/generator.html" target="_blank" rel="noopener">generator</a> 接口即是需要的接口。注册一个函数，这个函数可以在执行完后返回一个数组，数组每一个元素即是一个将要生成的文件的信息，这个信息包括:</p>    <pre><code class="lang-js">{    <span class="hljs-attribute">path</span>: post.path, <span class="hljs-comment">// 路径</span>    <span class="hljs-attribute">data</span>: post, <span class="hljs-comment">// 这个文件的内容</span>    <span class="hljs-attribute">layout</span>: <span class="hljs-string">'post'</span> <span class="hljs-comment">// 布局</span>}</code></pre><p>一般文件生成后会在 public 文件夹下，那么这个路径只要是相对 public 即可，比如 <code>api/posts.json</code>，则会在 <code>public/api/posts.json</code>。至于文件内容，因为这个 data 一般要求是字符串或流 (stream)，所以我选择用 JSON.stringify() 将需要的数据 (对象) 转化为字符串。</p><h2 id="那么最终需要生成哪些-json-文件呢"><a href="#那么最终需要生成哪些-json-文件呢" class="headerlink" title="那么最终需要生成哪些 json 文件呢?"></a>那么最终需要生成哪些 json 文件呢?</h2><h3 id="所有的-posts-数据"><a href="#所有的-posts-数据" class="headerlink" title="所有的 posts 数据"></a>所有的 posts 数据</h3><p>一个 <code>posts.json</code> 记录了这个博客所有的博客大概信息 (每篇博客的标题，包含的标签，发布日期等)，但不包含博客文章的具体内容，因为如果将所有文章内容放进一个文件的话，那么这个文件可能非常大。因而，准备再生成一个 <code>post/</code> 文件夹，下面存放了各个博客文章的具体信息。如果一篇博文标题为 <code>Foo</code>。那么请求 <code>api/post/Foo.json</code> 可以拿到这篇博文的具体信息。</p><h3 id="所有的-tags-数据"><a href="#所有的-tags-数据" class="headerlink" title="所有的 tags 数据"></a>所有的 tags 数据</h3><p>类似于 posts 数据，一个 <code>tags</code> 用于说明这个博文下所有的 tag，一个 <code>tag/</code> 文件夹包含每一个 tag 的具体信息（这个 tag 下有哪一些文章）。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>一些配置信息，比如 siteConfig，和 themeConfig。另外如果有自定义 page 的话，再放一些信息于 <code>page/</code> 文件夹下。</p><h1 id="404-处理"><a href="#404-处理" class="headerlink" title="404 处理"></a>404 处理</h1><p>这个是我当时最头疼的一个问题，毕竟 hexo 当初又不是为单页设计的，估计也考虑不到这个问题。</p><p>我有一个路由是 <code>/posts</code>。但在 <code>hexo g</code> 运行完后，在 <code>public</code> 目录下面是没有 <code>posts/index.html</code> 这个文件的。因此如果运行 <code>hexo s</code> 的时候，如果直接访问 <code>localhost:4000</code>。那么 hexo 会直接报错，提示 <code>Can not get /posts</code>。如果要解决这个问题，那么我必须在所有可能的路由下生成 <code>index.html</code>。如果我有 100 个路由，那么我需要生成在 100 个文件夹下生成共计 100 个 <code>index.html</code>。</p><p>可是这很明显不符合我对 <code>SPA</code> 的预期。按照最初的想法，我只需要一个 <code>index.html</code>。无论浏览器访问哪个路由，后端都能返回同一个 <code>index.html</code>。这一点可以参考 <code>vue-router</code> 官网上对 404 重定向的一个说明 – <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 History 模式</a>。</p><p>当然我上面这么说的自然原因是我采用了 <code>HTML5 History</code> 模式。我当然可以选择放弃这种模式，采用 URL hash 的方式。也就是说，我的博客地址会变成 <code>/#/post/foo</code> 的样子。但这里又出现了另外一个问题，disqus 对评论的获取是不考虑 <code>#</code> 之后的内容。换句话说，如果用户访问 <code>/#/post/foo</code> 和 <code>/#/post/bar</code> 时，disqus 都会去拿 <code>/</code> 路由对应的评论，所有的页面评论就全部一样了!</p><p>因此我不得不再继续思考如何采用上 <code>HTML5 History</code> 模式。如果只考虑部署的话，GitHub Pages 有 404 重定向的方式 (建立 404.html) 以及 nginx 也有类似功能。所有在部署之后是不会有这问题，我需要做的，是对 <code>hexo s</code> 的扩充。</p><p><code>hexo</code> 确实开放了对 <code>hexo s</code> 的扩充的接口，结合这个 ISSUE: <a href="https://github.com/hexojs/hexo/issues/1030" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1030</a>。我可以在 <code>hexo s</code> 中实现在 404 时的重定向了。但有两种方案:</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h2>    <pre><code class="lang-js">hexo.extend.filter.register(<span class="hljs-string">'server_middleware'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_404middleware</span> <span class="hljs-params">(app)</span></span> {  app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle404</span><span class="hljs-params">(req, res, next)</span></span> {    const s = fs.createReadStream(      <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">'../../../'</span>, hexo.<span class="hljs-built_in">config</span>.public_dir, <span class="hljs-string">'./index.html'</span>)    )    s.pipe(res)  }, <span class="hljs-number">99</span>)})</code></pre><p>这种方法，就是直接读取生成好的 index.html 返回。这种方案在大部分情况下可行。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二:"></a>方案二:</h2>    <pre><code class="lang-js">hexo.<span class="hljs-built_in">extend</span>.<span class="hljs-built_in">filter</span>.register(<span class="hljs-string">'server_middleware'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> _404<span class="hljs-title">middleware</span> <span class="hljs-params">(app)</span> {</span>  app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle404</span><span class="hljs-params">(req, res, next)</span> {</span>    const { pathname } = url.parse(req.url)    <span class="hljs-keyword">if</span> (!pathname.endsWith(<span class="hljs-string">'.json'</span>)) {      <span class="hljs-keyword">res</span>.writeHead(<span class="hljs-number">302</span>, {        <span class="hljs-string">'Location'</span>: url.<span class="hljs-built_in">resolve</span>(hexo.config.root, <span class="hljs-string">'404.html?redirect='</span> + req.url)      })      <span class="hljs-keyword">res</span>.end()    } <span class="hljs-keyword">else</span> {      <span class="hljs-keyword">next</span>()    }  }, <span class="hljs-number">99</span>)})</code></pre><p>其中 99 代表 priority。默认 server 的值为 10。priority 越小越先执行。让默认服务先运行，如果出现 404，那么上面的代码才会执行，进行重定向。注意我增加了一个 <code>redirect</code> 的请求参数，专门用于在前端继续跳转一次。如果不跳转，前端 url 就变成了 <code>/404.html</code>。但我想在当前 URL 下也能显示 404 页面，比如在 <code>/post/xx</code> 页面下显示 404 的内容，而不是跳转到 <code>/404.html</code> 显示。其中注意不要对 <code>json</code> 文件进行处理，仅对一般请求处理即可。</p><p>方案二，和方案一相比，两者都不算美观，并不能说是我最满意的方案。但相比之下，方案二，还好一点，原因是方案一一个明显的问题就是，它的成功运行是基于 public 目录下存在 <code>index.html</code> 的前提下。如果这个前提不满足，那么就无法继续。因此我暂时采用了方案二。</p><h1 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h1><p>上面讲的，其实大多是 hexo 相关内容。至于页面设计就简单多了，因为后端路由已经解决了。前端实际上只是样式的问题。因为当时想做的简单一点，于是才用了 <a href="https://milligram.io/" target="_blank" rel="noopener">milligram</a> 这么一个纯 css 的极简框架。</p><p>加上 vue 全家桶，以及 axios 用作异步请求工具，前端开发似乎并没有遇到什么大困难。</p><p>唯一可能算的上问题的或许是字体问题吧。原本字体用的是 google fonts 的链接，而总所周知，这在国内体验很不好，因此花了点时间，把字体从网上下载，并写成 css 引用的方式，打包成为主题的一部分。</p><h1 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h1><p>我考虑过要不要加上多语言支持，也就是 <code>i18n</code>。不过感觉没什么必要，并没有那么多需要翻译的。所以这个坑就先留着吧。</p><p>在我写这篇文章的时候，<a href="https://hexo.io/themes" target="_blank" rel="noopener">hexo.io/themes</a> 也有了一些其它单页应用的主题，或许未来应该有更多的吧。可能 hexo 未来会对单页应用的博客做一些相关的支持，也可能会出现一款为单页应用博客而定制的博客生成器吧。</p><p>另外，记得刚把这个发布并用在自己博客上的时候，有伙伴吐槽 “有点丑呀”。或许吧，和其它主题比起来，确实“朴素”了太多。不过不知道为什么，现在的我确实喜欢这样的“朴素”了呢。</p><p>顺便贴一下项目地址，<a href="https://github.com/lazzzis/hexo-theme-only" target="_blank" rel="noopener">hexo-theme-only</a>。欢迎使用和提供批评意见。</p><hr><p><img src="https://raw.githubusercontent.com/lazzzis/private-static/master/images/sankarea.png?token=AJ4R16LxM7Cb3eb9LnXgz--LkUDNpNCPks5a0RAMwA%3D%3D" alt="散华礼弥"><span class="image-caption">散华礼弥</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大概一年以前，我发布过一个主题，名为 &lt;a href=&quot;https://github.com/lazzzis/hexo-theme-mls&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-theme-mls&lt;/a&gt;。这个主题是我当时在学完如何写一个
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>联系 Koa.js 和 requests 看 HTTP 协议中的重定向</title>
    <link href="https://lazzzis.moe/2018/01/04/http-protocol-redirecting/"/>
    <id>https://lazzzis.moe/2018/01/04/http-protocol-redirecting/</id>
    <published>2018-01-04T21:29:09.000Z</published>
    <updated>2018-01-05T21:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 HTTP 协议中，一般 3 开头的状态码，都用于表示 <code>重定向</code>：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。</p><h1 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h1><p>为了告诉客户端应改前往哪一个页面，服务器在返回的响应 (response) 的 headers 中用 <code>Location</code> 字段标明具体应该访问的页面。</p><p>例如，访问 <code>http://example.com</code> 时，如果服务器想让浏览器跳转到 <code>http://google.com</code>，可以在 response 中写:</p><pre><code>HTTP/1.0 302 RedirectLocation: http://google.com</code></pre><p>一般浏览器收到后，会自动跳转。</p><p>另外，URL 也可以标明为相对路径，比如，在上个例子中，如果跳转到 <code>http://example.com/hello.html</code>，则可以标记为:</p><pre><code>HTTP/1.0 302 RedirectLocation: hello.html</code></pre><h1 id="Koa-js"><a href="#Koa-js" class="headerlink" title="Koa.js"></a>Koa.js</h1><p>在 Koa.js 中，context 有一个方法为 <code>redirect</code>，专门用于定向，而这个方法实际委托给了 <code>lib/response.js</code>。</p><p>其具体代码为:</p>    <pre><code class="lang-js">redirect(url, alt) {  <span class="hljs-comment">// location</span>  <span class="hljs-keyword">if</span> (<span class="hljs-string">'back'</span> == url) url = <span class="hljs-keyword">this</span>.ctx.<span class="hljs-keyword">get</span>(<span class="hljs-string">'Referrer'</span>) || alt || <span class="hljs-string">'/'</span>;  <span class="hljs-keyword">this</span>.<span class="hljs-keyword">set</span>(<span class="hljs-string">'Location'</span>, url);  <span class="hljs-comment">// status</span>  <span class="hljs-keyword">if</span> (!statuses.redirect[<span class="hljs-keyword">this</span>.status]) <span class="hljs-keyword">this</span>.status = <span class="hljs-number">302</span>;  <span class="hljs-comment">// html</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ctx.accepts(<span class="hljs-string">'html'</span>)) {    url = escape(url);    <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'text/html; charset=utf-8'</span>;    <span class="hljs-keyword">this</span>.body = `Redirecting to &lt;a href=<span class="hljs-string">"<span class="hljs-subst">${url}</span>"</span>&gt;${url}&lt;/a&gt;.`;    <span class="hljs-keyword">return</span>;  }  <span class="hljs-comment">// text</span>  <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'text/plain; charset=utf-8'</span>;  <span class="hljs-keyword">this</span>.body = `Redirecting to ${url}.`;},</code></pre><p>如果 URL 为 <code>back</code>，那么会跳转回请求来源的方向，比如你在 <code>http://github.com/lazzzis</code> 点击了 <code>lazzzis.github.io</code>，那么在请求 <code>lazzzis.github.io</code> 的 request 的头部中，字段为 <code>Referrer: http://github.com/lazzzis</code>。换句话说，<code>back</code> 的意思就是 “从哪里来，就回哪里去”。</p><p>而 <code>this.set(&#39;Location&#39;, url)</code> 作用则就是之前说的，将头部 headers 中 <code>Location</code> 设置为客户端应该去访问的那个 URL。之后，便是将状态码设置为 302。</p><p>这边，Koa.js 怕浏览器不会自动跳转，因此将也设置了消息主体部分，通知用户应该跳转。</p><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>接下来用 Python 的 requests 做实验。我们先用 Koa.js 写一个简单的服务端:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa'</span>)<span class="hljs-keyword">const</span> koaLogger = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa-logger'</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()app.<span class="hljs-keyword">use</span>(koaLogger())app.<span class="hljs-keyword">use</span>(async (ctx, next) =&gt; {  ctx.redirect(<span class="hljs-string">'http://lazzzis.github.io'</span>)})app.listen(<span class="hljs-number">5000</span>)</code></pre><p>然后发起请求:</p>    <pre><code class="lang-python"><span class="hljs-keyword">import</span> requestsr = requests.post(<span class="hljs-string">"http://localhost:5000"</span>)<span class="hljs-built_in">print</span>(r.url)<span class="hljs-meta"># http:<span class="hljs-comment">//lazzzis.github.io</span></span></code></pre><p>可以发现，requests 已经帮我们做了自动跳转。如果不想让它跳转的话，可以设置 <code>allow_redirects</code> 参数（默认为 True）：</p>    <pre><code class="lang-python">r = requests.post(<span class="hljs-string">"http://localhost:5000"</span>, <span class="hljs-attribute">allow_redirects</span>=<span class="hljs-literal">False</span>)<span class="hljs-builtin-name">print</span>(r.url)<span class="hljs-comment"># http://localhost:5000/</span><span class="hljs-builtin-name">print</span>(r.text)<span class="hljs-comment"># Redirecting to &lt;a href="http://lazzzis.github.io"&gt;http://lazzzis.github.io&lt;/a&gt;.</span></code></pre><p>取消跳转后，可以看到它这次停止了跳转。关于限制跳转的相关源码在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py" target="_blank" rel="noopener">requests.py</a> (代码太长，所以就不粘贴了)。</p><p>在 653 行: <code>yield_requests=True</code> 使得在 resolve_redirects 中时，不会进入下一步的 send：在 206 - 225 的分支可以看到， 如果 <code>yield_requests=True</code>，那么 requests 会做接下来的请求。</p><h2 id="获取下一个请求的-URL"><a href="#获取下一个请求的-URL" class="headerlink" title="获取下一个请求的 URL"></a>获取下一个请求的 URL</h2><p>在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py" target="_blank" rel="noopener">requests.py</a> 的 98 行的 get_redirect_target 的实现中，<code>location = resp.headers[&#39;location&#39;]</code> 表明了这里的处理和 <code>Koa.js</code> 是一样的，也是从 <code>location</code> 字段获取。</p><h2 id="更改请求方式"><a href="#更改请求方式" class="headerlink" title="更改请求方式"></a>更改请求方式</h2><p>另外，还有一个有意思的事情，我在请求的时候，发的是 <code>POST</code> 请求，可是 GitHub Pages 不支持 POST 的呀，那么 requests 一定换了另一种方法:</p>    <pre><code class="lang-python">r = requests.post(<span class="hljs-string">"http://localhost:5000"</span>)print(r.request.method)<span class="hljs-comment"># GET</span></code></pre><p>看的出来，requests 使其变为了 GET。这里的实现在于: <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py" target="_blank" rel="noopener">requests.py</a> 的 164 行 <code>self.rebuild_method(prepared_request, resp)</code> 和 292 行开始的 <code>rebuild_method</code> 的实现。尤其是 304 行和 309 行，将请求方法改为了 <code>GET</code>。</p><h2 id="递归请求"><a href="#递归请求" class="headerlink" title="递归请求"></a>递归请求</h2><p>这里想象两种极端情况。</p><p>一是如果服务端 A 实现出错，使得要求客户端依旧跳到 A。那么，requests 请求 A, 而之后有继续请求 A。这样，陷入了一个死循环。</p><p>第二种，类似，但不只一个服务器出错: A 要求跳转到 B，而 B 要求跳转到 C，可是 C 又要求跳转到 A，那么，这里也同样陷入了一个死循环。</p><p>requests 考虑到了这点，做了限制，避免一直跳转:</p><p>先对上面的服务端做一点修改:</p>    <pre><code class="lang-js">app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {  ctx.redirect(<span class="hljs-string">'http://localhost:5000'</span>)})</code></pre>    <pre><code class="lang-python"><span class="hljs-attr">r</span> = requests.post(<span class="hljs-string">"http://localhost:5000"</span>)<span class="hljs-comment"># requests.exceptions.TooManyRedirects: Exceeded 30 redirects.</span></code></pre><p>python 自定义了一个异常，用于说明引起的原因是过多的重定向，并且说明了 requests 最先跳转次数为 30 次。</p><p>可以看到在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py" target="_blank" rel="noopener">requests.py</a> 的第 139 行处，requests 本身记录了请求的历史，如果历史条数，也就是请求的次数，大于限制时会抛出异常。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://shop.oreilly.com/product/9781565925090.do" target="_blank" rel="noopener">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" target="_blank" rel="noopener">Redirections in HTTP</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 HTTP 协议中，一般 3 开头的状态码，都用于表示 &lt;code&gt;重定向&lt;/code&gt;：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。&lt;/p&gt;
&lt;h1 id=&quot;Location&quot;&gt;&lt;a href=&quot;#Location&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>2017 -&gt; 2018</title>
    <link href="https://lazzzis.moe/2017/12/29/the-end-of-2017/"/>
    <id>https://lazzzis.moe/2017/12/29/the-end-of-2017/</id>
    <published>2017-12-29T19:31:46.000Z</published>
    <updated>2017-12-29T19:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一年差不多在这时也写了这么一个年终总结，今年也写一个吧。</p><h1 id="之前定的目标实现了么"><a href="#之前定的目标实现了么" class="headerlink" title="之前定的目标实现了么"></a>之前定的目标实现了么</h1><h2 id="有些实现了，尽管很不完美。"><a href="#有些实现了，尽管很不完美。" class="headerlink" title="有些实现了，尽管很不完美。"></a>有些实现了，尽管很不完美。</h2><p>申请学校实际上只申请到了保底校，但最后还是接受了并现在在美帝上学。</p><p>乐理的坑没有填玩，最近才学了大概三个月，学得很慢，毕竟自己以前没有受过什么这方面训练。不过欣慰的是，确实看到自己在成长：在三个月前，我才知道音乐中有音乐的存在，原来音符分为四分音符，八分音符等等，到之后知道了一个高音谱表上各条线和间代表了什么音，在到现在能判断两个音之间的音程和初步了解了常用和弦的构造。对于我来说，这是很大成长了。更重要的是，我对音乐有更包容了 – 以前我的音乐大多集中在 ACG 相关音乐，而现在我也愿意去了解其它音乐 – 名摇，后摇，古典，各种摇滚等。这让我有了更大的视野。</p><h2 id="有些依旧是这样"><a href="#有些依旧是这样" class="headerlink" title="有些依旧是这样"></a>有些依旧是这样</h2><p>记得去年说要了解现实世界与未来，结果现在还是很迷茫，有几次都差点失望了。</p><p>说好的继续学习计算机和英语，实际上并没有太大进步，感觉一直在吃老本。尤其是英语，来了美帝之后反而更差了。。</p><h1 id="我做了什么"><a href="#我做了什么" class="headerlink" title="我做了什么"></a>我做了什么</h1><ul><li>写了十三篇博文</li><li>又写了一个 hexo 主题</li><li>把 Putong OJ 完成并上线了</li><li>来了美帝入学</li><li>入了一把电吉它</li><li>参加了一个漫展</li></ul><p>其中没有参加漫展是去年后悔的事，今年弥补了，也算填了一个坑。</p><p>这些算是映像比较深或花了比较多时间的事了，其它小事就略过了。</p><h1 id="我后悔什么"><a href="#我后悔什么" class="headerlink" title="我后悔什么"></a>我后悔什么</h1><p>很少后悔了，倒不是因为没有做错事，而是做事之前有了心理准备，就算做错了也要学会去接受或者挽救，而不是只会后悔。</p><h1 id="我还要做什么"><a href="#我还要做什么" class="headerlink" title="我还要做什么"></a>我还要做什么</h1><p>其实基本还去年一样，坑没有填完：</p><ul><li>乐理才学了不久，希望不会中途断掉</li><li>想法设法提高自己的英语</li><li>希望不再迷茫吧</li></ul><h1 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h1><p>今年这篇很短，确实没什么好说的。如果要像去年一样给自己评个分，那么在总分 5 分的情况下，我会给自己 1.5 分，因为今年除了一般之外，还没有任何的进步：就像上文说的一样，在吃老本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一年差不多在这时也写了这么一个年终总结，今年也写一个吧。&lt;/p&gt;
&lt;h1 id=&quot;之前定的目标实现了么&quot;&gt;&lt;a href=&quot;#之前定的目标实现了么&quot; class=&quot;headerlink&quot; title=&quot;之前定的目标实现了么&quot;&gt;&lt;/a&gt;之前定的目标实现了么&lt;/h1&gt;&lt;h2 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP 协议中的 ETag 与 If-None-Match</title>
    <link href="https://lazzzis.moe/2017/12/28/http-protocol-etag-if-none-match/"/>
    <id>https://lazzzis.moe/2017/12/28/http-protocol-etag-if-none-match/</id>
    <published>2017-12-28T22:26:57.000Z</published>
    <updated>2017-12-28T22:39:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。</p><p>软件开发常常有版本号的概念，比如 <code>1.0</code>, <code>1.1</code>, <code>2.0</code> 等等。软件使用者通常会在客户端版本落后于服务器最新版本时才会去服务器获取新的软件。</p><p>这一理念也用于了浏览器缓存策略中。结合下面这张图为例，浏览器已经缓存了 <code>foo.jpg</code> 且已记录版本号为<code>1.2</code> (这个版本号由服务器生成并告诉浏览器)，那么当浏览器再次请求 <code>foo.jpg</code> 时，就会同时把版本号也放在请求头中。这样，服务器收到请求时，就知道了客户端已缓存的文件的版本。如果服务器中的 <code>foo.jpg</code> 版本也是 <code>1.2</code>，那么服务器就可以说 <code>304 Not Modified</code>，不用再将 <code>foo.jpg</code> 传给了浏览器，因此就节省了带宽。反之，如果服务器端的 <code>foo.jpg</code> 已经 <code>1.3</code> 了，那么就要将新的文件传给浏览器，也同时告诉它版本号为 <code>1.3</code>，浏览器收到后，缓存文件，并记录版本号为 <code>1.3</code>。</p><p><img src="https://i.loli.net/2017/12/29/5a4566269629e.png" alt=""></p><p>ETag 是 Response Header 中的一个字段，而与之对应的一个出现在请求头中的字段为 <code>If-None-Match</code>。<code>If-None-Match</code> 对应的值即为浏览器缓存的的文件的版本号。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>使用 Koa 框架为例:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa'</span>)<span class="hljs-keyword">const</span> koaLogger = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa-logger'</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>)<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()app.<span class="hljs-keyword">use</span>(koaLogger())app.<span class="hljs-keyword">use</span>(async (ctx, next) =&gt; {  <span class="hljs-keyword">if</span> (ctx.get(<span class="hljs-string">'if-none-match'</span>) &amp;&amp; ctx.get(<span class="hljs-string">'if-none-match'</span>) === <span class="hljs-string">'foobar'</span>) {    ctx.status = <span class="hljs-number">304</span>  } <span class="hljs-keyword">else</span> {    ctx.status = <span class="hljs-number">200</span>    ctx.type = <span class="hljs-string">'json'</span>    ctx.set(<span class="hljs-string">'etag'</span>, <span class="hljs-string">'foobar'</span>)    ctx.body = fs.createReadStream(<span class="hljs-string">'package.json'</span>)  }})app.listen(<span class="hljs-number">5000</span>)</code></pre><p>这次我们把它标记为 <code>foobar</code>。注意版本号并不一定要像软件开发的版本号具有语义化，相反它可以是任意字符串，只要确保两个版本间的版本号不一样就行。</p><p><img src="https://i.loli.net/2017/12/29/5a45662a0d0de.png" alt=""></p><p>如图，第一次向 <code>localhost:5000/package.json</code> 发起请求，返回头中包含了 <code>etag: foobar</code>。因此是第一次请求，所以请求头之中没有 <code>If-None-Match</code> 字段。</p><p>刷新页面继续请求：</p><p><img src="https://i.loli.net/2017/12/29/5a45662a48d5c.png" alt=""></p><p>可以发现，这次请求头中多了 <code>if-none-match</code> 字段，其值就是 <code>foobar</code>。因此这次 <code>foobar</code> 和服务器版本相同，因此可以直接返回 304。</p><p>如果，修改本地服务器版本号，比如改成 <code>package</code>:</p>    <pre><code class="lang-js">app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-keyword">get</span>(<span class="hljs-string">'if-none-match'</span>) &amp;&amp; ctx.<span class="hljs-keyword">get</span>(<span class="hljs-string">'if-none-match'</span>) === <span class="hljs-string">'package'</span>) {    ctx.status = <span class="hljs-number">304</span>  } <span class="hljs-keyword">else</span> {    ctx.status = <span class="hljs-number">200</span>    ctx.type = <span class="hljs-string">'json'</span>    ctx.<span class="hljs-keyword">set</span>(<span class="hljs-string">'etag'</span>, <span class="hljs-string">'package'</span>)    ctx.body = fs.createReadStream(<span class="hljs-string">'package.json'</span>)  }})</code></pre><p>再次请求，</p><p><img src="https://i.loli.net/2017/12/29/5a45662a7925b.png" alt=""></p><p>如图，这次因为版本号不同了，所以服务端要再次发送文件，并且通知浏览器更新版本号。</p><h2 id="koa-static-cache"><a href="#koa-static-cache" class="headerlink" title="koa-static-cache"></a>koa-static-cache</h2><p>在 <a href="https://github.com/koajs/static-cache" target="_blank" rel="noopener">koa-static-cache</a> 这个包中，也使用了 <code>ETag</code> 策略。</p><p>源码中有这么几行代码:</p>    <pre><code class="lang-js"><span class="hljs-keyword">if</span> (file.md5) ctx<span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.etag</span> = file<span class="hljs-selector-class">.md5</span><span class="hljs-keyword">if</span> (ctx.fresh)  return ctx<span class="hljs-selector-class">.status</span> = <span class="hljs-number">304</span></code></pre><p>它的意思其实就是将文件的 <code>md5</code> 值作为版本号，因为文件内容一旦改变，那么它的 <code>md5</code> 也一定随之改变。</p><p>而 <code>ctx.fresh</code> 是 koa 实现的一个属性，可以参考文档 <a href="http://koajs.com/" target="_blank" rel="noopener">doc</a>。而这个属性就是根据 If-None-Match / ETag, and If-Modified-Since and Last-Modified 判断缓存是否过期。更具体的，Koa 源码中对 <code>fresh</code> 字段的实现又是使用了 <a href="https://github.com/jshttp/fresh" target="_blank" rel="noopener">fresh</a> 这个包，源码中可以观察这几行:</p>    <pre><code class="lang-js"><span class="hljs-comment">// if-none-match</span>  <span class="hljs-keyword">if</span> (noneMatch &amp;&amp; noneMatch !== <span class="hljs-string">'*'</span>) {    <span class="hljs-keyword">var</span> etag = resHeaders[<span class="hljs-string">'etag'</span>]    <span class="hljs-keyword">if</span> (!etag) {      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    }    <span class="hljs-keyword">var</span> etagStale = <span class="hljs-literal">true</span>    <span class="hljs-keyword">var</span> matches = parseTokenList(noneMatch)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; matches.length; i++) {      <span class="hljs-keyword">var</span> match = matches[i]      <span class="hljs-keyword">if</span> (match === etag || match === <span class="hljs-string">'W/'</span> + etag || <span class="hljs-string">'W/'</span> + match === etag) {        etagStale = <span class="hljs-literal">false</span>        <span class="hljs-keyword">break</span>      }    }    <span class="hljs-keyword">if</span> (etagStale) {      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    }  }</code></pre><p>其实现就是的原理就是比较 <code>if-none-match</code> 和 <code>etag</code> 的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://shop.oreilly.com/product/9781565925090.do" target="_blank" rel="noopener">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">MDN ETag</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。&lt;/p&gt;
&lt;p&gt;软件开发常常有版本号的概念，比如 &lt;code&gt;1.0&lt;/code&gt;, &lt;code&gt;1.1&lt;/code&gt;, &lt;code
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议中的 URL</title>
    <link href="https://lazzzis.moe/2017/12/16/http-protocol-url/"/>
    <id>https://lazzzis.moe/2017/12/16/http-protocol-url/</id>
    <published>2017-12-16T20:22:33.000Z</published>
    <updated>2017-12-16T20:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL-概念"><a href="#URL-概念" class="headerlink" title="URL 概念"></a>URL 概念</h1><blockquote><p>全称 Uniform Resource Locator (统一资源定位符)，是一种 URI (Uniform Resource Identifier, 统一资源标识符)</p></blockquote><h1 id="URL-作用"><a href="#URL-作用" class="headerlink" title="URL 作用"></a>URL 作用</h1><p>主要用于网络资源的定位。换句话说，当你想告诉 Alice 你的服务器上有一个有趣的文件想要分享时，你就可以告诉这个文件对应的 URL。那么 Alice 就可以根据这个 URL 找到你要分享的文件。而目前 URL 更通俗的被称为网址。</p><h2 id="URL-诞生前的故事"><a href="#URL-诞生前的故事" class="headerlink" title="URL 诞生前的故事"></a>URL 诞生前的故事</h2><p>想了解 URL 的意义，那你必须要了解一下在 URL 诞生前，人们是怎么找资源的。同样，你要分享一个文件给 Alice。那么你要说: 使用一个 FTP 软件，连接到 ftp.example.com，然后使用用户名 anonymous 和密码 anonymous，接着切换到 doc 目录，再然后转换到 <code>binary mode</code> (二进制模式)，找到名为 <code>story.doc</code> 的文件下载并打开。</p><p>但现在，你知道的，表示成 URL 就是 <code>ftp://ftp.example.com/doc/story.doc</code>。而且就下载而言，大部分浏览器已经具有 FTP 软件的一些功能。因此，URL 使你分享文件更加简单，因为别人更容易找到你想要分享的文件。</p><h1 id="URL-与请求"><a href="#URL-与请求" class="headerlink" title="URL 与请求"></a>URL 与请求</h1><p>URL 常常出现在 HTTP 请求的 start-line，也就是请求的第一行，比如:</p><pre><code>GET /hello.html HTTP/1.1Host: localhost:3000User-Agent: ...</code></pre><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</code></pre><p>依次解释一下</p><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>指代协议类型，告诉浏览器怎么去访问目标资源。常见的有 <code>FTP</code>, <code>HTTP</code>, <code>HTTPS</code>。 注意它是不区分大小写的，因此 <code>http://example.com</code> 与 <code>HTTP://example.com</code> 是完全等价的。</p><h2 id="User-和-password"><a href="#User-和-password" class="headerlink" title="User 和 password"></a>User 和 password</h2><p>某些协议需要密码，<code>FTP</code> 中就有时可以看到，举上面分享文件的例子，加上用户名密码就是 <code>ftp://anonymous:anonymous@ftp.example.com/doc/story.doc</code>。</p><h2 id="host-和-port"><a href="#host-和-port" class="headerlink" title="host 和 port"></a>host 和 port</h2><p>host 可以有两种表现形式，一种是域名，一种是 IP。不过域名只是为了方便记忆，因为在访问目标地址的时候，域名会通过 DNS 服务器解析为 IP。之后再通过寻找目标地址。</p><p>port 就是端口，平时访问网站之所以不用写端口，是因为它在 HTTP 协议中默认为 80 端口。</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>就是路径了。指代资源的位置，比如 <code>http://example.com/hello.doc</code>。说得就是 <code>hello.doc</code> 在服务器目录的根目录下。路径表示和 Unix 系统中的路径表示很相似，用 <code>/</code> 分隔。</p><p>但是在如今开发中 path 变得有抽象意义了，像上一个例子比较直白告诉你就是 <code>hello.doc</code>。但当今大多数路径并不能表示在服务器目录中的具体位置，而更像是在逻辑关系中的一种层级关系, 比如 <code>http://github.com/lazzzis/Test</code> 当然不是代表：你要的那个资源是在服务器的一个名为 <code>lazzzis</code> 的目录下的一个叫 <code>Test</code> 的文件。</p><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><code>query</code> 的形式以键值对的形式出现，即: <code>key=value</code>，多个键值对之间以 <code>&amp;</code> 分隔。</p><p><code>query</code>，常用于查询，在请求服务器的时候提供更多的额外信息。</p><h2 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h2><p>有时也被称为 <code>anchor</code> / <code>锚点</code>，指示当前文件内容的一个片段，有点类似于书签。</p><p><code>https://github.com/chancejs/chancejs#packages</code>。<code>#packages</code> 表示文件中代表 <code>packages</code> 的那一段，浏览器一般会自动帮你跳转到那一行。</p><p>注意的是，在发送带有 <code>fragment</code> 的请求时，<code>fragment</code> 其实不会包含在 HTTP 请求里。也就是说，服务器接受到的请求消息里并没有 <code>fragment</code> 这一部分。原因是，服务器通常只能把 <code>https://github.com/chancejs/chancejs</code> 代表的整个资源返回，而不能只返回 <code>#packages</code> 代表的那一段。</p><h1 id="字符的一些限制"><a href="#字符的一些限制" class="headerlink" title="字符的一些限制"></a>字符的一些限制</h1><p>通常情况下，HTTP 协议对可以出现在 URL 的字符作出了限制。比如一般你很难看到 URL 有中文或日文，等非英文字母。一般遇到中文等语言的字符，URL 会对其编码，转换成一个 <code>%</code> 开头的字符串。</p><p>如图，虽然我输入的是中文<code>火狐</code>，但 HTTP 请求消息中出现的是已经对其编码。</p><p><img src="https://i.loli.net/2017/12/17/5a3580135e99d.png" alt=""></p><p>除了中文字符，空格，斜杠等字符也会被编码，否则会在 URL 中引起歧义。比如 空格被编码为 <code>%20</code></p><h1 id="URL-潜在的问题"><a href="#URL-潜在的问题" class="headerlink" title="URL 潜在的问题"></a>URL 潜在的问题</h1><p>用 URL 表示资源的一个问题就是资源的对应的 URL 变化时，之前的 URL 就没用了。例如，原先用户 alice 的主页是 <code>http://example.com/alice</code>。但 <code>alice</code> 改名了，变成 <code>eve</code>，那么她的主页变成 <code>http://example.com/eve</code>。这时，她的朋友们可能因为仍旧通过 <code>http://example.com/alice</code> 访问她的主页而导致访问失败。</p><p>不过现在有些网站会提示 <code>alice</code> 已经更名为 <code>eve</code>，然后帮助浏览者跳转至 <code>http://example.com/eve</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener">统一资源定位符</a></li><li><a href="http://shop.oreilly.com/product/9781565925090.do" target="_blank" rel="noopener">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages" target="_blank" rel="noopener">HTTP Messages</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web" target="_blank" rel="noopener">Identifying resources on the Web</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;URL-概念&quot;&gt;&lt;a href=&quot;#URL-概念&quot; class=&quot;headerlink&quot; title=&quot;URL 概念&quot;&gt;&lt;/a&gt;URL 概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;全称 Uniform Resource Locator (统一资源定位符)，是一种
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序 / topological sort</title>
    <link href="https://lazzzis.moe/2017/11/22/intro-of-topological-sort/"/>
    <id>https://lazzzis.moe/2017/11/22/intro-of-topological-sort/</id>
    <published>2017-11-23T01:42:24.000Z</published>
    <updated>2017-11-23T01:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png" alt=""></p><p>其中, <code>1 -&gt; 3</code> 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。</p><p>而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 <code>[1, 2, 4, 3, 5, 7, 6]</code>。</p><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>一个显然可以得到的观点就是，对于没有依赖的任务，可以直接将其放入所求的序列中， 比如上图中的 <code>[1, 2]</code>。</p><p>那算法的第一步就是找出所有没有被依赖的任务，并将其移除，此时可以得到一个新的图:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo2.png" alt=""></p><p>显然又可以发现，又出现了没有依赖的任务 <code>[4]</code>，那我们继续把它放入所求的序列中，并将其移除，得到的新的图:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo3.png" alt=""></p><p>此时又得到新的图，而且同样出现了没有依赖的任务，所以继续把它放入序列中，将其移除。。。以此类推，每次移除没有依赖的点，得到新的图，继续移除没有依赖的点，直到所有的点都被移除了。</p><p>我们首先需要用一种数据结构表示一点任务是否有依赖。那我们可以发现，用依赖的数量来表示是否有依赖非常合适。如最开始的图中:</p><p>方块中的数字即表示旁边的任务的依赖数，如果数字为 0 即表示依赖为 0。而当我们把<code>[1, 2]</code> 移除后，相连的 <code>[3, 4]</code> 的依赖数必定会减少，变成如图所示:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo4.png" alt=""></p><p>此时任务 4 的依赖数为 0，将其移除后，任务 3 的依赖数变为 0，任务 6 的依赖变为 2。所有下一次又移除 3。</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo5.png" alt=""></p><p>而实际上，这里的依赖数有一个更专业的名词叫 <code>入度</code>。如其字面意思一样，对于某个点，有多少箭头指向它。</p><p>主流的实现方法有两种，BFS 和 DFS 。因为我更喜欢 BFS，所以这里用 BFS 解释。其中 Queue 的实现可以参照<a href="https://gist.github.com/lazzzis/e07499c379bf9ec43066cc6c66b091f0" target="_blank" rel="noopener">这里</a>。</p>    <pre><code class="lang-js"><span class="hljs-comment">/** * numTasks 表示任务的数量，这里假设任务的 id 从 0 ~ numTasks * * prerequisites 是一个二维数组 * 例如 [[3, 1], [4, 2], [3, 4]] 表示: * 任务 3 必须在任务 1 之后，任务 4 必须在任务 2 之后，任务 3 必须在任务 4 之后 * 换言之，1 指向 3，2 指向 4，4 指向 1 */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">topo</span> (<span class="hljs-params">numTasks, prerequisites</span>) </span>{  <span class="hljs-keyword">const</span> indegrees = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(numTasks).fill(<span class="hljs-number">0</span>) <span class="hljs-comment">// 入度</span>  <span class="hljs-keyword">const</span> links = <span class="hljs-built_in">Array</span>.from({ <span class="hljs-attr">length</span>: numTasks }).map(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> [])  <span class="hljs-comment">// 用一个二维数组表示图</span>  <span class="hljs-comment">// 比如数组 links[5] = [6, 7] 表示 5 指向 6 与 7</span>  prerequisites.forEach(<span class="hljs-function">(<span class="hljs-params">[second, first]</span>) =&gt;</span> {    indegrees[second]++    links[first].push(second)  })  <span class="hljs-keyword">const</span> q = <span class="hljs-keyword">new</span> Queue()  <span class="hljs-keyword">const</span> ans = []  <span class="hljs-comment">// 寻找 入度 为 0 的点</span>  ;[...Array(numTasks).keys()].filter(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> !indegrees[i]).forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> q.push(x))  <span class="hljs-keyword">while</span> (!q.empty()) {    <span class="hljs-keyword">const</span> top = q.pop()    ans.push(top)    <span class="hljs-comment">// 移除这个点的对应的边，所以相连的任务的入度都减一</span>    links[top].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> indegrees[x]--)    <span class="hljs-comment">// 入度减小的这些任务中是否有入度为 0 的点</span>    links[top].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !indegrees[x]).forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> q.push(x))  }  <span class="hljs-keyword">return</span> ans</code></pre><p>对于此图的运行结果:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo7.png" alt=""></p>    <pre><code class="lang-js">&gt; topo(<span class="hljs-number">7</span>, [[<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])[ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span> ]</code></pre><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>假设顶点数为 V，边的数目为 E，时间复杂度上讲，应该为 O(V + E)。</p><p>因为每一个点仅仅被访问一次，而每条边也都会被移除一次。</p><h2 id="存在环"><a href="#存在环" class="headerlink" title="存在环"></a>存在环</h2><p>如果存在环，那么在某个时刻存在入度不为 0 的点，如下图所示:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo6.png" alt=""></p><p>这种情况下，一般需要判断最后的序列长度是否为 <code>numTasks</code>。如果不是，则存在环。所以，这个算法也可以用于判断环的存在与否。</p><p>特别注意的是，即使存在环，上述代码中 <code>while (!q.empty())</code> 也不会陷入死循环，原因是 <code>q</code> 包含的是入度为 0 的点，如果不存在了入度为 0 的点，那么就会终止循环。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol><li><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">LeetCode 207. Course Schedule</a></li><li><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">LeetCode 210. Course Schedule II</a></li><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285" target="_blank" rel="noopener">HDU 1285 确定比赛名次</a></li><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2094" target="_blank" rel="noopener">HDU 2094 产生冠军</a></li></ol><h1 id="最后再说几句"><a href="#最后再说几句" class="headerlink" title="最后再说几句"></a>最后再说几句</h1><p>最初这题是一位 FaceBook 的学长给我做 mock interview 出的题目。当时我知道这是拓扑排序，但没想到的是，我因为长期没有做这类题，已经完全忘记了它的具体做法。在当时的情况下，我并没有想起来怎么去做这题。所以说，平时偶尔还是要刷一些已经刷过的题呀。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">Wiki Topological Sorting</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b91
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://lazzzis.moe/tags/ACM/"/>
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>思考为什么要用工厂模式</title>
    <link href="https://lazzzis.moe/2017/11/09/why-factory-method-pattern/"/>
    <id>https://lazzzis.moe/2017/11/09/why-factory-method-pattern/</id>
    <published>2017-11-09T18:01:59.000Z</published>
    <updated>2017-11-09T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>以 JavaScript 为例子发表一下我对工厂模式 (Factory Pattern) 的看法</p><p><strong>为什么不直接 new 呢? 我自己写代码直接 new 自己写的类不就好了么?</strong></p><p>这里不得不提一下设计模式的意义。设计模式并不是凭空捏造的，而是长期开发所形成的经验之谈，当然这些经验自然是成功的，被认可的经验，否则设计模式就不会被那么多人认可和推崇了。</p><p>设计模式主要针对的是大项目，也就是多个人的项目。A 并不一定知道 B 写了哪些类。通过工厂模式，A 在调用工厂类生产的实例的时候就不用关心 B 实现了哪些类了。</p><p>举例:</p><p>B 写的代码</p>    <pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>{    static create (<span class="hljs-class"><span class="hljs-keyword">type</span>) </span>{        <span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">===</span> 1) </span>{            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>()        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">===</span> 2) </span>{            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>()        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">C</span>()        }    }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{ execute() {} <span class="hljs-comment">/* ... */</span>}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{ execute() {} <span class="hljs-comment">/* ... */</span>}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{ execute() {} <span class="hljs-comment">/* ... */</span>}</code></pre><p>A 写的代码:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> foo = Factory.create(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> bar = Factory.create(<span class="hljs-number">2</span>)<span class="hljs-keyword">await</span> foo.excute()<span class="hljs-keyword">await</span> bar.excute()</code></pre><p>如代码所示，A 只要知道返回回来的实例具有 <code>execute</code> 方法就足够了，不用去记住各种类名, 甚至没有感觉到自己拿到的其实是不同的类。同时，因为没有直接使用 <code>new</code> 具体的某个类，所以如果以后要修改类名的话就会简单很多 – 比如要把 <code>A</code> 改名为 <code>Ace</code>，那么只需额外在 <code>Factory</code> 里把 <code>A</code> 改为 <code>Ace</code> 就行了。</p><p><strong>一般什么情况比较适合用工厂模式?</strong></p><p>一般需要根据外界的一些动态环境选择具体实例哪些类，或者说具体选择实例哪个类需要很繁杂的判断。</p>    <pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>{    <span class="hljs-keyword">static</span> create (config) {        <span class="hljs-keyword">if</span> (config.version &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BasicApp</span>()        <span class="hljs-keyword">if</span> (config.os === <span class="hljs-string">'linux'</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BashApp</span>()        <span class="hljs-keyword">if</span> (config.os === <span class="hljs-string">'windows'</span> &amp;&amp; config.online) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">OnlineApp</span>()        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">LocalApp</span>()    }}</code></pre><p>如代码所示，如果要决定实例哪个类要许多复杂的判断，那么用工厂模式封装就会轻松很多。需要做判断的事情已经交给了写 <code>Factory</code> 的人，使要实例的开发者也不用去了解判断规则, 并且这在未来修改判断规则提供了便利。</p><p>另外，有些人认为 <code>new</code> 一个具体的实例也是种硬编码。如果在一个项目里太多的地方用 <code>new</code>, 比如 <code>new Foo()</code>。那么 <code>Foo</code> 就与项目的多个地方有了紧密的联系。而为了使联系不那么紧密 (decouple)，将工厂作为两者之间的一个缓冲，使具体的类和需要类的地方被间接地连起来。我个人认为这个有一定道理，在一些大项目上可以考虑，但在小项目中似乎显得没那么必要。因为就算要改名，用 IDE 就可以替换掉几个文件中的所要替换的类名。</p><p><strong>使用工厂模式有什么注意的么?</strong></p><p>其实如上面看到的一样，<code>Factory</code> 返回回来的实例是实现了相同接口 / 功能的，因为这样才能使调用 <code>Factory</code> 的开发者真地只需要关心功能而可以忽略用了自己拿到的是具体什么类。例如，在 Java 之类的语言中，一般有大量的子类是继承了某抽象类，或实现了某接口，以此保证具有同一的方法名。</p><p>如果返回回来的实例有实现功能的不同接口，那么工厂模式的效用将大打折扣。</p>    <pre><code class="lang-js"><span class="hljs-keyword">class</span> Factory {    <span class="hljs-keyword">static</span> create (<span class="hljs-class"><span class="hljs-keyword">type</span>) {</span>        <span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> </span>=== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A()        <span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> </span>=== <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B()        <span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> </span>=== <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> C()    }}<span class="hljs-keyword">class</span> A { print() {} }<span class="hljs-keyword">class</span> B { output() {} }<span class="hljs-keyword">class</span> C { echo() {} }</code></pre><p>如代码所示，虽然 A, B, C 都实现了输出的功能。但是方法名不同，这导致多次调用 Factory 的开发者不得不时时刻刻提醒自己同样是从 Factory 拿到的对象为什么会有不同。这种设计或多或少会带来潜在的 bug。</p><p><strong>什么时候不要用工厂模式?</strong></p><p>设计模式是好东西，但不是万能的，只有特定的场合解决特定的问题。一般来讲，如果你的开发场景中没有出现本文前面所讲的 <em>复杂的实例过程</em> 或 <em>相同的接口</em> 的话，我个人就不建议使用了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="noopener">Learning JavaScript Design Patterns</a></li><li><a href="https://www.zhihu.com/question/24843188" target="_blank" rel="noopener">知乎: 工厂设计模式有什么用？</a></li><li><a href="https://www.zhihu.com/question/42975862" target="_blank" rel="noopener">知乎: 工厂模式（factory Method）的本质是什么？为什么引入工厂模式</a></li><li><a href="https://stackoverflow.com/questions/69849/factory-pattern-when-to-use-factory-methods" target="_blank" rel="noopener">Factory Pattern. When to use factory methods?</a></li><li><a href="https://msdn.microsoft.com/en-us/library/ee817667.aspx" target="_blank" rel="noopener">Exploring the Factory Design Pattern</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以 JavaScript 为例子发表一下我对工厂模式 (Factory Pattern) 的看法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接 new 呢? 我自己写代码直接 new 自己写的类不就好了么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里不得不提一下设计模式的意义。设计
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单谈谈 Node.js 对 ESM 的几种支持方案</title>
    <link href="https://lazzzis.moe/2017/10/17/words-on-the-support-of-esm-in-node/"/>
    <id>https://lazzzis.moe/2017/10/17/words-on-the-support-of-esm-in-node/</id>
    <published>2017-10-18T03:18:10.000Z</published>
    <updated>2017-11-14T15:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。</p><h1 id="主流的方案"><a href="#主流的方案" class="headerlink" title="主流的方案"></a>主流的方案</h1><ol><li>在文件开头添加 <code>&quot;use module&quot;;</code> 或类似字段</li><li>新的文件后缀名，如 <code>.mjs</code></li><li>通过源代码内容自动区分</li><li>在 <code>package.json</code> 指明采用 <code>ESM</code> 的文件</li></ol><p>这四个方案都已经满足了一些基本要求:</p><ul><li>对现有的 <code>package</code> (几乎全是 CJS) 不造成影响</li><li>不需要知道 <code>package</code> 采用的是哪种形式就可以直接导入</li></ul><p>在这个基础上，第 2 个方案接受的比较多，而且在当前版本 <code>8.7.0</code> 中，可以通过在命令行中增加 <code>--experimental-modules</code> 运行。<br>比如 <code>node --experimental-modules main.mjs</code>:</p>    <pre><code class="lang-js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span><span class="hljs-built_in">console</span>.log(_.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))</code></pre><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>其实我最初想到的也是这种方案, 因为我以前在其它语言中接触过一些类似的做法。</p><p>在一些脚本语言中，会采用类似与 <code>#!foo</code> 这种特殊的注释用于说明执行该脚本的程序，比如 <code>#!/usr/bin/env python3</code>。</p><p>而在 <code>python2</code> 中，也会在文件的开头注释说明该语言的编码形式: <code># -*- coding: &lt;encoding name&gt; -*-</code>，比如 <code># -*- coding: utf-8 -*-</code>。</p><p>既然其它语言有类似做法，那这种方案对 node 来说也行吧？</p><p>虽然这种方式很清晰，不过最后还是被否决了。</p><p>其中一个原因就是用户体验太差了。。。因为未来会是 <code>ESM</code> 的天下，既然是 <code>ESM</code> 的天下，那我为什么还要在每个文件开头写 <code>&quot;use modules&quot;;</code> 这样的代码。虽然现在还好，但这在以后势必会显得十分的冗余。</p><p>另一个原因是一些工具链为了区分不得不需要有一定的 <code>parse</code> 文件的能力。实现这个的成本明显比检测文件后缀名的成本要高的多。</p><p>主要由于以上两点，这个方案被否决了。</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>比起另外的方案，采用新的后缀 <code>.mjs</code>, 这个方案也算一个对程序员友好的方案。因为对于每个文件，只需多一个字母 <code>m</code> 在后缀名上 (<code>.js</code> -&gt; <code>.mjs</code>) 即可采用 <code>ESM</code>。</p><p>同时，不论从实现 <code>node</code> 解释器本身或者相关工具链角度来说，这个方案实现很容易就实现。</p><p>至于缺点，同样也是检测后缀名，很多相关工具仅仅把 <code>.js</code> 认为 <code>JavaScript</code> 文件，遇到 <code>.mjs</code> 可能就不认识了。</p><p>不过考虑到最近 <code>JavaScript</code> 相关后缀名不断增多，比如近几年出现的 <code>.jsx</code>, <code>.ts</code>。再增加一个 <code>.mjs</code> 似乎也没什么问题吧。<code>ヘ(￣ー￣ヘ)</code></p><p>另外，为什么采用 <code>.mjs</code> 而不是 <code>.es</code>, <code>.m.js</code> 呢？据了解，在可能想到的后缀名里，<code>.mjs</code> 和现有其它软件的后缀名的冲突最小。</p><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>这个方案最直接了，如果可以。我当然愿意接受这种方案：全部交给 <code>node</code> 自动根据源码判断，比如有 <code>import</code> 就认为是 <code>ESM</code>，有 <code>require</code> 就认为是 <code>CJS</code>。</p><p>不过这个实现起来却非常困难。因为 <code>node</code> 源码开发者们不得不对现有 <code>parsing API</code> 进行更改，改进。这个的改动量是巨大的。而且，就算实现了，因为每次都需要对源码内容解析，可能会对性能产生潜在的影响，尤其是在分析大文件的时候。所以由于这个明显的缺点，这个方案也被否决了。</p><h1 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h1><p>这个方案的好处，就是不用对采用 <code>ESM</code> 的文件做任何修改就能辨认出是 <code>ESM</code>。</p><p>不过说实话，这个一听就对开发者有点不友好。要把所有 ESM 都指明，似乎有点累呀。</p><p>比如这样子:</p>    <pre><code class="lang-json">{  <span class="hljs-attr">"module"</span>: <span class="hljs-string">"lib/index.js"</span>,  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"old/index.js"</span>,}</code></pre><p>或</p>    <pre><code class="lang-json">{  <span class="hljs-string">//</span> <span class="hljs-string">...</span>  <span class="hljs-string">//</span> files:  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib/hello.js"</span>, <span class="hljs-string">"bin/hello.js"</span>],  <span class="hljs-string">//</span> directories:  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib"</span>, <span class="hljs-string">"bin"</span>],  <span class="hljs-string">//</span> files and directories:  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib"</span>, <span class="hljs-string">"bin"</span>, <span class="hljs-string">"special.js"</span>],  <span class="hljs-string">//</span> <span class="hljs-keyword">if</span> package never uses CJS Modules  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"."</span>],}</code></pre><p>另一个比较实在的问题，就是如果要运行 <code>ESM</code> 的文件的话，那岂不是要把 js 文件和 package.json 一起使用？也就是说，单个 <code>ESM</code> 文件是不是不能运行。</p><p>同样这个对现有的某些工具链不友好，需要阅读 <code>package.json</code> 才能确定是不是 <code>ESM</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的而言，虽然方案二有些缺点，但确实是方案二更优一点。另外，有一篇对方案四的<a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md" target="_blank" rel="noopener">正名</a>文章，值得读一读。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/nodejs/node/wiki/ES6-Module-Detection-in-Node" target="_blank" rel="noopener">ES6 Module Detection in Node</a></li><li><a href="http://2ality.com/2017/05/es-module-specifiers.html" target="_blank" rel="noopener">Module specifiers: what’s new with ES modules?</a></li><li><a href="https://github.com/bmeck/node-eps/blob/es6-module/002-es6-modules.md#es-consuming-commonjs" target="_blank" rel="noopener">node-eps</a></li><li><a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md" target="_blank" rel="noopener">defense-of-dot-js</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。&lt;/p&gt;
&lt;h1 id=&quot;主流的方案&quot;&gt;&lt;a href=&quot;#主流的方案&quot; class=&quot;headerlink&quot; title=&quot;主流的方案&quot;&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>借助 Proxy 实现一个 DefaultDict</title>
    <link href="https://lazzzis.moe/2017/09/30/defaultdict-in-js/"/>
    <id>https://lazzzis.moe/2017/09/30/defaultdict-in-js/</id>
    <published>2017-10-01T02:44:12.000Z</published>
    <updated>2017-10-01T04:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里的 <code>DefaultDict</code> 指的是类似于 Python 中的 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener"><code>defaultdict</code></a> 的一种类。其基本特点就是当某个属性不存在于该对象中时，该对象会自动为这个属性创建一个默认值。这个默认值是由用户在创建 <code>DefaultDict</code> 时指定的。</p><p>举个例子，现在需要一个对象，如果某个属性不在这个对象时，在为这个属性赋值为 0.</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'please'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>]<span class="hljs-keyword">const</span> defaultDict = defaultDictFactory({}, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word of words) {    defaultDict[word]++}<span class="hljs-built_in">console</span>.log(defaultDict)<span class="hljs-comment">/*{ hello: 3,  world: 2,  please: 2,  say: 4}*/</span></code></pre><p>这个例子其实就是非常简单的一个统计单词数量的一个例子，如果不使用 <code>defaultDict</code>, 那么估计就会这么写:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'please'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>]<span class="hljs-keyword">const</span> defaultDict = {}<span class="hljs-built_in">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">word</span> of words) {    defaultDict[<span class="hljs-keyword">word</span>] = defaultDict[<span class="hljs-keyword">word</span>] == null ? <span class="hljs-number">1</span> : defaultDict[<span class="hljs-keyword">word</span>] + <span class="hljs-number">1</span>}</code></pre><p>你觉得那个更美观或实用一点呢？ 这个其实见仁见智，至少前者确实带来了一些便利。</p><p>回到正题，这里开始讲怎么去实现它。</p><h1 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h1><p>实现的方法很多，不一定必须要 <code>Proxy</code> 对象，但它最为 ES6 推出的一个类，有必要去尝试一下。简单的说，<code>Proxy</code> 可以改变对象的一些默认行为，包括增删改查。</p><p>举个例子:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>({}, {  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop</span>) </span>{    <span class="hljs-built_in">console</span>.log(target, prop)    <span class="hljs-keyword">return</span> target[prop]  }})obj.foo = <span class="hljs-number">1</span><span class="hljs-built_in">console</span>.log(obj[<span class="hljs-string">'bar'</span>])<span class="hljs-comment">/*{ foo: 1 } 'bar'undefined*/</span></code></pre><p>可见，<code>Proxy</code> 对对象属性的获取进行了一点修改。在这里 <code>obj.foo = 1</code>  不属于对 <code>foo</code> 属性的获取，而是对 <code>foo</code> 属性的赋值(set)，所以在执行 <code>obj.foo = 1</code> 时，<code>get: function (target, prop) { ... }</code> 并没有被执行。</p><p>更多的可以参考 <a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">ECMAScript 6 入门: Proxy</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里先定义个 <code>handler</code>，也就是对对象的属性获取进行拦截。那么这里需要思考，需要哪些参数呢？</p><p>首先一个，如何确认默认值，那么默认值的产生需要用户定义。所以我们需要一个 <code>defaultFactory</code> 函数用于生成默认值，这里使用了函数，为了有更多的可操作空间。</p><p>另外，如何判断一个属性在不在这个对象中呢？大部分用 <code>&#39;foo&#39; in obj</code> 判断，但极少时候用其它方式。所以这里就设置一个默认操作，如果用户没有指定，我们就用 <code>in</code> 操作符判断属性是否存在。</p><p>这么到这里可以基本实现了 <code>defaultDict</code>:</p>    <pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultDictFactory</span> (<span class="hljs-params">initials, defaultFactory, validator</span>) </span>{  <span class="hljs-keyword">if</span> (validator == <span class="hljs-literal">null</span>) {    validator = <span class="hljs-function">(<span class="hljs-params">prop, object</span>) =&gt;</span> prop <span class="hljs-keyword">in</span> object  }  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(initials, {    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop</span>) </span>{      <span class="hljs-keyword">if</span> (!validator(prop, target)) {        target[prop] = defaultFactory(target, prop)      }      <span class="hljs-keyword">return</span> target[prop]    }  })}</code></pre><p><code>defaultDictFactory</code> 作为一个工厂函数，专门生产 <code>defaultDict</code>。本来我想用 <code>class</code> 实现，不过遇到了瓶颈，所以改为工厂模式。<br><code>initials</code> 为初始对象，因为用户或许会将一个非空对象转化为 <code>defaultDict</code>。<br><code>defaultFactory</code> 函数用于生产默认值。<br><code>validator</code> 判断属性是否存在，可以有用户自定义判断属性是否存在的规则。</p><p>但为了安全起见，可以加一些对参数的检查。</p>    <pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultDictFactory</span> (<span class="hljs-params">initials, defaultFactory, validator</span>) </span>{  <span class="hljs-keyword">if</span> (defaultFactory == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> defaultFactory !== <span class="hljs-string">'function'</span>) {    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`defaultFactory must be a function`</span>)  }  <span class="hljs-keyword">if</span> (validator != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> validator !== <span class="hljs-string">'function'</span>) {    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`validator must be a function`</span>)  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (validator == <span class="hljs-literal">null</span>) {    validator = <span class="hljs-function">(<span class="hljs-params">prop, object</span>) =&gt;</span> prop <span class="hljs-keyword">in</span> object  }  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(initials, {    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, prop</span>) </span>{      <span class="hljs-keyword">if</span> (!validator(prop, target)) {        target[prop] = defaultFactory(prop, target)      }      <span class="hljs-keyword">return</span> target[prop]    }  })}</code></pre><p>这样子基本就完成了 <code>defaultDictFactory</code> 的定义。</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>这里还是以统计单词为例，增加 1 个要求: 单词的默认值为单词的长度</p><p>那么只需要设置 <code>defaultFactory</code>:</p>    <pre><code class="lang-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>, <span class="hljs-string">'please'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>, <span class="hljs-string">'say'</span>]<span class="hljs-keyword">const</span> defaultDict = defaultDictFactory({}, <span class="hljs-function">(<span class="hljs-params">prop</span>) =&gt;</span> prop.length)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> word of words) {  defaultDict[word]++}<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(defaultDict))<span class="hljs-comment">/*[ [ 'hello', 7 ], [ 'world', 6 ], [ 'please', 7 ], [ 'say', 6 ] ]*/</span></code></pre><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>建立 <code>defaultDict</code> 的最初想法一方面来自于 Python 的 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict" target="_blank" rel="noopener"><code>defaultdict</code></a>，因为这确实挺方便的。另一方面则来自于对平时刷题时经常遇到的 <code>obj.foo = obj.foo == null ? 1 : obj.foo + 1</code> 的这种写法觉得不美观的写法，所以试图改变一下。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://gist.github.com/thomasboyt/5987633" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/proxy</a></li><li><a href="https://gist.github.com/thomasboyt/5987633" target="_blank" rel="noopener">https://gist.github.com/thomasboyt/5987633</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里的 &lt;code&gt;DefaultDict&lt;/code&gt; 指的是类似于 Python 中的 &lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot; target
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>node-thunkify 的实现及源码阅读</title>
    <link href="https://lazzzis.moe/2017/06/29/source-code-of-thunkify/"/>
    <id>https://lazzzis.moe/2017/06/29/source-code-of-thunkify/</id>
    <published>2017-06-29T19:52:32.000Z</published>
    <updated>2017-08-02T14:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了些项目的源码，其中就包括 <code>thunkify</code>。虽然 <code>thunkify</code> 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 <a href="https://github.com/tj/node-thunkify/tree/0bd83e29df1bb0653230724f072cff96b0ab684e" target="_blank" rel="noopener">0bd83e</a>。</p><h1 id="功能陈述"><a href="#功能陈述" class="headerlink" title="功能陈述"></a>功能陈述</h1><p>将一个函数转换为一个为 Thunk 函数，这个函数被调用后会返回一个以回调函数为参数的函数。可以参考 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-函数" target="_blank" rel="noopener">Thunk 函数</a>。</p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>因为需求比较简单，所以我自己先实现了一下，然后比较与官方仓库的差异，可以发现一些源码的特点。呢</p><p>我自己的实现:</p>    <pre><code class="lang-js">module.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>{    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{      fn(...args, callback)    }  }}</code></pre><h2 id="从测试看问题"><a href="#从测试看问题" class="headerlink" title="从测试看问题"></a>从测试看问题</h2><p>源码有 test 文件，可以将源码的测试文件 clone 到本地后测试。将上面的代码测试后可以发现 3 个测试未通过:</p><ol><li>thunkify(fn) should maintain the receiver</li><li>thunkify(fn) should catch errors</li><li>thunkify(fn) should ignore multiple callbacks</li></ol><h3 id="maintain-the-receiver"><a href="#maintain-the-receiver" class="headerlink" title="maintain the receiver"></a>maintain the receiver</h3><p>通过 test 文件代码发现，这里主要涉及到一个关于 <code>this</code> 的问题:</p>    <pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> <span class="hljs-params">(fn)</span></span> {    fn(null, this.name)}var user = {    name: <span class="hljs-string">'tobi'</span>,    <span class="hljs-built_in">load</span>: thunkify(<span class="hljs-built_in">load</span>)}user.<span class="hljs-built_in">load</span>()(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, name)</span></span> {    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> done(err)    <span class="hljs-built_in">assert</span>(name === <span class="hljs-string">'tobi'</span>)    done()})</code></pre><p>原函数 f 可能是某个对象的方法，所以要保证 thunkify 后的函数，称它为 tf, 仍然能正常访问 <code>this</code> ，所以 tf 函数里需要能引用到原函数 f 里 <code>this</code> 的值，<code>thunkify</code> 源码中用 <code>ctx</code> 变量对其表示原函数 f 的 <code>this</code>：</p>    <pre><code class="lang-js"><span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// line 27</span>fn.apply(ctx, args); <span class="hljs-comment">// line 43</span></code></pre><h3 id="catch-errors"><a href="#catch-errors" class="headerlink" title="catch errors"></a>catch errors</h3><p>尽管原函数 f 是需要一个回调函数做参数，理论上这个回调函数应该能捕捉异常了，但有些时候，这个回调函数可能没有正常 catch，例如测试文件中的样例:</p>    <pre><code class="lang-js">// fn 作为回调函数却没有捕捉这个异常<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span> <span class="hljs-params">(fn)</span></span> {    throw new Error(<span class="hljs-string">'boom'</span>)}<span class="hljs-built_in">load</span> = thunkify(<span class="hljs-built_in">load</span>)<span class="hljs-built_in">load</span>()(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span></span> {    <span class="hljs-built_in">assert</span>(err)    <span class="hljs-built_in">assert</span>(err.message === <span class="hljs-string">'boom'</span>)    done()})</code></pre><p>而 thunkify 则 “帮” 其捕捉了。当发现原函数 f 抛出异常时，源码中自动用用户传进的回调函数捕捉了。</p>    <pre><code class="lang-js"><span class="hljs-comment">// line 42 - 47</span><span class="hljs-comment">// done 代表用户传进的回调函数</span><span class="hljs-selector-tag">try</span> {  <span class="hljs-selector-tag">fn</span><span class="hljs-selector-class">.apply</span>(ctx, args);} <span class="hljs-selector-tag">catch</span> (err) {  <span class="hljs-selector-tag">done</span>(err);}</code></pre><h3 id="ignore-multiple-callbacks"><a href="#ignore-multiple-callbacks" class="headerlink" title="ignore multiple callbacks"></a>ignore multiple callbacks</h3><p>理论上讲，一个回调函数 callback 只能被调用一次，但在实际情况中，仍然会存在被调用多次的意外情况，例如测试文件中的例子：</p>    <pre><code class="lang-js">function <span class="hljs-keyword">load</span> (<span class="hljs-function"><span class="hljs-keyword">fn</span>) {    <span class="hljs-keyword">fn</span><span class="hljs-params">(<span class="hljs-built_in">null</span>, <span class="hljs-number">1</span>)</span>    <span class="hljs-keyword">fn</span><span class="hljs-params">(<span class="hljs-built_in">null</span>, <span class="hljs-number">2</span>)</span>    <span class="hljs-keyword">fn</span><span class="hljs-params">(<span class="hljs-built_in">null</span>, <span class="hljs-number">3</span>)</span>}<span class="hljs-title">load</span> = thunkify<span class="hljs-params">(<span class="hljs-keyword">load</span>)</span><span class="hljs-keyword">load</span><span class="hljs-params">()</span><span class="hljs-params">(done)</span></span></code></pre><p>为了确保回调函数 callback 只被调用了一次，<code>thunkify</code> 对回调函数进行了一次封装：</p>    <pre><code class="lang-js"><span class="hljs-comment">// line 34 - 40</span><span class="hljs-keyword">var</span> called;args.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{    <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;    called = <span class="hljs-literal">true</span>;    done.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>);});</code></pre><p><code>called</code> 作为一个 flag，第一次调用时，if 语句会把 called 当作否定值，所以 <code>return</code> 不会被执行。但从第二次开始，<code>called</code> 都会变成 <code>true</code>，所以 <code>return</code> 都会执行，确保了回调函数 callback 只会被调用一次。</p><p>这里需要注意一下 <code>args</code> 这个变量，它每次都会 <code>push</code> 一下，因为 <code>thunkify</code> 后的函数 tf 可能被引用调用多次:</p>    <pre><code class="lang-js"><span class="hljs-symbol">function</span> <span class="hljs-meta">fn</span> (done) {  done(null, Date.now())}<span class="hljs-symbol">let</span> tf = thunkify(<span class="hljs-meta">fn</span>)()<span class="hljs-symbol">let</span> <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c2</span>, <span class="hljs-built_in">c3</span><span class="hljs-symbol">c1</span> = <span class="hljs-built_in">c2</span> = <span class="hljs-built_in">c3</span> = (err, value) =&gt; console.log(value)<span class="hljs-symbol">tf</span>(<span class="hljs-built_in">c1</span>)<span class="hljs-symbol">tf</span>(<span class="hljs-built_in">c2</span>)<span class="hljs-symbol">tf</span>(<span class="hljs-built_in">c3</span>)</code></pre><p>这个程序最后只会输出一次值。因为根据闭包规则，第二次调用 tf 开始，回调函数就被 <code>push</code> 进 <code>args</code> 里了。当第三次调用 tf 时，此时的 args 等价为 <code>[c1, c2, c3]</code>，根据源码， <code>tf(c3)</code> 相当于调用 <code>tf.apply(ctx, [c1, c2, c3])</code>。所以此时真正执行的回调是 <code>c1</code>，如前文所说，这个 <code>c1</code> 是被源码封装过的，里面的内容只会被执行一次。</p><h3 id="自己的实现（改进后）"><a href="#自己的实现（改进后）" class="headerlink" title="自己的实现（改进后）"></a>自己的实现（改进后）</h3><p>结合 ES6，自己在解决上述问题后又实现了一遍，功能上没有改变，全是增加鲁棒性</p>    <pre><code class="lang-js">module.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> </span>{  assert(<span class="hljs-string">'function'</span> === <span class="hljs-keyword">typeof</span> fn, <span class="hljs-string">'function required'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>{    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span> <span class="hljs-comment">// fix test 'should maintain the receiver'</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{      <span class="hljs-keyword">const</span> refinedCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>{        let first = <span class="hljs-literal">true</span>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>{          <span class="hljs-keyword">if</span> (!first) <span class="hljs-keyword">return</span>          first = <span class="hljs-literal">false</span>          callback(...args)        }      }      args.push(refinedCallback(callback))      <span class="hljs-keyword">try</span> {        fn.call(ctx, ...args)      } <span class="hljs-keyword">catch</span> (err) {        callback(err)      }    }  }}</code></pre><h2 id="从-Commit-看改进"><a href="#从-Commit-看改进" class="headerlink" title="从 Commit 看改进"></a>从 Commit 看改进</h2><p>查看各个 commit，以及以前的代码，可以发现一些有趣的事。</p><h3 id="crankshaft"><a href="#crankshaft" class="headerlink" title="crankshaft"></a>crankshaft</h3><p>在 <a href="https://github.com/tj/node-thunkify/commit/d537460eb23e3d556c4f726eb04bef189dd3994f" target="_blank" rel="noopener">d53746</a> 这个 commit 中，提交者改变了 arguments 变成了数组的方式，从简单的 slice 方法，变成了声明一个数组然后一一赋值的方法。</p><p>第一次看到 <code>crankshaft</code> 还不知道是什么，后来才知道是指代 Chrome 的一个引擎。<a href="https://github.com/tj/node-thunkify/pull/12" target="_blank" rel="noopener">Pull request #12</a> 有提到这个优化，虽然我还是觉得这个优化在某种程度牺牲了部分可读性。</p><h3 id="remove-memoization"><a href="#remove-memoization" class="headerlink" title="remove memoization"></a>remove memoization</h3><p>参考 <a href="https://github.com/tj/node-thunkify/commit/30f25adebf79f4793fd5c8b6f873d5e093dfaf6d" target="_blank" rel="noopener">30f25a</a> 移除了一个记忆化操作。</p><p>在这个版本之前的代码，如果执行下面的程序，会发现这三次执行都输出同样的结果，这多多少少有点反直觉，所以 commit 上 tj 也说 <code>promises have different expectations</code>。</p>    <pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">done</span>) </span>{  done(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Date</span>.now())}<span class="hljs-keyword">let</span> dtn = thunkify(fn)()dtn(<span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))dtn(<span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))dtn(<span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))</code></pre><p>所以这个改进后，执行上述程序只会输出一次结果。</p><h3 id="add-assert-fn"><a href="#add-assert-fn" class="headerlink" title="add assert(fn)"></a>add assert(fn)</h3><p>在 <a href="https://github.com/tj/node-thunkify/commit/05abda9cba45b8669caebbeab4fbe5f4a666336b" target="_blank" rel="noopener">05abda</a> 处增加了一个 assert 调用避免被 thunkify 的参数不是函数 – 一个提高函数鲁棒性的功能。</p><h3 id="remove-support-for-eager-execution"><a href="#remove-support-for-eager-execution" class="headerlink" title="remove support for eager execution"></a>remove support for eager execution</h3><p><a href="https://github.com/tj/node-thunkify/commit/a504b918a93d04aaa62f467ae7213a25f47d0f69" target="_blank" rel="noopener">a504b9</a> 算一次比较大的改进，发现这个 commit 大大缩减了代码。不过这次删去了避免回调函数被多次执行的代码，也就是对回调函数的封装。在这之后的几个 commit 里，维护者又把这一层封装添加了回去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在没有看过 <code>thunkify</code> 源码的情况下，这个功能的实现并不算难。但 <code>thunkify</code> 代码比在本文开始我自己写的代码更优秀的地方就在于代码的鲁棒性，这一点从测试文件和 commit 日志中可见一斑，确实考虑了生产环境中可能出现的众多复杂情况，更适合日常使用。同时，阅读 <code>thunkify</code> 源码的目的也并不限于代码的实现，更多的是学习维护和增加代码的鲁棒性。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="noopener">Generator 函数的异步应用</a></li><li><a href="https://blog.daraw.cn/2016/11/11/notes-about-node-thunkify/" target="_blank" rel="noopener">node-thunkify源码阅读笔记</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了些项目的源码，其中就包括 &lt;code&gt;thunkify&lt;/code&gt;。虽然 &lt;code&gt;thunkify&lt;/code&gt; 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 &lt;a href
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>终于完成了一个 OJ -- Putong OJ</title>
    <link href="https://lazzzis.moe/2017/06/01/notes-of-putongoj/"/>
    <id>https://lazzzis.moe/2017/06/01/notes-of-putongoj/</id>
    <published>2017-06-02T03:53:12.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Putong OJ</strong> – 一个看上去很普通的 Online Judge，现已<a href="http://acm.cjlu.edu.cn" target="_blank" rel="noopener">上线</a></p><h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><p>说一些我自认为可以称得上特性的”特性”</p><h2 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h2><p>估计现在没有一个 OJ 采用的是单页应用吧。</p><p>其实最初开发单页应用的一个初衷是尽可能减轻服务器的压力，因为学校的服务器不是很好，这一点我后面还会说明。所以我觉得相比于后端渲染，前端渲染能减轻服务器压力。</p><p>另外，采用单页应用，那么后端就可以采用 restful 设计，后端的编写压力就减少了不少。前端方面因为采用的是 Vue 作为框架，开发上相对简单点，毕竟 vue 的学习难度比 react 要小一点，而且现在与 vue 相关的现成组件也不少，因此 <del>偷懒</del> 短期开发也是相对比较简单的。而且，我一个毕业狗，考虑到未来学弟学妹的维护难度，或许选择 vue 会好一点吧。</p><h2 id="Koa-v2-Restful"><a href="#Koa-v2-Restful" class="headerlink" title="Koa v2 + Restful"></a>Koa v2 + Restful</h2><p>后端上采用了 Node.js，而且采用了 koa v2 框架，摆脱了 callback hell，并且用上 <code>async / await</code>，因此在代码编写给人的快感自然要大于 Express。并且摆脱了后端渲染，restful 的后端框架说实话真的轻松了不少。</p><h2 id="干死-IE8"><a href="#干死-IE8" class="headerlink" title="干死 IE8"></a>干死 IE8</h2><p>在这里我还是 <strong>激进</strong> 了一点。保守一点说，现在大学内有一部分机子其实仍在坚持 IE8，而且是仅有一个 IE8 浏览器。如果从保证运行的角度看，我其实有责任兼容 IE8 的。但是从另一个角度看，我为何要兼容 IE8:</p><ol><li>现在都 2017 年，IE8 本来就该被淘汰，再怎么说 IE10 以上也是要的，而且学校这边有些机房的机子已经配备了 Chrome，那么其它机子同样配置 Chrome 也是早晚的事。</li><li>我何必要拿 IE8 折磨自己？如果要兼容 IE8，那么我至少 vue 都不能用了。既然连 vue 都不能用了，那写单页应用的难度就增加的不是一点半点。总不能让我用 jQuery 去写单页应用吧。。</li><li>跟上一条类似，一是保证我开发轻松，二是保证后来的学弟学妹维护轻松，我使用了很多一些现成的且简单易用的前端库，二这些前端库对浏览器的兼容性不一，但要保证全部都能正常运行，那么 IE 还是别想了。。</li></ol><h2 id="redis-mongodb"><a href="#redis-mongodb" class="headerlink" title="redis + mongodb"></a>redis + mongodb</h2><p>严格意义上说不上特性。但是确实觉得 redis + mongodb 确实省了不少力气。最直接的一点是 mongodb 的字段属性可以是数组，我可以用一个列表即可表示一个比赛内所有题目的 id，如果换作 mysql 的话，估计又多一张表了吧。有时感觉数据里的表就和代码行数一样，越多越容易出问题，所以还是尽量控制在可承受的范围内。</p><h1 id="开发杂想"><a href="#开发杂想" class="headerlink" title="开发杂想"></a>开发杂想</h1><h2 id="开发初衷"><a href="#开发初衷" class="headerlink" title="开发初衷"></a>开发初衷</h2><p>我写的这个 OJ 应该是第三代了。第一代是一名学长在 hustoj 起初上改写的 OJ。这个 OJ 用了大概 7，8 年了吧，而且还是部署在一台实体机里。估计跟机器老旧也有点关系，这台机器在某次拿去办比赛之后突然损坏了，而且是硬件损坏了，但幸运地是硬盘没问题，还可以把里面的数据取出来。</p><p>在这种情况下，上一届某学长决定重新写一个 OJ，而且为了表决心，毕业设计的题目就是作一个 OJ。在他的毕业设计任务书里也清楚写到要用 Golang + vue 的组合写一个 OJ。不过最后，他跑路了。。。他因为某些原因，并没有开发出一个新的 OJ，而是拿了 Github 上的一个用 Golang 写的但没用 vue 的 OJ 充当毕业设计了。然后这个 OJ 最后部署到了学校的云服务器上，并且还是用 docker 部署，就这样开始使用了。不过一个问题是，这位学长没有同步以前的数据，所以这个 OJ 部署上去后并没有以前的题目，而是全新的只有一道 A+B 的题目。这个 OJ 就是第二代 OJ 了，就这样用了一年，直到我重写。</p><p>第二代 OJ 其实也还好，毕竟这项目在 Github 上也维护了一段时间了，开发者也在生产环境上使用了一段时间了。因此，重写 OJ 更多的是出于我们自身的原因。一个比较直接但也有点尴尬的原因是这个 OJ 是用 Golang 写的。如果没人会 Golang，那么维护这个 OJ 就有点难了，因为指导老师会时不时要求对 OJ 做些改动。我不想否认 Golang 是一门优秀的语言，但问题是放在我所在的校园内，愿意学习 Golang 的人太少，包括我自己。我不想为了一个 OJ 而去学 Golang，更何况在我已经想用 Node 改写的情况下。另外，至少目前 Golang 的工作岗位相对较少，对某些人来说，学习 Golang 的动力略有不足。同样是学校不会教的语言，学习 PHP, Java, JavaScript, Python 对学生还是主流。</p><p>另一个改写的原因是，就是我单纯地想写一个 JS 前后端全包的网站了。这一点确实是出于自身利益。</p><h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>语言选择是第一道坎。如上文所说，其实有四个比较好的选择: PHP, Java, JavaScript, Python。一个首先排除 Java，尽管很多人写过 Java，但我个人对 Java 已经有点反感，不认同这一门废话多和设计模式多的语言; 对于 PHP，我没有学过 PHP，而且从我个人的理解看，PHP7 + Laravel 或许是可以考虑的，其它 PHP 版本和 PHP 框架似乎显得不怎么样; 对于 JavaScript 和 Python，我个人还是比较喜欢的，对于前者，只要搞前端的人都会，对于后者，学习成本低，而且学习的人也多，毕竟 Python 不止能用于 Web 开发。之所以选择 JavaScript 而不是 Python，只是单纯地认为 Node.js 性能会优于 Python，毕竟要考虑到学校给的机器挺一般的。另外选择 JS 的话，前后端都是 JS，对于维护者来说，或许也会轻松点吧。</p><h2 id="学校的服务器"><a href="#学校的服务器" class="headerlink" title="学校的服务器"></a>学校的服务器</h2><p>虽然平时用用是放在学校的云服务器上，可能还好点。但是到了比赛，为了搞起局域网，不得不把 OJ 弄到一个实体机并搬到比赛场地来，然而这个实体机真心不行。至少上一年的比赛就出了大问题，学生访问机器时，会出现“阻塞”，有时能访问，有时显示无响应。然后看机器上的 log，也没抛出异常，据学长说是并发可能有问题。</p><p>虽然不知道是不是真的是并发问题，但如果考虑到并发的话，目前除了 Golang，应该也只有 Node 是一个好的选择了吧。</p><h2 id="版本维护"><a href="#版本维护" class="headerlink" title="版本维护"></a>版本维护</h2><p>版本维护确实有点糟糕。或者说最初的版本维护根本说不上版本维护吧，感觉像打工作报告似的，每天写写今天做了啥。后来出现的一个问题是，版本控制形同虚设，后来我就几乎没做，然后更糟糕的是，我同时在两三台机器上开发，导致三台机器上的版本又不同步，此时我又想起了同步的好处 (╯°□°）╯︵ ┻━┻。</p><p>后来伴随着 koa v1 到 koa v2 的重写，以及前端增加 vuex，我干脆把 Github 上的项目删了重建，重新做了一个版本控制。这次做版本控制前又温习了一遍 git 的常用命令，开始搞起分支。而且发现 git 还有 archive 这个好用的命令。</p><h2 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h2><p>本来也想用 docker 部署的，无奈发现 npm 在 docker 里的速度实在是感人(。ヘ°)</p><p><img src="https://s29.postimg.org/4ii3q3chj/Screen_Shot_2017-06-02_at_10.11.01.png" alt="Github Issue"><span class="image-caption">Github Issue</span></p><p>最后用 docker 打包只有 redis 和 mongodb。</p><h2 id="起名"><a href="#起名" class="headerlink" title="起名"></a>起名</h2><p>其实我挺不想用学校的名义给 OJ 起名字，不想叫它 XX 大学 OJ，总觉得这样起名总有一种强调这是 XX 大学的 OJ，不是其它大学的 OJ 一样。但实际上，作为一个开源项目，至少别人想用就用，何必到处在 OJ 里强调大学。这让我想起来 Chrome 刚出来的时候，Chrome 刚出来的时候，界面完全找不到 Google 和 Chrome 标识的字样，让你感觉你就是单纯的使用一个优秀的浏览器，甚至让你不在意这是什么浏览器。所以我不用大学的名字起名，也有一丝这种想法，</p><p>另外，我也像想取个奇特点的名字嘛＼（Ｔ∇Ｔ）／</p><p>Putong 其实就是<code>普通</code>，想法就是来自于 <code>普通 Disco</code></p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=2129461&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>虽然开发上线了，不过有一些不足也是肯定了，争取毕业前把一些坑给填一下，比如多写点有意义的注释，留点有意义的文档之类的。还有一个给题目加标签的功能也没加，可能要留给后来维护的学弟学妹了吧。</p><p>OJ 后端的开发有很多参考了 <a href="http://acdream.info/" target="_blank" rel="noopener">Acdream</a> 和 <a href="http://acm.zjgsu.edu.cn/" target="_blank" rel="noopener">GoOnlineJudge</a> 的设计。这两个 OJ 都是优秀的 OJ。</p><hr><p><img src="/projects/images/48134921.jpg" alt="Pixiv ID 48134921"><span class="image-caption">Pixiv ID 48134921</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Putong OJ&lt;/strong&gt; – 一个看上去很普通的 Online Judge，现已&lt;a href=&quot;http://acm.cjlu.edu.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上线&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
      <category term="Projects" scheme="https://lazzzis.moe/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>杭州白马湖漫展一行</title>
    <link href="https://lazzzis.moe/2017/04/28/anime-convention-in-hangzhou/"/>
    <id>https://lazzzis.moe/2017/04/28/anime-convention-in-hangzhou/</id>
    <published>2017-04-29T01:51:02.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名在杭州读书的学生，其实从大一开始，我就一直想去这个展会了。第一次和第二次“太乖”，遇上了点学院的事，听了辅导员和学生会的建议，给他们做苦力去了。第三次正忙于升学考试，故自愿放弃了那次机会。但今年，我在杭州，又没有理由不去，所以还是去了。之所以选择这个日子（4月28日），主要还是因为听说“山下智博”也会来展，想去见见，所以选择了今天。</p><h1 id="无聊的-A-馆一层"><a href="#无聊的-A-馆一层" class="headerlink" title="无聊的 A 馆一层"></a>无聊的 A 馆一层</h1><p>本次展会分两个馆，A 馆与 B 馆。进门直接进的是 A 馆，而且 A 馆一层这些的“好位置”都给了“官媒” – CCTV，浙江卫视等媒体。相对来说，这些展位的内容显得无聊枯燥，这点从人数上就可以看出</p><p><img src="https://c1.staticflickr.com/3/2879/33512656613_cd0fb22bc0_c.jpg" alt="入口处观望"><span class="image-caption">入口处观望</span></p><h1 id="热闹的-A-馆二层"><a href="#热闹的-A-馆二层" class="headerlink" title="热闹的 A 馆二层"></a>热闹的 A 馆二层</h1><p>而二层则相对好多了。网易在二层占了两个展位 —- 一个给阴阳师，一个给网易的代理游戏（如守望先锋，星际，魔兽等）。我与小伙伴们在后一个展台前站了一会，看了看水友赛。不过可惜我也就凑凑热闹了，因为我压根不玩这些游戏。</p><p>阴阳师展位相当热闹。展位上同样有水友赛，但还有几个 COSer 作为主播在网易的 CC 直播上做直播。而这个展会最热闹的莫过于下午两点的“山下”登场时了。正如微博上所说，山下真的女装了，COS 了某个式神（原谅我连阴阳师也没玩过）。在活动的两个小时里，在主持人的主持下，山下与台下的观众做了些游戏，然后山下现场抽卡。总体来说，都是以阴阳师为主题的游戏。对于那些又爱山下又爱阴阳师的人来说最喜欢这种活动了。</p><p><img src="https://c1.staticflickr.com/3/2814/33512766803_663ae5457d_c.jpg" alt="阴阳师"><span class="image-caption">阴阳师</span></p><p>虽然我参观此展的目的之一是为了见山下智博，但我在看了一个小时后，默默地离开了一会。一方面如前文所说，我不爱也不玩阴阳师，听不懂主持人的话，不懂游戏的内容。另一方面，前面的人太高了！– 我看不到智博了。。。 <code>(╯︵╰,)</code></p><p><img src="https://c1.staticflickr.com/3/2890/33938820510_2ca58cc829_c.jpg" alt="阴阳师"><span class="image-caption">阴阳师</span></p><p>二楼另外的展位也都是游戏了，比如电魂等。对我这种不怎么看游戏的人来说，看了看一会就走了。</p><h1 id="更多精彩的-B-馆一层"><a href="#更多精彩的-B-馆一层" class="headerlink" title="更多精彩的 B 馆一层"></a>更多精彩的 B 馆一层</h1><p>或许 B 馆一层更符合参加漫展的人吧，这里云集了国外的展方，比如东京电视台，Disney。东京电视台的馆内还摆了各式的手办，标价大多 100 或 150，少数600，800。大多手版是 V 家，物语之类的，相对来说受众面还是比较宽的。馆外还摆了一排的扭蛋，10 RMB 一次。不过不管是扭蛋还是手办，我都没有入手。</p><p><img src="https://c1.staticflickr.com/3/2822/33512857933_f9ab1f14a3_c.jpg" alt="手办们"><span class="image-caption">手办们</span></p><p><img src="https://c1.staticflickr.com/5/4157/34323109655_990cf7229d_c.jpg" alt="兔斯基（注意背景是东京电视台展区）"><span class="image-caption">兔斯基（注意背景是东京电视台展区）</span></p><p><img src="https://c1.staticflickr.com/5/4166/33481472564_2c0cac72a9_c.jpg" alt="星战"><span class="image-caption">星战</span></p><p>除了国外的，也有国内的。展馆中心一眼就能看到 B 站的直播台，不过这个直播台对我来说又是一个没有吸引力的地方了。因为这里并没有多少活动，除了正午 12 点会有几名舞见来馆接受采访。</p><p><img src="https://c1.staticflickr.com/5/4182/33481242074_040d12d9f9_c.jpg" alt="B 站直播台"><span class="image-caption">B 站直播台</span></p><p><strong>最吸引我的</strong> 或许是 B 站旁边的天文角川了。在其它馆都在用大音箱放音乐的时候，只有天文角川默默地呆在那。馆内罗列了较多的书籍，从画册到小说，角川的主要卖品都有身影。大多数书籍都已塑封，因此很少有人对着一本书看太长时间。在这些书籍中，《冰菓》很好地吸引了我的目光。就在前几天，我就有想买《冰菓》第 5 册的冲动，但苦于线上的商家无货。而我在线下却见到了实体书籍，自然让我兴奋了好一会。原价 25 的书籍，实付 20，同时附赠了一张海报。买书是在早上，在快结束展会的时候，我还是回到了天文角川看了一会，犹豫着是不是要再买些书。尽管有一些 5 元特价书，如 灼眼的夏娜，但我仔细思考下，从以前的经历看，我就算买了这书估计也不会太喜欢看。因此第二次去天文角川并没有买什么物品。</p><h1 id="乱七八糟的-B-馆二层"><a href="#乱七八糟的-B-馆二层" class="headerlink" title="乱七八糟的 B 馆二层"></a>乱七八糟的 B 馆二层</h1><p>B 馆二层显得无序一点。这里有一些奇怪的官方展位 – 比如阿里云（你来混脸熟么？），也有部分不知名的小商铺。在二层仍能看到 B 站的身影 – B 站的店铺。不过 B 站内的商品与淘宝上的 B 站店别无二致，价格也无多少优惠，再者实用性或是装饰性也略差，我觉得我还没到给 B 站充信仰的程度，故而没在此购物。</p><h1 id="全是小商铺的-B-馆三层"><a href="#全是小商铺的-B-馆三层" class="headerlink" title="全是小商铺的 B 馆三层"></a>全是小商铺的 B 馆三层</h1><p>这里几乎全是小商铺。本以为会有各种新奇的周边，但仅逛了一会就发现我还是想错了。这里的商铺 <strong>同质化</strong> 有点严重。80 % 以上的商品分为 4 类 – 手办类，抱枕类，挂画类，福袋类。其中后三种几乎会同时在同一个商铺内，因此这么算的话，也就两种商铺了。而我对挂画和抱枕比较挑剔，又不信福袋。这么一算也就只能看看手办了。然而，相对竞争力而言，这些商铺的手办尽管自称官方，但似乎从每种角度上比不上国外方展馆所卖的更具官方性。况且手办的受众其实不如抱枕之类的，一个“滑稽”抱枕几乎男女通吃，只要玩表情的路人几乎都会心动一下。总的来讲，商家间的区别在品类上已经不算大，在加上抱枕挂画之类的主题几乎也有很大一部分的重叠，商家与商家的区别只能体现在福袋的大小与价格上了。因此，这里的商铺并不算多样与精彩。</p><p><img src="https://c1.staticflickr.com/5/4168/34282275796_0d6234e1c1_c.jpg" alt="商铺内的手办"><span class="image-caption">商铺内的手办</span></p><p>即使如此，却还是有一个与周围“格格不入”的商铺 – 一家卖 CD 的商铺。这家商铺也主要以 ACG 为主，而且还包含了东方同人！（这个馆内东方的数量并不多，甚至稀有）在价格上，商家已经打出了买一送一的策略，而且一张的价格收 90 RMB，看起来是比较划算的。我挑选了一张化物语的CD（刚好最近在补化物语），然后挑了一张蝶 P 的碟。这次消费算已经是我在这次行程中最大的消费了。除了这些 CD 能吸引我的兴趣外，其它真的很少了。</p><h1 id="无存在感的-B-馆四层"><a href="#无存在感的-B-馆四层" class="headerlink" title="无存在感的 B 馆四层"></a>无存在感的 B 馆四层</h1><p>除了“朱德庸”展区有点意思，其它展区（儿童画，法制题材画）实在没啥人看。</p><p><img src="https://c1.staticflickr.com/3/2858/34192123471_62f52f2c35_c.jpg" alt="漫画家朱德庸的作品"><span class="image-caption">漫画家朱德庸的作品</span></p><h1 id="一些吐槽"><a href="#一些吐槽" class="headerlink" title="一些吐槽"></a>一些吐槽</h1><p>尽管这次的展会是以动漫为主题，不过 BAT 也还是齐了 – 腾讯动漫，阿里云，以及百度外卖。。。</p><p>馆内居然还有 vipabc，英孚教育的商铺。别人买了亲子票带孩子来玩，孩子很高兴，然后父母却又给他们报了个班？</p><p>没怎么看清山下智博，除了前面的观众挡住我的视线外，一个做直播的刚好也挡住了我的视线。</p><p>优酷，qq 等展位上都放了自家的或流行的动漫角色，而旁边的乐视放了消防教育动漫展（你为何不与法制教育主题展放到同一个展区呢？）。</p><p>还真有老年人来参观的，估计是陪孩子吧，还真是辛苦了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大学最后一次漫展，但却也是我参与的第一次漫展，也总算在毕业前完成了“参观漫展”这个任务。以后还会不会参加呢？如果有的话，我还是会考虑参加的。</p><p>最后，贴张照片，拍摄于 B 站展区内(暂时不想露脸)：</p><p><img src="https://c1.staticflickr.com/3/2811/34282503846_622ff1db53_c.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名在杭州读书的学生，其实从大一开始，我就一直想去这个展会了。第一次和第二次“太乖”，遇上了点学院的事，听了辅导员和学生会的建议，给他们做苦力去了。第三次正忙于升学考试，故自愿放弃了那次机会。但今年，我在杭州，又没有理由不去，所以还是去了。之所以选择这个日子（4月28日
      
    
    </summary>
    
    
      <category term="ACG" scheme="https://lazzzis.moe/tags/ACG/"/>
    
  </entry>
  
  <entry>
    <title>一周面试小结</title>
    <link href="https://lazzzis.moe/2017/03/24/recent-interviews-in-march-2017/"/>
    <id>https://lazzzis.moe/2017/03/24/recent-interviews-in-march-2017/</id>
    <published>2017-03-25T01:38:09.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景及摘要"><a href="#背景及摘要" class="headerlink" title="背景及摘要"></a>背景及摘要</h1><p>3 月 15 日，浙大玉泉校区举办了一场招聘会，近几百家单位参加。虽然我不是浙大本校生，但是外校学生若携带学生证件也是可以进入的。我总共带了 12 份简历前往，并全部投出。我的目标岗位为 Web 前端开发，但也对 Python / Node.js 后端有意向。目前我已进行了 3 次面试，分别是 <a href="https://www.lagou.com/gongsi/137471.html" target="_blank" rel="noopener">数聚科技</a>, <a href="https://www.lagou.com/gongsi/178043.html" target="_blank" rel="noopener">谷神星</a>, <a href="https://www.lagou.com/gongsi/210.html" target="_blank" rel="noopener">企朋</a> （点击可查看拉钩网上的信息）。我想在这篇文章里分享一下我这几次的面试过程，谈谈我的一些想法，希望对大家有帮助。</p><h1 id="招聘会"><a href="#招聘会" class="headerlink" title="招聘会"></a>招聘会</h1><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>这是我的 <a href="https://drive.google.com/file/d/0B46-8KBsYVBpcUZuemJqLXhFalk/view?usp=sharing" target="_blank" rel="noopener">简历</a> 。因为这份简历仅用于交流，因此我故意抹去了一些信息，比如真实姓名，联系方式，就读的大学等。同时这份简历是我在招聘会后稍作了修改的简历（增加了专业，意向岗位，将 “Java实习生” 改为 “Web 实习生”，其它均未改动）。</p><p>事实上这是我第一次做招聘用的简历，直接套用了 Google Docs 的一个 Resume 模板。但是有几个细节在编辑时没有注意，在招聘会后或面试时我才发现这些是个问题：</p><ol><li><p><strong>没有标注专业</strong>。尽管现在有很多公司也不会太在意你是否是计算机专业出生，但专业本身仍然是 HR 关注的一个重要信息。其次，有些公司在招聘要求上也明确说明需要计算机相关专业的应聘者。因此专业作为一个关键信息仍不能忽视。</p></li><li><p><strong>没有写明目标岗位</strong>。在最初的（也就是用于投递的那一版的）简历里，我没有明确说明意向。招聘会上，有些 HR 会将收到的简历按岗位分开存放。但有些 HR 则不然。或者说，在人多的情况下， HR 也难免会忘记你的意向。注意，我在最初的简历中有写 “Java” 实习生的经历。这本来没问题，但是在我没写清岗位的情况下，有几位 HR 错以为我对 “Java工程师” 有意向。因此，目标岗位也是极重要的信息。</p></li><li><p><strong>简历或许可以再紧凑一点</strong>。看了一些他人的简历，大多有表格辅助，而且空间利用率明显比我的简历要高。或许可以再思考一下如何再打扮一下我的简历。</p></li></ol><h2 id="现场"><a href="#现场" class="headerlink" title="现场"></a>现场</h2><p><strong>请务必先详细了解招聘场所内的具体分布！</strong></p><p>当我到招聘会现场时，计划时长 3 小时的招聘会已经举办了半小时了。我当时也没注意 3 个场所内公司的分布，所以我一到现场时就先跑进了第一个分会场。看完第一个会场后我就前往了第二个会场。而当时的我仅知道有 3 个会场的存在，但不清楚 3 个会场中公司摊位的数量。结果就是，我在第 2 个会场花了近一个小时。而到了第 3 个会场，我呆了，这里比第 2 个会场有更多的企业。这时，距离结束大约剩余 1 小时。而且在最后大约 20 分钟，我惊奇地发现，这个场所（一个排球馆）的某处有一个不长的通道，通向同一场所的另一个区域 – 这里还有将近 100 家企业。更糟糕的是，<strong>他们已经开始收摊</strong> 了。更更糟糕的是，此时的我。。。手头已经 <strong>没有剩余的简历了</strong>。</p><h1 id="数聚科技"><a href="#数聚科技" class="headerlink" title="数聚科技"></a>数聚科技</h1><p>我应聘了这家公司的前端，是第二个联系了我的公司（第一个公司以为我要应聘 Java 。。。所以我在电话上就拒绝了 HR）。HR 与我约好周五见面，时间是 3 点到 4 点。</p><p>公司位于浙大科技园（浙大玉泉校区附近）。园内环境可以，但园外。。。背后是丘陵。</p><p><img src="https://s22.postimg.org/50rcp9jn5/Screen_Shot_2017_03_22_at_22_54_21.png" alt="园内"><span class="image-caption">园内</span></p><p><img src="https://s17.postimg.org/588dmvpnz/Screen_Shot_2017_03_22_at_22_53_54.png" alt="园外"><span class="image-caption">园外</span></p><p>面试者是两人，分别是 HR 以及一名技术员工（该员工并没详细介绍自己，但从年龄和谈话上看，应该不是 CTO 或 PM）。</p><p>对话首先以我简历上的项目为重点，主要问了我采用了哪些工具（框架以及包）。接着聊了一下我何时毕业以及我的住处问题。最后商讨薪水。</p><p>整个过程中没有询问任何 <strong>技术上的问题</strong>。谈话中仅仅是说我怎么做项目。但没有问我如何解决一些问题，比如：如何解决高并发问题，也没有问我任何关于 JavaScript 语言的相关问题。</p><p>其次，这个 HR 对技术不是很了解。虽然对于 HR 应不应该懂技术这个问题我保留意见，但我还是想吐槽一下。我在谈项目时我把 <code>Vue</code> 念作单词发音，而不是读成 3 个字母 (<code>V-U-E</code>)。但当我讲完项目后，HR 还是问了一句：你既然对这个 “wei you” 框架这么熟悉，那你对 <code>V-U-E</code> (读这 3 个字母) 熟不熟悉呢？ 我: (；￣Д￣） 这不同一个玩意么。。。</p><p>还想吐槽一点，这个技术员工 <strong>似乎也不是特懂技术</strong>。因为我在简历里写了 SCSS (可以参考 <a href="http://sass-lang.com/" target="_blank" rel="noopener">Link</a>)，但这技术人员却说：这里是不是写错了，SCSS 是什么，应该是 CSS 吧？ 我: ヘ(゜Д、゜)ノ 你不是技术人员么？</p><p>另外，目前这个公司前端业务不算特别重。据悉，该公司近期做的一个项目是调查问卷。这也难怪他们问我是否用过 E-Charts。不过当时我也完全不知道 E-Charts 是什么。</p><p>总的来说，我个人对这家公司的面试感觉一般。因为我对面试也报了一种 <strong>学习</strong> 的态度，希望能在面试中也能了解一些自己的不足。但是这次面试恰恰相反，我反倒看到了他们的一些不足。</p><p>关于薪水，我当时没有提，因为我还真没认真想这事，以为公司会主动提供数字再让我做决定。所以当时只是说之后电话联系。</p><p>这是星期五（3 月 17 日）的面试，在这之后的第 3 天（星期一），我接到了 HR 的电话。电话中 HR 通知了我被录取的消息，不过在 HR 提出薪资前，我就回绝了。不管这个公司是否真的有前景，但至少我觉得我极不适合这个公司。</p><h1 id="企朋"><a href="#企朋" class="headerlink" title="企朋"></a>企朋</h1><p>先上结论，这是我目前面试中 <strong>最满意</strong> 的公司，无论从面试过程还是公司本身来说。</p><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>笔试总体分三部分: 网络相关知识，算法编程知识，语言相关知识。可以看出该测试偏概念与算法，比如快排或 GC，没有考某某对象的使用或某某方法的使用。至于具体题目，我觉得还是不要透露的好。总之，对于这份试卷，虽然有几题明显可以看出是非原创的（就是从网上抄的），但总体上还是比较能反映一个编程者的基本素养的。</p><h2 id="一面（技术面）"><a href="#一面（技术面）" class="headerlink" title="一面（技术面）"></a>一面（技术面）</h2><p>本以为前端工程师会问我关于 <code>prototype</code> 或 <code>Object</code> 相关的问题，但事实上这一位工程师没有注重这方面，而是问了我一些关于 <code>yield</code>，以及 <code>async await</code> 的一些问题。</p><p>同时也问了一些关于 <code>session</code> 的概念或实现。我对 <code>session</code> 的理解程度仅仅是用 <code>Node.Js</code> 的某个包实现的程度。所以这方面我确实不懂，反而是工程师教导了我。</p><p>再者，工程师和我聊了一些我项目上的事，针对我项目中写的提问，比如 restful 理解之类的。</p><p>总体上讲，前端工程师并没有问那些 <code>JavaScript</code> 中的那些坑，而是注重我在项目上的实际能力，因为工程师多次对我如何理解和解决问题发问。</p><h2 id="二面-CTO"><a href="#二面-CTO" class="headerlink" title="二面 (CTO)"></a>二面 (CTO)</h2><p>技术面之后，马上就安排了 CTO 前来面试。</p><p>不得不说，CTO 整个人显示的气场就很不一样。第一眼看上去，CTO 和蔼可亲，同时有温文尔雅；而在提问和聊天时，又显得沉着睿智。</p><p>和 CTO 的聊天中，我也明显感觉他的表达能力比我更甚一筹。举个例子，在聊项目时，我提到我对排行榜的处理是先以分数排序，再按时间顺序排序。而 CTO 一转述，则变成: <strong>此排序以分数为第一维度，以时间为第二维度</strong>。这种表述便显得书面化，也不容易被人误解。</p><p>CTO 也问了我一些关于 <code>情怀</code> 的题，比如你崇拜的人之类的。（P.S. 这个问题好像有很多公司问呀，我在招聘会上就被一个公司问过了，还同样是一个招前端的公司 ((´д｀)) ）</p><p>CTO 的具体问题细节同样就不透露了，但 CTO 的问题的出发点比前端工程师的站在一个更高的角度，包含了我对项目整个过程中出现的问题以及我个人的一些修养（比如对于 <code>Open Source</code> 和 <code>新技术</code> 的看法）。</p><p>当然，这面试并不是单向的，最后 CTO 允许我问他一些问题。CTO 对我的问题进行了耐心详细的解答，而不是一句两句带过。这让我感觉 CTO 是真心希望我能问问题的，而不是出于某些礼貌说的客套话。</p><h2 id="三面-HR"><a href="#三面-HR" class="headerlink" title="三面 (HR)"></a>三面 (HR)</h2><p>和 HR 的聊天集中于待遇和我的需求。HR 给的关于实习薪资就蛮高的，是一些工资的 1.5 ~ 2 倍。（我认为薪资是一种隐私，所以具体数字就不提了）</p><p>另外，同 HR 的聊天中我也了解到这家公司也很注重效率和协作。HR 跟我解释了目前公司使用的协同工具和技术。从这个角度看，在这家公司工作，<strong>沟通不是问题</strong>。</p><p>和 HR 的整体过程很愉快，尤其当 HR 说我有 <strong>极客范</strong> 的时候 ＼(^▽^＠)ノ。真的，这句话足以让我高兴一整天；<strong>对于目前的我来说，这几乎是最大的认可</strong>。并且，这名 HR 是第一个这么评价我的人。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>这个公司的环境很棒！</strong></p><p>一进门就感觉这很有 google 的风范。办公室边上有零食架，健身器材，以及其它游戏措施。按 HR 的说法，<strong>这是为了让员工专注于手头的任务</strong>。</p><p><img src="https://s9.postimg.org/kjfijydu7/Screen_Shot_2017_03_23_at_23_37_38.png" alt="公司一角"><span class="image-caption">公司一角</span></p><p><img src="https://s10.postimg.org/ro11xzw61/Screen_Shot_2017_03_23_at_23_59_04.png" alt="公司一角"><span class="image-caption">公司一角</span></p><p><img src="https://s21.postimg.org/mr83kbpc7/Screen_Shot_2017_03_24_at_00_01_10.png" alt="公司一角 -- 吃饭啦！"><span class="image-caption">公司一角 -- 吃饭啦！</span></p><p>另外，在面完 CTO 后，刚好是午饭时间，CTO 和 HR 很友好地请我在公司吃饭。我刚开始出于礼貌而委婉地拒绝了，不过在几次邀请下还是放开吃了。。。嗯，味道不错！ლ(⌒▽⌒ლ)</p><h2 id="谷神星"><a href="#谷神星" class="headerlink" title="谷神星"></a>谷神星</h2><p>首先我表示一下我对这个公司的歉意，因为我迟到了一个小时。以至于到了之后，技术人员有事不在了，所以面试我的反而是一名销售人员。</p><p>销售人员看了简历之后让我介绍自己并讲讲简历上的项目。不过讲到一半时，他打断了对话。他很坦诚的表示，自己只是销售，不懂技术。说罢，还给了我一些建议，比如简历上还是缺少点亮点，说话不够简洁。可能有人觉得这名销售有点无理，但我却不这么认为。从当时销售的语气和表情看，销售确实是出于好意所以打断对话并给我建议，因为我继续讲技术也是对牛弹琴，同时我也确实有表现不好的地方。</p><p>与销售聊完后，HR 与我约好，（当天为周二）过一两天后，我将会与现位于温哥华的一名技术人员进行电话面试。</p><p>周四早上，我与技术人员进行了约好的（微信）电话面试。</p><p>从通话开始，技术便开始提问，首先是关于 <code>Java</code> 的，比如 <code>Spring</code> 的特点。但说实话，我对 <code>Java</code> 并不在行，所以回答得支支吾吾。</p><p>后来又问了一些 <code>JavaScript</code> 的问题，比如 <code>Synchronous vs Asynchronous</code>，<code>Promise</code> 等。因为这与前端相关，所以我比刚才表达更加流利了。</p><p>接着，对 database 又提问了一些，比如 <code>transaction</code>，几条 <code>SQL</code> 语句等。我对数据库只会基本使用，但一些特点却不然。因此这里回答的也很一般。</p><p>最后，技术让我介绍自己做的一个项目。我自然讲了我最近做的那个在线评测系统。</p><p>若让我作个评价，我会说这个技术也确实懂点技术的，对我的提问也明显注重于一些语法的细节和特点。但对我个人如何实现整个项目以及实现项目的能力过问的很少。</p><p>至于我对这个公司的看法，主要是薪资水平太低了。实习生工资也才 3K，而且之前销售还没讲转正后的具体薪资的，只说工资是看实习表现再决定的。初次之外，这个公司并没有专门的前后端，换句话说，我要同时处理前后端认为。这对我来说是不可接受的，毕竟我在之前的一次实习中已经体验过这种开发了。一般这种做法对开发者的负担还是有点大， 不能专心于一件事情之中。因此，我决定拒绝掉这个公司。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前面试了就这几家，剩下几家要么没通知，要么已经预约了面试但还没到时间。如果后续还有面试，我大概会写一篇新的文章来分享自己的经历和想法。</p><p>但就这几家而言，我个人认为面试是可以准备的，某种程度上也类似与应试考试，允许你临时抱佛脚。但，面试的最终表现还是基于你的真实水平的，依你平时的水平已经基本决定了面试的表现。面试前多做些细节准备能增加面试官的好感度，但并不能仅凭借这些就获得面试官的芳心。</p><p>所以，一方面平时必须要做些项目。这些项目最好与你期望的岗位相关，同时最好是具备一定复杂程度的，比如一个单纯的获取在线时间的爬虫是不够的，但如果是一个能够爬多个网站并能根据比较数据给出建议的爬虫则相对高级很多，则可以显得你能组织代码以及分析问题。同时，对于一个较大的项目，最好是能正式上线的，因为这可以体现你有能力维护代码。另外，我个人认为项目的数量不在多，而在精 —- 你有时间写 10 个冒泡排序还不如写 1 个快速排序来提升算法能力。</p><p>至少，我这几个面试基本上是靠项目 <code>在线评测系统</code> 来与面试官进行交流的（或者是说靠”吹”的 ﾍ(￣ ￣;ﾍ)），如果这个项目不够，简历上的实习也基本能充当谈资了。至于另外的几个项目 – 个人博客 之类的，就是用来凑篇幅的 – 面试官很少提它们，我也几乎不会主动靠它们彰显自己的能力。不过，我不得不说我在简历里的一个遗憾，我没有发布过任何一个包 – 无论是 Python 还是 Node.js 。发布一个好用可维护的包已经添加到 2017 的 Todo-List 里了。</p><p>最后，希望我的这篇文章能给大家一些帮助；同时，祝大家都能拿到满意的 Offer。</p><hr><p><img src="https://s27.postimg.org/mpd84np37/49916912_p0.jpg" alt="Pixiv ID: 49916912"><span class="image-caption">Pixiv ID: 49916912</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景及摘要&quot;&gt;&lt;a href=&quot;#背景及摘要&quot; class=&quot;headerlink&quot; title=&quot;背景及摘要&quot;&gt;&lt;/a&gt;背景及摘要&lt;/h1&gt;&lt;p&gt;3 月 15 日，浙大玉泉校区举办了一场招聘会，近几百家单位参加。虽然我不是浙大本校生，但是外校学生若携带学生证件也
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>howdoi 源码阅读与分析</title>
    <link href="https://lazzzis.moe/2017/03/04/source-code-of-howdoi/"/>
    <id>https://lazzzis.moe/2017/03/04/source-code-of-howdoi/</id>
    <published>2017-03-05T02:49:27.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gleitz/howdoi" target="_blank" rel="noopener">howdoi</a> – 一款通过命令行帮你从 stackoverflow 中寻找答案的工具，其源代码部分不足 300 行。同时，这份代码被 <a href="http://docs.python-guide.org/en/latest/writing/reading/" target="_blank" rel="noopener">The Hitchhiker’s Guide to Python!</a> 推荐为适合新手源码阅读的代码。因此，在读完源码后，我分享一下我对这份代码的理解。</p><p>这里采用的版本是 tree 中标号为 <a href="https://github.com/gleitz/howdoi/tree/d84afdee603dbe699153e35650d46ddd734337d1" target="_blank" rel="noopener">d84afdee60</a> 的那一版</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>简单的概括:</p><blockquote><p>获取搜索关键词 –&gt; 通过爬虫找到 stackoverflow 上的答案(html 格式) –&gt; 对 html 进行解析拿到答案</p></blockquote><p><img src="https://s8.postimg.org/nqgt134np/Screen_Shot_2017_03_04_at_22_59_06.png" alt="一副简单的示意图"><span class="image-caption">一副简单的示意图</span></p><h2 id="获取关键词"><a href="#获取关键词" class="headerlink" title="获取关键词"></a>获取关键词</h2><p>其中 <strong>关键词</strong> 必须从终端获取，这一步可以通过 Python 自带的包 <code>argparse</code> 实现。</p><p>在代码的第 153 行，<code>args[&#39;query&#39;] = &#39; &#39;.join(args[&#39;query&#39;]).replace(&#39;?&#39;, &#39;&#39;)</code>， 这里作者将关键词中的问号去掉了。刚开始误以为这个处理是怕将问号放到 url 后，问号后面的字符串会变为 url 中查询的参数，从而没有达到使用者的意图。事实上，我的这个想法是错误的，因为之后的代码中，作者会将查询的字符串转义了。我的第二个猜测认为问号会影响 google 查询的结果，因为 <code>?</code> 符号是 google 搜索的指令之一，比如 搜索 <code>c?lor</code> 和 <code>clor</code> 的结果几乎是完全不同的。</p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><p>而爬虫部分，则使用包 <strong>requests</strong> ，其中 url 采用的是 google 搜索的 url, <code>&#39;https://www.google.com/search?q=site:{0}%20{1}&#39;</code>。其中 0 位对应搜索的目标网站，而 1 位代表搜索的内容。比如 <code>&#39;https://www.google.com/search?q=site:stackoverflow.com%20python%20async&#39;</code> 代表在 stackoverflow 上搜索有关 <code>python async</code> 的内容，相当于你在 google 的搜索框里输入了 <code>site:stackoverflow python async</code>。其中 site 是 google 搜索的一个指令，其它指令还包括 <code>filetype</code> (制定文件类型)等。</p><p>而 1 的位置填的搜索的内容正是命令行中输入的内容。为了安全起见，最好将其转义，如代码中 95 行所示 <code>result = _get_result(SEARCH_URL.format(URL, url_quote(query)))</code>。假如 <code>query = &#39;foo bar&#39;</code>, 那么转义后 <code>query = &#39;foo%20bar&#39;</code>。</p><h2 id="解析-html"><a href="#解析-html" class="headerlink" title="解析 html"></a>解析 html</h2><p>采用的工具是 <code>pyquery</code>，它可以让使用者像使用 <code>jquery</code> 一样解析 html 代码。</p><p>第一次拿到的 html 是 google 搜索的结果，而不是 stackoverflow 的页面，所以要先拿到有答案的 stackoverflow 的页面。函数 <code>_is_question</code> 帮助程序识别超链接是否是 stackoverflow 的链接。</p><p>如果是 stackoverflow 的链接，那么接下来有一个分支 – 第 151, 152 行。</p><ol><li>用户只需要 url。那么就此打住，将 url 返回即可。</li><li>如果用户需要答案。就对这个链接做一次请求，这一次拿到的 html 就是 stackoverflow 有提问和回答的页面了。为了提高拿到的答案的可靠型，在 153 行，<code>page = _get_result(link + &#39;?answertab=votes&#39;)</code> 使得 stackoverflow 页面返回的结果是根据答案的支持数从高到低排序的。</li></ol><p>拿到页面后，再对 html 分析，这里又有一个分支。如果用户只要代码，拿到 <code>pre</code> 标签内或 <code>code</code> 标签内的内容返回，否则把答案的文本全部返回。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>以下几个部分即使删去，也并不也影响程序的主要功能。但加上的话可以很好的改善用户体验。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>对应函数 <code>get_proxies</code>。其中作者还为没有用 http 开头的网址加了 http，比如 <code>{&#39;http&#39;: &#39;localhost:1080&#39;}</code> 会转化为 <code>{&#39;http&#39;: &#39;http://localhost:1080&#39;}</code>。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果开启缓存而且搜索次数多了，缓存可以很好地改善用户体验。作者的实现采用了 <code>requests_cache</code>。使用也挺简单的，不多说了，可以参考<a href="https://github.com/reclosedev/requests-cache" target="_blank" rel="noopener">文档</a>。</p><h3 id="颜色输出"><a href="#颜色输出" class="headerlink" title="颜色输出"></a>颜色输出</h3><p>这也是改善用户体验的一个途径。作者采用的是 <a href="http://pygments.org/" target="_blank" rel="noopener">pygments</a> 。用 pygments 提供的 lexer 对字符串解析并加上颜色。</p><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>这里讲一些我从这份源码中比较有启发的代码风格</p><h2 id="私有函数"><a href="#私有函数" class="headerlink" title="私有函数"></a>私有函数</h2><p>Python 中并没有严格意义上的 私有函数，一般来讲，名字以但下划线开头的即为 <strong>不推荐调用</strong> 的函数，也可以认为属于私有函数。而观察这个项目以前的代码，可以发现最早并没有私有函数。私有函数的出现起于 <a href="https://github.com/gleitz/howdoi/pull/132" target="_blank" rel="noopener">Pull Request: PEP 8 conventions #132</a>。个人认为区分私有和公有的区分对于使用者的学习还是有帮助的，尤其是文档不多或者使用者比较着急使用的情况下，使用者可以直接看公有函数。另外，公有函数也警告使用者不要随意调用，因为有些私有函数的随意调用可能会造成一些对项目比较危险的结果。</p><h2 id="函数的顺序"><a href="#函数的顺序" class="headerlink" title="函数的顺序"></a>函数的顺序</h2><p>不知是无意还是有意，函数的顺序根据调用的顺序逆序排列。比如我们从 <code>command_line_runner</code> 看起，这个函数第一个出现的调用是 <code>get_parser</code>，而源码中 <code>command_line_runner</code> 的上一个函数就是 <code>get_parser</code>。继续往下看，则可以看到 <code>_clear_cache</code>, <code>_enable_cache</code>。而这个顺序刚好是你从文件尾往文件头看得顺序。也就是说，每次我看到一个函数调用时，我肯定往上翻就行了，而且越先看到的越先出现，这给阅读源码带来了很大的便利。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>我发现这里的常量包括了作为模板的字符串，如 <code>SEARCH_URL = &#39;https://www.google.com/search?q=site:{0}%20{1}&#39;</code>。仔细想想，我好像以前写常量都是固定的字符串或数字，这种模板型的字符串常量我好像一直没用过。</p><h1 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h1><p><code>URL = os.getenv(&#39;HOWDOI_URL&#39;) or &#39;stackoverflow.com&#39;</code></p><p>注意这里用的 stackoverflow 地址是 <code>stackoverflow.com</code>  而不是 <code>www.stackoverflow.com</code>。这是有区别的。使用前者搜索，出来的 stackoverflow 相关链接大多是 <code>stackoverflow.com/problems/(\d+)/</code> 形式，而使用后者，大多出现的是 <code>www.stackoverflow.com/a/(\d+)/</code> 形式。前者的形式相对后者的形式更容易判断一个链接是不是 stackoverflow 的问题链接。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>howdoi 的点子很好，而且源码确实比较易懂。读完源码之后，建议可以自己试着实现一个类似的或用其它语言复刻一个。毕竟，有些问题是只有开发时才能想到的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/gleitz/howdoi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;howdoi&lt;/a&gt; – 一款通过命令行帮你从 stackoverflow 中寻找答案的工具，其源代码部分不足 300 行。同
      
    
    </summary>
    
    
      <category term="Python" scheme="https://lazzzis.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 对函数默认参数的处理</title>
    <link href="https://lazzzis.moe/2017/01/16/default-para-in-python/"/>
    <id>https://lazzzis.moe/2017/01/16/default-para-in-python/</id>
    <published>2017-01-17T01:13:49.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 对函数默认参数的处理</p><p>一个以可变对象为默认参数的函数:</p>    <pre><code class="lang-Python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.x = <span class="hljs-number">1</span>        print(<span class="hljs-string">'created'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(a = A<span class="hljs-params">()</span>)</span>:</span>    a.x += <span class="hljs-number">1</span>    print(a.x)<span class="hljs-comment"># output: created</span>f() <span class="hljs-comment"># output: 2</span>f() <span class="hljs-comment"># output: 3</span></code></pre><p>从结果可以看出，Python 在解析时便已经创建好了默认参数 a 的值。函数 f 在调用时采用了同一个对象，而不是每次调用时重新创建新的对象。这一点与 <code>C++</code> 的处理方式不同。</p><h1 id="f-defaults"><a href="#f-defaults" class="headerlink" title="f.__defaults__"></a><code>f.__defaults__</code></h1><p>在 Python 中，函数属于一等公民(first-class)。函数可当作一个对象，拥有自己的属性与方法。而默认参数则存在与函数的一个属性中。</p>    <pre><code class="lang-Python"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[28]</span>: <span class="hljs-selector-tag">def</span> <span class="hljs-selector-tag">f</span>(a, b=<span class="hljs-number">1</span>):       <span class="hljs-selector-tag">2</span>     <span class="hljs-selector-tag">pass</span><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[29]</span>: <span class="hljs-selector-tag">f</span><span class="hljs-selector-class">.__defaults__</span><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[29]</span>: (<span class="hljs-number">1</span>, [])</code></pre><p>Python 在解析代码时，便会将默认参数存于 <code>f.__defaults__</code> 中。</p><p>在 CPython 的 (funcobject.h)[<a href="https://github.com/python/cpython/blob/master/Include/funcobject.h]" target="_blank" rel="noopener">https://github.com/python/cpython/blob/master/Include/funcobject.h]</a> 中也可以看到，<code>PyFunctionObject</code> 的一个属性便是 <code>func_defaults</code>, 对应 Python 中每个函数中的 <code>__defaults__</code> 属性</p><h1 id="默认参数-与-闭包"><a href="#默认参数-与-闭包" class="headerlink" title="默认参数 与 闭包"></a>默认参数 与 闭包</h1><p>以下是一个经常被提起的关于理解闭包的一段代码</p>    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>:</span>    lst = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        lst.append(<span class="hljs-keyword">lambda</span> x: x * i)    <span class="hljs-keyword">return</span> lstlst = test()[f(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> lst]<span class="hljs-comment"># Output: [4, 4, 4, 4, 4]</span></code></pre><p>在这里中，匿名函数中的变量 <code>i</code> 并没有在声明时便被求值，而是在匿名函数被调用时才被求值。因为 <code>i</code> 来自于 <code>test</code> 函数，且在匿名函数被调用时，循环已经结束，所以 <code>i</code> 的值已经变成 4。</p><p>但如果想让 <code>i</code> 在匿名函数声明时便被求值该如何做呢？<br>以下代码便借助默认参数解决问题:</p>    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>:</span>    lst = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        lst.append(<span class="hljs-keyword">lambda</span> x, i=i: x * i)    <span class="hljs-keyword">return</span> lstlst = test()[f(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> lst]<span class="hljs-comment"># Output: [0, 1, 2, 3, 4]</span></code></pre><p>与第一段代码相比，第二段代码中的 <code>i</code> 在匿名函数声明时就被求值，而且因此，每个匿名函数拥有的默认参数 <code>i</code> 的值都不相同。这样解决了问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/python/cpython/blob/master/Include/funcobject.h" target="_blank" rel="noopener">funcobject.h</a></li><li><a href="http://stackoverflow.com/questions/10120974/where-is-the-default-parameter-in-python-function" target="_blank" rel="noopener">Where is the default parameter in Python function</a></li><li><a href="http://effbot.org/zone/default-values.htm" target="_blank" rel="noopener">Default Parameter Values in Python</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 对函数默认参数的处理&lt;/p&gt;
&lt;p&gt;一个以可变对象为默认参数的函数:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;lang-Python&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cla
      
    
    </summary>
    
    
      <category term="Python" scheme="https://lazzzis.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>初看 CPython</title>
    <link href="https://lazzzis.moe/2017/01/04/a-glance-at-cpython/"/>
    <id>https://lazzzis.moe/2017/01/04/a-glance-at-cpython/</id>
    <published>2017-01-05T01:24:13.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-CPython"><a href="#什么是-CPython" class="headerlink" title="什么是 CPython"></a>什么是 CPython</h1><p>简单的说, <code>CPython</code> 是 Python 解释器的一个实现。换句话说，Python 解释器是由 C 写的，然后由 GCC 之类的编译器编译而成的可执行文件。除了 CPython，还有 <a href="http://pypy.org/" target="_blank" rel="noopener">PyPy</a>(用 Python 实现的 Python 解释器)，<a href="http://www.skulpt.org/" target="_blank" rel="noopener">Skulpt</a>(用 JavaScript 实现的 Python 解释器) 等等。如果你不知道你用的是哪一个，那么你一定用的就是 CPython。因为 CPython 是 Python 官方的解释器实现，其它均属于第三方实现。</p><h1 id="从源码到运行"><a href="#从源码到运行" class="headerlink" title="从源码到运行"></a>从源码到运行</h1><p>对于从 Python 源码到解释器执行它们的这个过程，我把它分为两大步 —— 编译(Compiling) 与 解释(Interpreting)。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>尽管 Python 一门典型的解释型语言 —— 与编译型语言(C, C++) 相对，但 Python 的运行确实涉及到了编译的部分。</p><p>编译在这里的主要功能是将源代码转换为字节码，包括编译了原理中两个关键步骤，词法分析与语法分析，即 lexing, parsing, 也包含了语法检查，即 <code>SyntaxError</code> 可能在这个过程中抛出。</p><p>而由 Python 编译而来的字节码似于如下:</p><pre><code>  1           0 LOAD_NAME                0 (print)              2 LOAD_CONST               0 (&#39;hello world&#39;)              4 CALL_FUNCTION            1              6 POP_TOP              8 LOAD_CONST               1 (None)             10 RETURN_VALUE</code></pre><p>关于字节码的内容，后面将进一步讨论</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>在这一步，Python 解释器对编译生成的字节码进行解释。且在实际过程中，编译所做的只占很少一部分，也就是说：解释的部分远大于编译的部分 —— 这也是为什么 Python 仍被成为解释型语言的重要原因之一。</p><p>因为 Python 解释器对字节码而非源码进行解释，因此 Python 解释器也会被称为 Python 虚拟机(Python Virtual Machine / PVM)。特别需要指出，尽管 Python 虚拟机与 Java 虚拟机都被称为虚拟机，但两者内部之间仍有较大差别(可以参考<a href="https://www.zhihu.com/question/23727114" target="_blank" rel="noopener">link</a>)。</p><h2 id="字节码的意义"><a href="#字节码的意义" class="headerlink" title="字节码的意义"></a>字节码的意义</h2><p><strong>为什么不直接解释源码？</strong><br>实际上，直接解释源码在理论上当然是可行的。但这样做也有一些缺点。<br>举个例子:</p><pre><code>def test(x, y):    if x &lt; y:        return 1    elif x == y:        return 2    return 3</code></pre><p>如果直接解释源码，那么你每次执行 test 函数都要对函数体重新分析，也就要依次分析出 <code>if</code> 语块，<code>if</code> 条件部分。等结构分析好了，之后，才能对 x, y 取值进行比较。</p><p>但事实上，代码一旦写好，结构不会再变，会变的只是变量的取值。那么可以先对其编译，编译好后再解释就不需要每次重新分析结构，而是可以直接就对 x, y 进行取值比较。从这个角度讲，编译成字节码提高了解释器的效率。</p><p>其次，字节码的存在类似于汇编的存在。汇编介于 C 语言与硬件之间，作为抽象的中间层用于降低开发的复杂度。Python 中的字节码也是如此。</p><h1 id="字节码指令集"><a href="#字节码指令集" class="headerlink" title="字节码指令集"></a>字节码指令集</h1><h2 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h2><p>Python 提高 <code>dis</code> 模块供用户查看由 Python 源码编译而成的字节码。</p><p>假设下列代码是 <code>test.py</code> 中的全部内容:</p>    <pre><code class="lang-python"><span class="hljs-attr">x</span> = <span class="hljs-number">1</span><span class="hljs-attr">y</span> = <span class="hljs-number">2</span><span class="hljs-attr">z</span> = x + y</code></pre><p>在终端中输入</p>    <pre><code class="lang-bash">python -<span class="hljs-keyword">m</span> <span class="hljs-keyword">dis</span> <span class="hljs-keyword">test</span>.py</code></pre><p>可以看到输出的字节码:</p><pre><code>  1           0 LOAD_CONST               0 (1)              3 STORE_NAME               0 (x)  2           6 LOAD_CONST               1 (2)              9 STORE_NAME               1 (y)  3          12 LOAD_NAME                0 (x)             15 LOAD_NAME                1 (y)             18 BINARY_ADD             19 STORE_NAME               2 (z)             22 LOAD_CONST               2 (None)             25 RETURN_VALUE</code></pre><p>其中每一列代表的含义为:</p><pre><code>行号            字节码偏移量     字节码指令        指令参数          对于参数的相关说明   1             0            LOAD_CONST        0               (1)</code></pre><h2 id="解释字节码"><a href="#解释字节码" class="headerlink" title="解释字节码"></a>解释字节码</h2><p>Python 解释器对字节码指令进行解释，同时对 <strong>栈</strong> (Stack)进行操作 —- Python 虚拟机属于 <strong>栈机器</strong> (Stack machine)。值的存取都是基于栈来实现的。类似下图:<br><img src="https://markfaction.files.wordpress.com/2012/07/stackadd.png" alt="7 + 20 的实现过程: 将读到的7 与 20存放与栈中，然后取出相加, 并将结果放入栈中"><span class="image-caption">7 + 20 的实现过程: 将读到的7 与 20存放与栈中，然后取出相加, 并将结果放入栈中</span></p><p><strong>栈机器</strong> 优于 <strong>寄存器机器</strong>(Register Virtual Machine) 的一个地方是不需要对地址的存取，数据的读取通过 POP 和 PUSH 的到，而非通过一个寄存器地址，操作上相对简单。</p><h3 id="字节码指令集有哪些"><a href="#字节码指令集有哪些" class="headerlink" title="字节码指令集有哪些"></a>字节码指令集有哪些</h3><p>所有的指令码可以在这个网页中看到: <a href="https://hg.python.org/cpython/file/v2.7.8/Include/opcode.h" target="_blank" rel="noopener">https://hg.python.org/cpython/file/v2.7.8/Include/opcode.h</a>。这里以网上资料比较多的 2.7.8 为例。从 0 – 147 共148个指令，每个指令都对应特定的功能。任何 Python 源码编译后形成的字节码都可以在这其中找到。</p><h3 id="字节码从哪里被执行"><a href="#字节码从哪里被执行" class="headerlink" title="字节码从哪里被执行"></a>字节码从哪里被执行</h3><p>仍以 2.7.8 为例，查看 CPython 工程的 Python/ceval.c 文件: <a href="https://hg.python.org/cpython/file/v2.7.8/Python/ceval.c" target="_blank" rel="noopener">https://hg.python.org/cpython/file/v2.7.8/Python/ceval.c</a>。<br>第 964 行处有一个 <code>for (;;)</code> 语句块，负责不断读入每一条指令并执行。</p><p>继续往下看，第 1112 行有一个“庞大”的 <code>switch</code> 语块。负责检查每一条指令具体是哪一条指令，然后采取对应的操作。</p><p>以 1148 行的 <code>POP_TOP</code> 为例:</p>    <pre><code class="lang-c">case POP_TOP:    v = POP()<span class="hljs-comment">;</span>    Py_DECREF(v)<span class="hljs-comment">;</span>    goto fast_next_opcode<span class="hljs-comment">;</span></code></pre><p>对应的操作可描述为: 取并弹出栈顶的数据，对这个数据的计数器减一，执行下一条指令。</p><p>CPython 便是以此循环，直到因为用户终止等原因才停止运行。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>目前这是一篇极其浅显的对 CPython 的描述。我最近正在学习和研究 CPython 的源码。如果有新的理解，我会继续更新。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://youtu.be/HVUTjQzESeo" target="_blank" rel="noopener">Allison Kaptur - Bytes in the Machine: Inside the CPython interpreter - PyCon 2015</a></li><li><a href="https://youtu.be/LhadeL7_EIU?list=PLzV58Zm8FuBL6OAv1Yu6AwXZrnsFbbR0S" target="_blank" rel="noopener">CPython internals - Interpreter and source code overview</a></li><li><a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/" target="_blank" rel="noopener">Stack based vs Register based Virtual Machine Architecture, and the Dalvik VM</a></li><li><a href="http://stackoverflow.com/questions/441824/java-virtual-machine-vs-python-interpreter-parlance" target="_blank" rel="noopener">Java “Virtual Machine” vs. Python “Interpreter” parlance?</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-CPython&quot;&gt;&lt;a href=&quot;#什么是-CPython&quot; class=&quot;headerlink&quot; title=&quot;什么是 CPython&quot;&gt;&lt;/a&gt;什么是 CPython&lt;/h1&gt;&lt;p&gt;简单的说, &lt;code&gt;CPython&lt;/code&gt; 是 Pytho
      
    
    </summary>
    
    
      <category term="Python" scheme="https://lazzzis.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>2016 -&gt; 2017</title>
    <link href="https://lazzzis.moe/2016/12/20/the-end-of-2016/"/>
    <id>https://lazzzis.moe/2016/12/20/the-end-of-2016/</id>
    <published>2016-12-21T02:12:15.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>（叹气）又是一年。</p><h1 id="时间花在哪里了？"><a href="#时间花在哪里了？" class="headerlink" title="时间花在哪里了？"></a>时间花在哪里了？</h1><p>这是我从大三到大四的一年，也是从课多到课少的一年。所以自由安排的时间相对多了很多。</p><p>上半年的学期少部分时间花在课程上，大约一星期上 3 次课左右。</p><p>下半年的学期除了一个时长 3 周的由学校强制学生参加的生产实习外，其余时间为自由时间。</p><p>大部分时间花在了准备 GRE、TOEFL 考试，以及学校的申请上了。这个时间段从 3 月持续到了 12 月。</p><p>花在代码上的时间少了很多。因为准备语言考试和学习代码这两件事，发生了冲突，所以我不得不大大压缩了花在计算机知识学习上的时间，包括暑假里的两个月里我用在代码上的时间可能不超过几天。大概从 11 月开始，我才渐渐将时间放回到计算机知识的学习上。</p><h1 id="我做了什么？"><a href="#我做了什么？" class="headerlink" title="我做了什么？"></a>我做了什么？</h1><p>记录了对我印象比较深或对我比较有意义的事件:</p><ul><li>购买了 MacBook Pro(Retina)</li><li>考了二次 GRE 和 三次 TOEFL</li><li>完成并发布了一个 hexo 的主题</li><li>目前已学习了 <em>Stucture and Interpretation of Computer Program</em> 的约 70%</li><li>目前已完成了美国研究生院共计 11 个项目的申请</li></ul><p><img src="https://s24.postimg.org/utgjkq5xh/IMG_0840.jpg" alt="购买的 MacBook Pro(Retina)"><span class="image-caption">购买的 MacBook Pro(Retina)</span></p><h1 id="我后悔什么？"><a href="#我后悔什么？" class="headerlink" title="我后悔什么？"></a>我后悔什么？</h1><p>尽管人生没有后悔药，但前车之鉴 后事之师，希望我自己不会在下一年也后同样的悔:</p><ul><li>后悔我自己在第三次考 TOEFL 时没有稳住情绪</li><li>后悔对我曾经喜欢过的人说了难听的话</li><li>后悔错过了参加在杭州的举办的 hackathon</li><li>后悔在这一年中没有参加任何一次漫展</li></ul><h1 id="我选择什么"><a href="#我选择什么" class="headerlink" title="我选择什么?"></a>我选择什么?</h1><h2 id="我选择放弃考研"><a href="#我选择放弃考研" class="headerlink" title="我选择放弃考研"></a>我选择放弃考研</h2><p>这是我在之前一直没有想到的，因为当我还是大一大二时，每当有人问我未来的出路，我总是会毫不犹豫的回答：我要考研。</p><p>但直到大三，我才考虑我之前为什么会这么认为，我想到了三个原因：</p><ol><li>我所在的学院是学校的荣誉学院，大部分人都很爱学习，然后在加上历来这个学院就以颇高的考研率著称，辅导员等人又重复此事实，暗示着同学们应该去考研。因此我受到了一定影响，认为我自己也应考研。</li><li>在大一大二一方面认识到工作并不一定是自由的，另一方面认识到自己能力上的不足，需要更进一步的学习，所以我至少放弃了毕业后工作。</li><li>我压根就没考虑过除了考研和工作之后的选择！！！这是重点，在进入大学后，我无意识地假设了自己只有这两个选择，因此在排除工作后，自然而然地以为应该选择考研。</li></ol><h2 id="我选择申请美国的研究生院"><a href="#我选择申请美国的研究生院" class="headerlink" title="我选择申请美国的研究生院"></a>我选择申请美国的研究生院</h2><p>这个决定也不是凭空得来的，包括了外因的推动:</p><ol><li>自从科学上网后，我在互联网上更直接地了解到了外面的世界，这其中就包括了教育。我直接或间接地接触到了留学生，也了解到了在外面读书的好处，因此开始思考我自己在这方面的可行性。</li><li>我亲戚中这几年也有人出国，同时父母虽然有点担忧，但也不完全反对，因此我算是在家庭和亲戚边得到了一定的支持。</li><li>周围的人也有选择走这条路，顿时觉得自己不是一个人在战斗。</li></ol><h1 id="我还要做什么"><a href="#我还要做什么" class="headerlink" title="我还要做什么"></a>我还要做什么</h1><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><strong>假如哪天我放弃了学习，那要么是我死了，要么就是我颓废得无药可救了</strong></p><p>英语和计算机知识就不用说了，这是我赖以生存的必备之物，必须坚持学习。</p><p>我还希望我能学习乐理知识。我喜欢音乐，因此我也想试着去了解它。同时，我最近迷上了<code>电子管风琴</code>（又称<code>双琴键电子琴</code>），希望我将来能在闲暇之余自由地在电子管风琴上弹奏自己的曲子。</p><h2 id="了解现实的世界"><a href="#了解现实的世界" class="headerlink" title="了解现实的世界"></a>了解现实的世界</h2><p>是的，我一直觉得我还是很宅。我的身体素质很一般，也只是刚刚能过体侧的水平而已，说不上强壮。我也渐渐感觉到体力不足带给我的麻烦。在今年最后一个月，我在同伴的鼓励下办了张健身卡，现在每天都会去。希望我能坚持下去，让自己拥有一个更强壮的身体。</p><p>另外，我对这个社会了解得太少，至少是对中国社会了解地太少。毕竟我在未来总归是要在社会上打拼的，我还是希望能多看看这个社会，了解这个社会的光明与黑暗。</p><h2 id="了解未来"><a href="#了解未来" class="headerlink" title="了解未来"></a>了解未来</h2><p><strong>毕业前的一段时间是迷茫的时期</strong></p><p>尽管我已经初步规划了未来一两年的安排，但事实是我该如何看待更久远的安排。未来实在是有太多的不确定因素，我看不清我现在的选择是不是最好的选择，我真得要用时间来证明我的选择么？</p><p><img src="https://s24.postimg.org/snocz2spx/Screen_Shot_2016_12_15_at_23_16_49.png" alt="《蒲公英之路》：永不会再踌躇"><span class="image-caption">《蒲公英之路》：永不会再踌躇</span></p><h1 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h1><p>如果满分是 5 分的话，我会给这一年的自己打 2.5 分。原因是相比以往，这一年的自己确实很一般：普通地学习，普通地考试，普通地敲代码。虽然做地不算差，但也绝对不算优秀。</p><hr><p><img src="https://s23.postimg.org/rvpndu597/15447116_p0.jpg" alt="Merry X&#39;mas (Pixiv ID: 15447116)"><span class="image-caption">Merry X&#39;mas (Pixiv ID: 15447116)</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（叹气）又是一年。&lt;/p&gt;
&lt;h1 id=&quot;时间花在哪里了？&quot;&gt;&lt;a href=&quot;#时间花在哪里了？&quot; class=&quot;headerlink&quot; title=&quot;时间花在哪里了？&quot;&gt;&lt;/a&gt;时间花在哪里了？&lt;/h1&gt;&lt;p&gt;这是我从大三到大四的一年，也是从课多到课少的一年。所以自由
      
    
    </summary>
    
      <category term="kny" scheme="https://lazzzis.moe/categories/kny/"/>
    
    
  </entry>
  
  <entry>
    <title>延迟计算: 关于 Python 的 yield</title>
    <link href="https://lazzzis.moe/2016/12/12/python-yield-and-delay/"/>
    <id>https://lazzzis.moe/2016/12/12/python-yield-and-delay/</id>
    <published>2016-12-13T02:07:06.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 SICP 第 3 章中，有一段部分内容是以 stream 为核心而展开的。而 stream 的特点就是 lazy evaluation / delayed evaluation （惰性求值 / 延迟计算）。在接触 stream 之时，我便立即联想到 Python 具有类似的功能 — <code>yield</code>。</p><h1 id="yield-的意义"><a href="#yield-的意义" class="headerlink" title="yield 的意义"></a>yield 的意义</h1><p>使用 yield 的目的是为了生成器，而使用生成器的一个特点是每次只向你返回一个结果。基于这个特点，生成器可以产生的结果数量甚至可以是无限的。因此，生成器在用于表示一些 <code>list</code> 不便或无法表示的超多元素的集合时将表现出很好的便捷性。</p><p>例如:</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [68]: def fib():   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     former, latter = 0, 1   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     yield former   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     yield latter   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         former, latter = latter, latter + former   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         yield latter<span class="hljs-keyword">In</span> [69]: select = lambda x :x <span class="hljs-keyword">and</span> x % 1377 == 0<span class="hljs-keyword">In</span> [70]: <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(fib()):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-keyword">if</span> select(item):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         <span class="hljs-builtin-name">print</span>(i, item)   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         break</code></pre><p>在这里，我先定义了一个生成器函数 fib，用于生成 fibonacci 数列，以及另一个普通函数 select，用于筛选出能被 1377 整除的数。接着用一个循环找出第一个满足 select 的条件的数。在这里，使用生成器的好处是你不需要实现估计需要计算多少个 fibonacci 数列中的元素。因为 fib() 可以产生第无穷个 fibonacci 数列中的元素，加入你换成一个 <code>list</code>：</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [70]: <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(fib_lst):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-keyword">if</span> select(item):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         <span class="hljs-builtin-name">print</span>(i, item)   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         break</code></pre><p>这里就有一个明显的顾虑：fib_lst 中应该放多少个元素？放 100 个够不够？1000 个呢？10000 个呢？</p><p>假使你运气好，发现对于例子中 select 函数， 1000 个够了，但如果更改 select 为 <code>lambda x: x and x % 3119 == 0</code>。那么 1000 个还会够么。可能需要 10000 个。同时，你每次生成 10000 个甚至 1000000 个元素的列表，那么生成和保存一个如此大的列表在时间上和空间上会使巨大的浪费。而相比于此，生成器没有保存所有元素，因此至少在空间上有极大的便利。</p><h2 id="Q：不用生成器，不也有办法达到类似的效果么？"><a href="#Q：不用生成器，不也有办法达到类似的效果么？" class="headerlink" title="Q：不用生成器，不也有办法达到类似的效果么？"></a>Q：不用生成器，不也有办法达到类似的效果么？</h2><p>或许有人会举出这么一个反例，既然 fib() 函数产生的生成器只是每次临时计算而已，那不用列表或生成器不也有办法可以很方便么？例如:</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [63]: former, latter = 0, 1<span class="hljs-keyword">In</span> [64]: i = 2<span class="hljs-keyword">In</span> [65]: <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     former, latter = latter, former + latter   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-keyword">if</span> select(latter):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         <span class="hljs-builtin-name">print</span>(i, latter)   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         break   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     i += 1</code></pre><p>虽然这个方法也可以，但是仔细想想，这个方法的可读性和可移植性说不上很好。一个原因是在进行 select 的代码中糅合了 fibonacci 数列元素计算的过程，使得逻辑上分离的两个部分连在了一起。另一个原因是，生成器将 fibonacci 数列的元素进行了封装，那么在其他模块中也只需要用 fib() 即可调用；而在这个方法中，每一次计算 fibonacci 数列都需要重新写一遍计算的代码，欠缺方便。</p><h2 id="写法优化"><a href="#写法优化" class="headerlink" title="写法优化"></a>写法优化</h2><p>在上例中，我用一个简单的循环求得了第一个满足要求的元素。而在 Python 中，大多简单的循环又可以写成类似列表表达式的方式，而上一个例子也是如此。</p>    <pre><code class="lang-python">In [<span class="hljs-number">74</span>]: next((<span class="hljs-selector-tag">i</span>, item) <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>, item <span class="hljs-keyword">in</span> enumerate(fib()) <span class="hljs-keyword">if</span> select(item))</code></pre><p>在这里，<code>(i, item) for i, item in enumerate(fib()) if select(item)</code> 本身代表了一个生成器表达式</p><pre><code>In [77]: ((i, item) for i, item in enumerate(fib()) if select(item))Out[77]: &lt;generator object &lt;genexpr&gt; at 0x104674258&gt;In [78]: gen = ((i, item) for i, item in enumerate(fib()) if select(item))In [79]: next(gen)Out[79]:(1316, 47670484598039529967308137755285220283067857159635666308572483292852087741971817495430736032322993914141991666526048221816855193212853932963317951773586445466676607895893764927922577383975888691399916203755485478472365658305444586740978034474331219811230599774368887776557837)In [80]: next(gen)Out[80]:(2632, 5081408804827217679483690811505190320468896152614650981083661467793773636093281628433780640132913496539149358258875736128851767346736337537150191351612842042674073125589815465376413058371692145091298387648676549040287922078680500401041910184918357118604215905739580720823641807065276860800035024575275858699179043965222324466320661415297713837965844699076750589037980732572303226178214876864049241381018710405651898072419680038625628403496847878874630005198585018290768191523976457263007140359513843497547268641482458809531359561789398938836874997259)</code></pre><p>如代码所示，这个表达式可以用于一直求下一个满足要求的数子，也可以认为是求第无限个满足要求的数字。这样的写法也与上面的例子的类似的道理，要用的时候再计算，要多少算多少。避免一次性算太多而带来的在时间上的延迟和内存上的紧张。</p><h1 id="yield-的暂停"><a href="#yield-的暂停" class="headerlink" title="yield 的暂停"></a>yield 的暂停</h1><p>尽管在 yield 的帮助下可以产生近似无限长的列表，但这也并不是说生成器可以一直下去: 在有些情况下，我们还是希望 yield 能在某个条件下停下。而如果在生成器函数中使用了 <code>return</code>，那么 <code>return</code> 即意味这暂停。</p><p>例如，我们在每次做一次数学测试，一直生成随机数，直至满足某个条件为止。</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [81]: def random_test(select, start, end):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         t = random.randint(start, end)   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         <span class="hljs-keyword">if</span> select(t):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:             return   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         <span class="hljs-keyword">else</span>:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:             yield t<span class="hljs-keyword">In</span> [82]: r = random_test(lambda x : x &lt; 100, 0, 1000)<span class="hljs-keyword">In</span> [83]: <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> enumerate(r):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-builtin-name">print</span>(i, item)</code></pre><p>只要不满足 select 条件，这个测试也会一直进行下去，无论是进行多少次，不管是 100 次，还是 1000 次。</p><h2 id="return-的在生成器中的含义"><a href="#return-的在生成器中的含义" class="headerlink" title="return 的在生成器中的含义"></a><code>return</code> 的在生成器中的含义</h2><p><code>return</code> 在生成器中表达的含义就是”一切已经结束了，没有更有趣的元素要返回了”</p><p>基于这个含义，如果在 <code>return</code> 后跟上一个返回值的话，那么这个返回值是不会被返回的。</p>    <pre><code class="lang-python">In [<span class="hljs-number">84</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">return_test</span><span class="hljs-params">()</span></span>:   ....:     <span class="hljs-keyword">return</span> <span class="hljs-string">"Will I be returned?"</span>   ....:     <span class="hljs-keyword">yield</span> <span class="hljs-string">"I know I will never be returned"</span>In [<span class="hljs-number">85</span>]: r = return_test()In [<span class="hljs-number">86</span>]: <span class="hljs-keyword">next</span>(r)---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-<span class="hljs-number">86</span>-0b5056469c9c&gt; <span class="hljs-keyword">in</span> &lt;<span class="hljs-class"><span class="hljs-keyword">module</span>&gt;()</span>----&gt; <span class="hljs-number">1</span> <span class="hljs-keyword">next</span>(r)<span class="hljs-symbol">StopIteration:</span> Will I be returned?</code></pre><p>由此可见，执行 <code>return</code> 的时候，生成器就会停止，抛出 <code>StopIteration</code> 表示停止，不会再返回任何返回值。</p><h2 id="return-等于-StopIteration"><a href="#return-等于-StopIteration" class="headerlink" title="return 等于 StopIteration ?"></a><code>return</code> 等于 <code>StopIteration</code> ?</h2><p>既然在上例中，执行 <code>return</code> 就会抛出 <code>StopIteration</code> 异常，那么在生成器函数中，是不是就意味着，<code>StopIteration</code> 是由 <code>return</code> 抛出的呢?</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [87]: def catch_stop():   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     try:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         return   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     except:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:         yield <span class="hljs-string">"I catch it"</span><span class="hljs-keyword">In</span> [88]: c = catch_stop()<span class="hljs-keyword">In</span> [89]: next(c)---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-89-73b012f9653f&gt; <span class="hljs-keyword">in</span> &lt;module&gt;()----&gt; 1 next(c)StopIteration:</code></pre><p>由代码可见，<code>StopIteration</code> 并没有被捕获，这说明 <code>StopIteration</code> 是在另一个地方抛出的。而至于是在哪里抛出的，目前据我了解，这可能涉及到 Python 底层解释器的实现，我尚不十分了解。</p><h1 id="关于生成器函数的实现"><a href="#关于生成器函数的实现" class="headerlink" title="关于生成器函数的实现"></a>关于生成器函数的实现</h1><p>生成器函数的实现一个重要点就是它保存了每次运行时的环境信息以及下一次的起点。对于普通函数，每一次运行的起点无疑都是从函数的最开头。而对于生成器函数，除了第一次运行的起点是在函数最开头， 每一次运行的起点都是上一次运行结束的终点。</p><p>另外虽然生成器函数保存了环境信息，但这并不说它保存了环境中每个变量的值。</p>    <pre><code class="lang-python">n [105]: N = 0<span class="hljs-keyword">In</span> [106]: def test_sum():   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.:     i = 0   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.:     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.:         yield N + i   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.:         i += 1<span class="hljs-keyword">In</span> [107]: t = test_sum()<span class="hljs-keyword">In</span> [108]: next(t)Out[108]: 0<span class="hljs-keyword">In</span> [109]: next(t)Out[109]: 1<span class="hljs-keyword">In</span> [110]: N = 100<span class="hljs-keyword">In</span> [111]: next(t)Out[111]: 102</code></pre><p>由代码可见，生成器函数保存了环境变量中 <code>N</code> 的存在，但并没有在产生生成器时就将 <code>N</code> 的值定了下来，而仍是每次运行 <code>next</code> 时对其重新求值。</p><h2 id="一些猜测"><a href="#一些猜测" class="headerlink" title="一些猜测"></a>一些猜测</h2><p>联想到 SICP 中对 stream 的实现，那么 Python 可能也有类似的做法，即将一个元素包装在函数里。<br>假如不做延时计算:</p>    <pre><code class="lang-python"><span class="hljs-keyword">In</span> [<span class="hljs-number">113</span>]: [<span class="hljs-string">"how long will it be?"</span>, time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>), time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>)]Out[<span class="hljs-number">113</span>]: [<span class="hljs-string">'how long will it be?'</span>, None, None] <span class="hljs-meta"># 3 seconds</span></code></pre><p>这个输出将在 3 秒后输出，但如果讲每个元素包装在函数里:</p>    <pre><code class="lang-python">In [<span class="hljs-number">114</span>]: lst = [lambd<span class="hljs-variable">a:</span> <span class="hljs-string">"how long will it be?"</span>,lambd<span class="hljs-variable">a:</span> time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>),lambd<span class="hljs-variable">a:</span> ti   .....: <span class="hljs-keyword">me</span>.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">2</span>)]In [<span class="hljs-number">115</span>]: <span class="hljs-keyword">for</span> item in <span class="hljs-keyword">ls</span><span class="hljs-variable">t:</span>   .....:     <span class="hljs-keyword">print</span>(item())how long will it <span class="hljs-keyword">be</span>?None # <span class="hljs-number">1</span> secondNone # <span class="hljs-number">2</span> seconds</code></pre><p>通过这个方法，每个元素也是在调用是才会被求值，因此我猜测 Python 在实现上可能有类似的做法。但具体是怎么做的，这是一个我接下来需要研究的话题。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果对 <code>yield</code> 想要更多的了解，建议查看 <a href="https://www.python.org/dev/peps/pep-0255/" target="_blank" rel="noopener">PEP 255 – Simple Generators</a>, 其中更进一步的探讨了为什么要引入新的关键字 <code>yield</code>，而不是将其设置为一个内建函数，以及为什么不引入一个新的关键字代替 <code>def</code> 来更清楚地表示某个函数是生成器函数等等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.python.org/dev/peps/pep-0255/" target="_blank" rel="noopener">PEP 255 – Simple Generators</a></li><li><a href="https://swizec.com/blog/python-and-lazy-evaluation/swizec/5148" target="_blank" rel="noopener">Python and lazy evaluation</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 SICP 第 3 章中，有一段部分内容是以 stream 为核心而展开的。而 stream 的特点就是 lazy evaluation / delayed evaluation （惰性求值 / 延迟计算）。在接触 stream 之时，我便立即联想到 Python 具有类
      
    
    </summary>
    
    
      <category term="Python" scheme="https://lazzzis.moe/tags/Python/"/>
    
      <category term="SICP" scheme="https://lazzzis.moe/tags/SICP/"/>
    
  </entry>
  
  <entry>
    <title>对 SICP Chapter 2 的一些理解</title>
    <link href="https://lazzzis.moe/2016/12/03/sicp-chapter-2-summary/"/>
    <id>https://lazzzis.moe/2016/12/03/sicp-chapter-2-summary/</id>
    <published>2016-12-04T04:01:22.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>SICP 第二章的标题为 <em>“Building Abstractions with Data”</em>。与第一章标题<em>“Building Abstractions with Procedures”</em> 相比，这一章明显注重于在数据上的抽象。因此，在本章中所采用的例子中，会有多种数据类型被抽象出来，而每种数据类型又会对应着多种操作，那么随着代码量的增多，如何在不减少需求的情况下正确的对数据的抽象将直接影响开发者编码时的难度以及后期维护的成本。</p><p>在阅读和练习完 Chapter 2 之后，我想谈一下对我思维冲击比较大的几个点。</p><h1 id="Data-Directed-Programming"><a href="#Data-Directed-Programming" class="headerlink" title="Data-Directed Programming"></a>Data-Directed Programming</h1><p>在 SICP 中，DDP 出现的一个背景是：存在多种数据类型，它们需要实现相同功能的操作，但对于不同的类型，具体的实现方式有存在不同。</p><p>拿书上的例子来说，对于有理数R1, R2, 它们的值分别为 3/4, 5/6。那么对于它们，可以构造一个方法叫做 add 用于计算 R1, R2 的值，比如 <code>(add R1 R2)</code>。</p><p>同样的，如果是在同一个系统里，再增加一种类型 ———— 无理数。对于 I1，I2, 它们的值分别是 1 + 2i, 3 + 4i。同样，可以构造一个方法叫 add, 同于计算 I1，I2 的值，比如 <code>(add I1 I2)</code>。</p><p><strong>问题来了</strong>：这是在同一个系统当中，add 被定义了两次，后一次会覆盖前一次，那么在运算过无理数后再调用 add 计算 R1, R2 时，系统必然会报错。</p><p><strong>解法一</strong>: 对于支持面向对象和方法重载的语言，比如 Java, C++，这个问题根本就不是问题。写两个 add 方法，但是参数类型不同。当你调用 add 的时候，系统会根据参数的类型用于决定调用哪一个 add 方法。</p><p><strong>解法二</strong>：对于像 C 语言这种语言，还可以重新命名函数的方法，比如对于计算有理数加法的函数，可以叫做 <code>add_rational</code>；对于计算无理数加法的函数，可以叫做 <code>add_irrational</code>。但问题也很明显，如果在这个系统增加更多种需要进行加法运算的数据类型，那么对于每一种数据类型定义一种函数，而且名字还需要确保不同。假如在系统设计初期，设计者能想好这么多名字，比如 100 种，那勉强还算解决了。然而对于用户来说，这就很头疼了。如果我面对一个支持 100 种数据类型的系统，每操作一种数据类型，我就需要查查手册。如果有一个 <code>add</code> 函数能支持任意一种数据类型加法的运算，那么用户必然对这个系统的好感度必然直线上升。</p><p><strong>解法三</strong>：那就定义一个 <code>add</code> 函数，当传入两个数据时，判断一下类型，在进行相应的操作就好了。<br>伪代码如下:</p>    <pre><code class="lang-python">def add(x, y):    <span class="hljs-keyword">if</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(x) == <span class="hljs-string">"rational"</span> <span class="hljs-keyword">and</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(y) == <span class="hljs-string">"rational"</span>:        pass # 对应有理数加法的代码    <span class="hljs-keyword">elif</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(x) == <span class="hljs-string">"irrational"</span> <span class="hljs-keyword">and</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(y) == <span class="hljs-string">"irrational"</span>:        pass # 对应无理数加法的代码    <span class="hljs-keyword">elif</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(x) == <span class="hljs-string">"type-a"</span> <span class="hljs-keyword">and</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(y) == <span class="hljs-string">"type-a"</span>:        pass # 对应<span class="hljs-class"><span class="hljs-keyword">type</span>-<span class="hljs-title">a</span>加法的代码    </span>    <span class="hljs-keyword">elif</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(x) == <span class="hljs-string">"type-b"</span> <span class="hljs-keyword">and</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>(y) == <span class="hljs-string">"type-b"</span>:        pass # 对应<span class="hljs-class"><span class="hljs-keyword">type</span>-<span class="hljs-title">b</span>加法的代码</span>    <span class="hljs-keyword">elif</span> ... # 以此类推，每个<span class="hljs-keyword">elif</span> 部分对应一种数据类型的加法运算       </code></pre><p>对于开发者实现来说，这个方法还算可以，虽然不算美观。<br>记得去年我在某公司实习的时候，我所在的那个项目中还真有这样的代码。一个文件中“挂”了至少上百个 <code>else if</code>。每个实习生一旦写好一个模块，就要在这个文件上加一个对应的 <code>else if</code>。然后因为多个实习生，每个实习生的工作台上都有整个项目的文件，最后提交的时候，负责管理实习生的员工还查看每个实习生增加了几个 <code>else if</code>，然后把它们一个一个汇总到一个文件上。<br>所以很明显，这个方法勉强可以，虽然对开发来说事实上会带来一点繁琐。</p><p><strong>解法四</strong>: 在以上三种解法基础上，终于到了 DDP 登场。我认为 DDP 和解法三的一个重要区别就是，DDP 开发了一个表结构，帮助开发者分析类型并调用对应函数。同时在这时，系统还可以模块化，增加命名空间，避免设计者把过多时间花在起名字上。</p><p>DDP 中有两个重要的函数 <code>put</code>, <code>get</code>。</p>    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-title">put</span><span class="hljs-params">(&lt;操作&gt;，&lt;方法所需参数的各个类型&gt;，方法名)</span></span><span class="hljs-function"><span class="hljs-title">get</span><span class="hljs-params">(&lt;操作&gt;，&lt;方法所需参数的各个类型&gt;)</span></span></code></pre><p>先不管具体是怎么实现的，先明白功能。put 的功能是往系统的一个特殊数据结构中存储一种方法，而这个方法对应的操作是 &lt;操作&gt;，对应参数的各个类型为&lt;方法所需参数的各个类型&gt;。<br>比如:</p>    <pre><code class="lang-python">put(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"rational"</span>, <span class="hljs-string">"rational"</span>], rational-<span class="hljs-keyword">add</span><span class="bash">)</span>put(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"irrational"</span>, <span class="hljs-string">"irrational"</span>], irrational-<span class="hljs-keyword">add</span><span class="bash">)</span></code></pre><p>而 put 的目的是为了 get，这个才是关键。通过 get 就可以实现取到对应数据类性的方法。</p>    <pre><code class="lang-python"><span class="hljs-builtin-name">get</span>(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"rational"</span>, <span class="hljs-string">"rational"</span>]) # rational-<span class="hljs-builtin-name">add</span><span class="hljs-builtin-name">get</span>(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"irrational"</span>, <span class="hljs-string">"irrational"</span>]) # irrational-<span class="hljs-builtin-name">add</span></code></pre><p>这看上去似乎没什么用，但是如果在继续定义 add:</p>    <pre><code class="lang-python">def add(<span class="hljs-name">x</span>, y)    return get(<span class="hljs-string">"add"</span>, [type(<span class="hljs-name">x</span>), type(<span class="hljs-name">x</span>)])(<span class="hljs-name">x</span>, y)</code></pre><p>那么这个 add 就可以处理各种系统支持的类型了。<br>比如如果我用 add 计算有理数 R1, R2的和，那么 <code>get</code> 会返回 <code>rational-add</code> 方法计算R1， R2；如果再用 add 计算无理数 I1, I2的和，那么 <code>get</code> 会返回 <code>irrational-add</code> 方法计算I1， I2。</p><p>对于用户来说，每次计算调用的都是同一个方法 <code>add</code>，而对于系统，每次用于计算的则是不同的方法计算。那么如何解决命名空间呢？因为 put 方法已经在系统中实现，属于全局。那么put 也可以在任何地方使用，比如:</p>    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install_rational</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add</span><span class="hljs-params">(x, y)</span>:</span>        <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 处理有理数加法</span>    put(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"rational"</span>, <span class="hljs-string">"rational"</span>], _add)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install_irrational</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add</span><span class="hljs-params">(x, y)</span>:</span>        <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 处理无理数加法</span>    put(<span class="hljs-string">"add"</span>, [<span class="hljs-string">"irrational"</span>, <span class="hljs-string">"irrational"</span>], _add)</code></pre><p>这里事实上还涉及到了闭包。因为 <code>_add</code> 方法是在不同的函数中定义的，处于不同的命名空间。所以在这里，对于不同的数据类型的加法函数，可以采用同一个命名。另外，这种设计事实上也模块化了，因为当你需要用有理数时，只需执行 <code>install_rational()</code>。这样这个系统就支持有理数加法操作。</p><p>对比解法三，四可以发现，解法四更简洁化了，它开发了一个程序用于自动添加对应的方法。</p><p>因为 put 操作的作用是往表结构中存储数据，那么这个表结构可以采用类似 python 中的 dict 实现。</p><h1 id="Message-Passing"><a href="#Message-Passing" class="headerlink" title="Message Passing"></a>Message Passing</h1><p>Message Passing 是本章另一个令我感觉十分新颖的点。在我看来，Message Passing 的特点在于它将一个数据，既可以看作函数操作，又可以看作对象操作。同时它又与 Object-oriented Programming (OOP) 又有些许相似之处。</p><p>同样，以有理数的实现为例子:</p>    <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_rational</span><span class="hljs-params">(numer, denom)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(y)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span><span class="hljs-params">(y)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mul</span><span class="hljs-params">(y)</span>:</span>        <span class="hljs-keyword">return</span> make_rational(numer * y(<span class="hljs-string">"numer"</span>), denom * y(<span class="hljs-string">"denom"</span>))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(msg)</span>:</span>        <span class="hljs-keyword">if</span> msg == <span class="hljs-string">"add"</span>:            <span class="hljs-keyword">return</span> add        <span class="hljs-keyword">elif</span> msg == <span class="hljs-string">"sub"</span>:            <span class="hljs-keyword">return</span> sub        <span class="hljs-keyword">elif</span> msg == <span class="hljs-string">"mul"</span>:            <span class="hljs-keyword">return</span> mul        <span class="hljs-keyword">elif</span> msg == <span class="hljs-string">"numer"</span>:            <span class="hljs-keyword">return</span> numer        <span class="hljs-keyword">elif</span> msg == <span class="hljs-string">"denom"</span>:            <span class="hljs-keyword">return</span> denom        ...    <span class="hljs-keyword">return</span> dispatch</code></pre><p>可以看出，如果构造一个有理数对象，那么这个方法实际上返回的是 dispatch 的方法。而如果用调用 add 方法，或 获得 numer 属性，那么就要把构建出来的对象当作函数使用:</p>    <pre><code class="lang-python">x, y = make_rational(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), make_rational(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-function"><span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"add"</span>)</span><span class="hljs-params">(y)</span></span><span class="hljs-function"><span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">"numer"</span>)</span></span></code></pre><p>这里是第一个有趣的地方，在第一行中，<code>x, y</code> 被看作是对象，而在第二、三行中，<code>x, y</code> 又被看作是方法 / 函数。这么一来 对象 和 函数 的界限似乎被打破了，或者说，对象 和 函数进行了自由的转换。</p><p>第二个有趣的地方在于这与 OOP 的关系，如果在一个支持 OOP 语言编写的系统中存在 <code>Rational</code> 这个类，那么 <code>make_rational()</code> 就类似与构造函数 <code>Rational()</code>；<code>x(&quot;add&quot;)(y)</code> 就类似于 OOP 中的 <code>x.add(y)</code>；<code>x(&quot;numer&quot;)</code> 类似于 OOP 中的 <code>x.numer</code>。也就是说，在一个不支持面向对象，但支持将函数看作对象操作的语言中，Message Passing 实现了类似于 OOP 的功能。</p><p>同样的，如果要定义一个通用的 add 操作，可以用以下方法实现:</p>    <pre><code class="lang-python">def <span class="hljs-keyword">add</span><span class="bash">(x, y):</span>    return x(<span class="hljs-string">"add"</span>)(y)x, y = make_rational(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), make_rational(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">add</span><span class="bash">(x, y)</span></code></pre><p>那么用户就调用 <code>add(x, y)</code> 之时，又将 x，y 看作了对象而不是函数。倘若再增加一种无理数的数据类型，那也可以参照上文中有理数的实现方法实现，并且，如果无理数中的实现中，同样又对 “add” 的处理，那么无理数的相加也可以直接调用 <code>add(x, y)</code>。</p><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><p>除了以上两点，在书中还有更多的讨论：其中一个常见的问题就是如果如何将<code>add</code>用于其他类型的相加，比如无理数和有理数的相加，无理数和自然数的相加。书中采用的方法很巧妙，它定义了一个升级的规则，如果两个相加的数不在一个等级，那么将其中一个等级较低的进行升级。比如，<code>3 / 4</code> 与 <code>2</code> 相加，<code>2</code> 先升级，成为有理数<code>2 / 1</code>，这是可以处在同一层级（都是有理数），所以可以相加；<code>3 + 4i</code> 与 <code>2</code> 相加，<code>2</code> 先升级，成为了 <code>2 / 1</code>，但仍不在同一个层级，因此再升级，成为<code>2 / 1 + 0i</code>，这时可以相加了（注意，实数部分的 <code>3 + 2 / 1</code> 计算过程中事实上也运用了升级的规则）。</p><p>总体来说，对于以上这几点，我只是做了比较基础的一些总结。如果对这方面感兴趣，建议阅读书籍，书中还有更多的内容值得阅读和思考。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">SICP</a></li><li><a href="http://sicp.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">SICP 解题参考</a></li><li><a href="http://inst.eecs.berkeley.edu/~cs61a/su10/resources/sp11-Jordy/ddp.html" target="_blank" rel="noopener">DDP and Message Passing @ inst.eecs.berkeley.edu</a></li><li><a href="http://berkeley-cs61as.github.io/textbook/data-directed-programming.html" target="_blank" rel="noopener">Data-Directed Programming @ berkeley-cs61as</a></li><li><a href="http://berkeley-cs61as.github.io/textbook/message-passing.html" target="_blank" rel="noopener">Message Passing @ berkeley-cs61as</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SICP 第二章的标题为 &lt;em&gt;“Building Abstractions with Data”&lt;/em&gt;。与第一章标题&lt;em&gt;“Building Abstractions with Procedures”&lt;/em&gt; 相比，这一章明显注重于在数据上的抽象。因此，在本章中
      
    
    </summary>
    
    
      <category term="SICP" scheme="https://lazzzis.moe/tags/SICP/"/>
    
      <category term="Scheme" scheme="https://lazzzis.moe/tags/Scheme/"/>
    
  </entry>
  
  <entry>
    <title>创建了适用于 hexo 的一个主题 mls</title>
    <link href="https://lazzzis.moe/2016/11/10/new-blog-theme-mls/"/>
    <id>https://lazzzis.moe/2016/11/10/new-blog-theme-mls/</id>
    <published>2016-11-11T00:46:55.000Z</published>
    <updated>2017-07-30T05:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前用的主题是基于 <a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a>, 虽然这确实是一个不错的主题，使用上也没什么不便，但毕竟这是一个他人贡献的主题。我一直想试着自己做一个主题。之前也尝试在 landscape 上改，修改了一些颜色，对 CSS 做了一些简单修改，但布局没变，整体一眼还是能看出这是 landscape，并且因为我当时不熟悉 EJS 模板，对 Sass 及 CSS3 不是特别熟悉，所以有些功能的实现也完全不知道怎么做，比如一些透明效果的动画。</p><p>最近一段时间，相对以前来说稍微不忙了点，所以趁这个机会试着做一个主题了。</p><h1 id="一些教程"><a href="#一些教程" class="headerlink" title="一些教程"></a>一些教程</h1><h2 id="MarketSheet"><a href="#MarketSheet" class="headerlink" title="MarketSheet"></a>MarketSheet</h2><p><a href="http://marksheet.io/" target="_blank" rel="noopener">MarketSheet</a> 这是一个 HTML/CSS/Sass 教程的网站。我主要用它学习 CSS。相比较于其它教程，我十分推荐这个教程。</p><p>一是因为前期它不堆砌各种语法知识，所以前期比较简单，例子也比较多，比如最开始讲讲很基础简单的 color, size, 而不是上来就讲 margin, padding 等对新手来说不友好的点。如果前期语法太多，就比较容易在刚开始就犯糊涂，影响后面的学习。</p><p>二是这个教程确实讲得清楚，比如对 <code>position</code> 属性的解释，比如以前我一直对 <code>relative</code>/<code>absolute</code>/ 不清楚，不知道<code>相对</code>是什么，<code>绝对</code> 是什么，但教程直接解释了 <code>relative</code> 是相对元素原先的位置，而 <code>absolute</code> 是相对已经对位的 parent 来说的。更多的内容可以参考网站。</p><p>三是一些语法外的规则讲解，比如何时使用 class 和 id，如何在表示颜色的十六进制、rgba、hsl 的三者中抉择 等等。</p><h2 id="Sass-amp-SCSS-Tutorial-for-Beginners"><a href="#Sass-amp-SCSS-Tutorial-for-Beginners" class="headerlink" title="Sass &amp; SCSS Tutorial for Beginners"></a>Sass &amp; SCSS Tutorial for Beginners</h2><p><a href="https://www.youtube.com/watch?v=sCbXTrsl7NU&amp;list=PL6gx4Cwl9DGBxQO2r_kmxn-0UqL_Rkj0t" target="_blank" rel="noopener">Sass &amp; SCSS Tutorial for Beginners</a><br>同样的理由，刚开始就不要太麻烦，把基础牢固最重要。这个教程每节课就讲一个知识点，比如 extend 或 mixin, 而且一节课的内容不长，10 分钟左右。<br>学完之后再去转转其他教程，这时学习一些稍微高级点的知识点就会相对轻松些。</p><h2 id="CREATE-AN-HEXO-THEME"><a href="#CREATE-AN-HEXO-THEME" class="headerlink" title="CREATE AN HEXO THEME"></a>CREATE AN HEXO THEME</h2><p><a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="noopener">CREATE AN HEXO THEME</a><br>这个就是从头到尾的一个 hexo theme 教程了，包括了从简单的首页开始，一直到最后的插入评论系统。应该说跟着这个教程做下来的话，搭建 hexo 博客的基本思路已经有了。自己主要做的就是稍微调整下布局，补充补充一些 CSS，这样一个基本功能的主题已经基本完成了。</p><h1 id="一些开源框架-组件-插件"><a href="#一些开源框架-组件-插件" class="headerlink" title="一些开源框架 / 组件 / 插件"></a>一些开源框架 / 组件 / 插件</h1><h2 id="Materialize"><a href="#Materialize" class="headerlink" title="Materialize"></a>Materialize</h2><p><a href="https://github.com/Dogfalo/materialize" target="_blank" rel="noopener">Materialize</a><br>一个实现了 Material design 的前端框架。之所以使用框架，一方面是想稍微偷个懒，因为目前我对如何实现响应式布局不是很了解，用现成的框架能降低难度，其次是我对 Material design 还是有点喜欢的，所以选择了这个框架。</p><p>不过，并没有使用框架中太多部分，主要是导航栏，icons，以及内置的 grid 布局。</p><h2 id="jquery-backstretch"><a href="#jquery-backstretch" class="headerlink" title="jquery-backstretch"></a>jquery-backstretch</h2><p><a href="https://github.com/srobbin/jquery-backstretch" target="_blank" rel="noopener">jquery-backstretch</a><br>使用这个插件主要是两个理由，一是可以延迟加载背景图片，也就是说避免图片加载太慢而导致其它内容加载延迟太多。通过延迟加载，可以在其它加载了差不多了后再加载图片。二是在写主题时发现 chrome 的一个 bug，在我写了 <code>body {background-attachment: fixed}</code> 后，chrome 并没有照做，通过审查元素可以发现，chrome 自动在 body 上加了一个 <code>style=&quot;background-attachment: scroll&quot;</code>。虽然 google 了很多方法，但效果都不大理想。后来放弃了刚开始在 body 元素上设置背景的想法，而通过在其它元素上设置以间接达到目的。</p><h2 id="highlight-js"><a href="#highlight-js" class="headerlink" title="highlight.js"></a>highlight.js</h2><p><a href="https://github.com/isagalaev/highlight.js" target="_blank" rel="noopener">highlight.js</a><br>这个用于对代码的高亮。原先 hexo 的代码渲染很奇怪，它把代码部分渲染成了表格，而且用于代码高亮部分的主题的样式表我也看不懂。所以我这一次又偷懒了，关闭了默认的代码高亮（关闭方法不难，可参考 <a href="https://liuzhichao.com/2016/hexo-use-prettify-to-highlight-code.html" target="_blank" rel="noopener">link</a>），使用了 highlight.js，而且这个组件提供了很多主题。我现在用的主题是 “Atom One Light”。这是一个我同样在 atom 上设置的亮色主题。</p><h2 id="highlightjs-line-numbers-js"><a href="#highlightjs-line-numbers-js" class="headerlink" title="highlightjs-line-numbers.js"></a>highlightjs-line-numbers.js</h2><p><a href="https://github.com/wcoder/highlightjs-line-numbers.js" target="_blank" rel="noopener">highlightjs-line-numbers.js</a><br>因为希望给代码显示行数，所以找到了这个插件，使用也很方便。</p><h2 id="hexo-image-caption"><a href="#hexo-image-caption" class="headerlink" title="hexo-image-caption"></a>hexo-image-caption</h2><p><a href="https://github.com/wayou/hexo-image-caption" target="_blank" rel="noopener">hexo-image-caption</a><br>在原先的 landscape 里，图片下方可以显示一段文字，这段文字就是在写 markdown 时插入图片时的说明文字。为了实现这个功能，我再次偷懒，搜到了这个插件。使用后的效果就是这样: <img src="http://placehold.it/350x150" alt="这是一张 350 * 150 的图片？"><span class="image-caption">这是一张 350 * 150 的图片？</span></p><h2 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a>fontawesome</h2><p>一开始不知道一些图标是如何显示在 blog 上的，后来我知道了 <a href="http://fontawesome.io/" target="_blank" rel="noopener">fontawesome</a>。使用没什么难度，效果可以参考现在页面 footer 上的那几个图标的样子，唯一我个人不满意的地方就在于没有网易云音乐的图标，所以用了一个其它图标代替。</p><h2 id="share-js"><a href="#share-js" class="headerlink" title="share.js"></a>share.js</h2><p><a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">share.js</a> 用于分享功能。这个功能原本不在计划之内，但在逛 GitHub 时偶然看到了，而且确实简单好用，于是加上了。目前我选择了四个社交应用的分享，显示在文章之后。</p><h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><p>这次主题的创建比我想象的简单了很多，一个很重要的原因就在于 GitHub 上丰富的资源，包括各种教程，为我节省了很多精力和时间，<del>允许我偷懒</del>。我必须要向这些资源们的作者表示感谢。</p><p>同时我不得不说，有些 blog 也带给了我一些灵感。jquery-backstretch 是我在看了<a href="xcoder.in">艾克斯の編碼者</a>的 blog 才知道的，另外也从这个 blog 的主题上也知道了如何单独建立 Categories 和 Tags 的页面。同时， 网页下滑后导航栏透明的设计是在看了 <a href="http://wattlebird.github.io/" target="_blank" rel="noopener">Dedication</a> 之后才想到要做。而在 footer 上加图标的方法则是参考了 <a href="http://morris821028.github.io/" target="_blank" rel="noopener">Morris’ Blog</a> 的设计。</p><h1 id="关于-mls"><a href="#关于-mls" class="headerlink" title="关于 mls"></a>关于 mls</h1><p>主题的代码这几天我会在 GitHub 上开源。</p><p>至于为什么叫 mls，其实很简单，m 代表了 materialize 框架；ls 代表 landscape，代表了上一个主题，因为最初的想法不是从头写，而是想在 landscape 上修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前用的主题是基于 &lt;a href=&quot;https://github.com/hexojs/hexo-theme-landscape&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;landscape&lt;/a&gt;, 虽然这确实是一个不错的主题，使用上也没什么不便，
      
    
    </summary>
    
      <category term="Front-end" scheme="https://lazzzis.moe/categories/Front-end/"/>
    
    
      <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
      <category term="CSS" scheme="https://lazzzis.moe/tags/CSS/"/>
    
      <category term="Sass" scheme="https://lazzzis.moe/tags/Sass/"/>
    
  </entry>
  
</feed>
