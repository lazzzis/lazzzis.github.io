<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lazzzis</title>
  
  
  <link href="https://lazzzis.moe/atom.xml" rel="self"/>
  
  <link href="https://lazzzis.moe/"/>
  <updated>2021-01-18T02:15:25.495Z</updated>
  <id>https://lazzzis.moe/</id>
  
  <author>
    <name>lazzzis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>认识社会心理学 ——《Not by Chance Alone》与《The Social Animal》小记</title>
    <link href="https://lazzzis.moe/post/the-social-animal/"/>
    <id>https://lazzzis.moe/post/the-social-animal/</id>
    <published>2021-01-17T23:46:21.000Z</published>
    <updated>2021-01-18T02:15:25.495Z</updated>
    
    <content type="html"><![CDATA[<p>《Not by Chance Alone》(中译：<a href="https://book.douban.com/subject/19949881/">绝非偶然</a>)以及《The Social Animal》(中译：<a href="https://book.douban.com/subject/2328458/">社会性动物</a>) 均为社会心理学家 Elliot Aronson (埃利奥特·阿伦森) 的著作。前者，为 Aronson 的自传；而后者，则是由 Aronson 编写的社会心理学入门教材。</p><a id="more"></a><p>阅读的动机是偶然在豆瓣上看到了《绝非偶然》这本书，读完后就又对《社会性动物》产生了兴趣，所以一口气就把两本读完了。我确实以前也没读过心理学相关的书籍，凭着好奇心翻开书籍，被里面提到的有趣的例子和作者深入浅出的讲述方式而深深吸引。</p><h1 id="对心理学的改观"><a href="#对心理学的改观" class="headerlink" title="对心理学的改观"></a>对心理学的改观</h1><p>现代网络已经逐渐揭开了心理学的面纱，像电视剧里 “读心” 这样的理解已经逐渐被抛弃。取而代之的，是更接近科学的看法，尽管这其中仍有一些不充分的认知。</p><p>最初，心理学之于我，有点 “哲学” 的意味。我最早接触的心理学文章，颇有一种思考人生的意图，例如，在试图解读人为什么孤独的文章里会有作者对人生意义的解读，从而帮助读者理解孤独的成因和解决方法。但后来了解到，心理学和物理学，化学一样，依托于包含了假设，实验，和分析等在内的科学方法论。因此，现在说起心理学，有些人会优先想到一个人被连接了仪器测试脑电波的场景。这其实可以理解，因为有些心理问题确实可以归结为病理问题，这方面的研究，更多被称为精神病学或神经科学。精神病学更多是在生物层面分析，医学层面分析，必要时辅以药物。</p><p>而《The Social Animal》主要介绍的，是心理学的一个分支 —— 社会心理学，一个研究社会坏境对人行为影响的心理学。<strong>科学实验</strong>在社会心理学里扮演着不可或缺的角色。在这本书中出现的所有理论和结论，除了现实世界的观察以外，更多是通过实验得出的。而这个做实验的基本方法论，和医学里常说的 “双盲实验” 是非常相似的 —— 将志愿者尽可能随机分配为控制组和实验组，这两组的任何条件，除了要实验的要素，其它的任何条件都是相同的。但这里有一点和药物测试的实验截然不同，药物测试里，患者虽然不知道自己吃的是安慰剂还是待测试药物，但仍然知道实验的目的是测试药物。而在社会心理学的实验里，却不会这么做，因为如果提前告诉了测试者实验的目的，那么测试者会有意纠正自己接下来的行为，使其行为不自然，比如如果告诉测试者接下来的实验将测试人是否会服从权威，那么测试者接下来很可能会特别注意这点，从而避免出现服从权威的行为。为了让测试者更接近自然状态，实验设计者通常会设计一个封面故事（Cover Story）。以著名的 <a href="https://www.wikiwand.com/zh-hans/%E7%B1%B3%E7%88%BE%E6%A0%BC%E5%80%AB%E5%AF%A6%E9%A9%97">“米尔格拉姆实验”(Milgram experiment)</a> 为例，实验设计者为了掩盖真正的意图，在招募志愿者时的说辞是要测试 “记忆力”。</p><p>这么做的目的，就是为了增强其科学性。这里的科学性，也包含了可重复性。仍以刚才提到的米尔格拉姆实验为例，后来的实验者多次重复了这个实验从而验证了原实验的结论，同时也改进了一些实验条件，比如，实验中的指导者是以电话方式发出指令，这种情景下的被测试者有多少不一样的反应。因为可重复性，后来的实验者，可以发现更多的问题，也可以指出原实验中得出的结论有更严格的限定条件。</p><p>实验是如此的重要，因此在总共 9 篇章节的《社会性动物》中，作者用单独的一章来解释实验的重要性，如何设计一个合理的实验等。同时，作者也对目前主流社会对社会心理学中的实验的批评做了回应，包括实验中的欺骗是否道德等。类似地，在另一本广泛应用的社会心理学教材<a href="https://book.douban.com/subject/26701760/">《社会心理学》(Social Psychology)</a> 里，也在开篇就详细阐述了实验的方法及重要性。这部分的内容，很大程度上涉及到了辩证性思维的思想，比如，相关性不代表因果性，第三者潜在因素的存在对实验的影响。了解这些思想，也有助于人们面对当今网络上各种流行的心理学段子时，能有更严谨的态度和辩证的思维去看待。也难怪，作者在提到网络上一些流行的心理学段子时也说，“我们应该先问问，‘这是否可以重现?’”.</p><blockquote><p>Today, unfortunately, there have been many pop social psychology “findings” that get public attention and then don’t pass the test of replication. But that does not mean that the basic methods of social-psychological experimentation are at fault — it means that science is moving along as it should, correcting its mistakes and advancing the findings that hold up. <strong>It also means, however, that the public should be wary of sensational, improbable, or simplistic findings and ask, “But have they been replicated?”</strong></p></blockquote><h1 id="作者成为社会心理学家的契机"><a href="#作者成为社会心理学家的契机" class="headerlink" title="作者成为社会心理学家的契机"></a>作者成为社会心理学家的契机</h1><p>作者最初是并不打算选择心理学的，因为经济问题一直困扰着他。作者的父亲在经济大萧条后失去了经营的店铺，经济变得困难，甚至作者本来也没准备读大学。是在他哥哥的劝说下，加上他哥哥就读的大学 <a href="https://www.wikiwand.com/en/Brandeis_University">Brandeis University</a> 愿意为作者提供一年学费和一份兼职才同意进入大学。但可惜的是，在大二那年，学校又突然因为资金不足而不能继续为他提供经济资助，作者只能打工挣学费，却仍旧没有足够的钱用来租房。所以，那一段时间，作者基本是睡在室外，比如树林里，没有锁的汽车的后座里。</p><p>在这样的背景下，他其实是想选择来钱更快的经济学专业的，直到偶然一次机会上了一节心理学导论课。这节课本来是作者在和一位女同学约会后，想一起陪着上课的，但这节课是由提出了著名的 “马斯洛需求理论” 的<a href="https://www.wikiwand.com/zh/%E4%BA%9A%E4%BC%AF%E6%8B%89%E7%BD%95%C2%B7%E9%A9%AC%E6%96%AF%E6%B4%9B">马斯洛</a>教授的课。这节课中提到的关于偏见的内容激发了他对童年的回忆，也触发了他更多的思考，以至于他忙于笔记而忘记了走进这间教室的原本目的。作者因为发现自己对这门学科如此地感兴趣，所以才想成为心理学家，也就在第二天把专业志愿从经济学换成了心理学。</p><p>作者在自传的序言中就提到了一个对新生的建议：比起思考 “Who am I?”，更应该思考 “Who do I want to become?”。我想，在选定心理学专业的那一刻，作者已经清楚地回答了自己的这个问题。</p><blockquote><p>For the past fifty years as a teacher, I have tried to impart this way of looking at things to my students. Early in my career I came to understand that this was the single most precious gift I could ever give them. Students are continually asking themselves, “Who am I?” My goal was to get them to reframe the question into <strong>“Who do I want to become?”</strong> Once they arrive at their own answer, they must also learn that getting there won’t come by chance alone.</p></blockquote><h1 id="优秀的入门教材"><a href="#优秀的入门教材" class="headerlink" title="优秀的入门教材"></a>优秀的入门教材</h1><h2 id="大量的例子"><a href="#大量的例子" class="headerlink" title="大量的例子"></a>大量的例子</h2><p>这本教材和其它学科的美国经典教材有一个共同显著的特点，就是富含大量生动且贴近生活的例子。比如在我阅读的第十二版里，就有多处以 2016 年美国总统大选为例解释偏见和冲动行为的发生原因。除此之外，也有发生在作者自己身边的例子，比如在解释旁观者效应这一节中，就提到了作者在野营中的一次经历：在这次野营的晚上，附近一个帐篷里发出了一声惨叫，而当作者走出一探究竟时，发现已经有很多附近帐篷的人提着灯围在那儿了。如果用旁观者效应解释的话，大家应该都害怕得或冷漠得呆在自己的帐篷里才对，但作者借这次亲生经历来提醒读者，旁观者效应有着更为苛刻的条件，同时存在其它潜在因素可以打破这个效应，但仍需大量实验证明。</p><h2 id="带着疑问阅读"><a href="#带着疑问阅读" class="headerlink" title="带着疑问阅读"></a>带着疑问阅读</h2><p>“带着疑问阅读”，是备受推崇的一种阅读方法。这本教材，为了激起读者的疑问，在教材的第一章便列举了 11 个真实发生的小故事，而读者要想解释这 11 个小故事，明白其中的缘由，就需要一节一节地阅读和思考。在每个章节的第一篇，作者也依旧举一个例子作为引子，带出主题。当阅读完一章之后，再回看之前的例子，便能豁然开朗：看上去荒谬的现象背后，也存在合理的解释。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>《社会性动物》包含了比较流行的，对初学者比较感兴趣的话题：自我辩解，大众交流，从众性，偏见等。因为作者 Aronson 致力于认知失调（Cognitive Dissonance）的研究，所以其中的一章 “自我辩解” 其实就是围绕着这一理论展开的。在之后的其它章节中，作者也多次用认知失调来解释现象和实验结果。</p><h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>因为这两本书包含了太多的内容，但这些内容又是那么地生动有趣，我想我这么一篇小结，也仅仅分享了我在阅读过程的感想的一部分而已。把这本书推荐给没有了解过心理学但又想要了解的读者。这两本书籍，不仅可以帮助我们进一步理解社会中的一些奇怪现象，同时通过这些现象，我们又能反窥我们自己，了解我们为什么有时能做出另自己事后愧疚懊悔和疑惑的，与自己预期不符的行为。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Not by Chance Alone》(中译：&lt;a href=&quot;https://book.douban.com/subject/19949881/&quot;&gt;绝非偶然&lt;/a&gt;)以及《The Social Animal》(中译：&lt;a href=&quot;https://book.douban.com/subject/2328458/&quot;&gt;社会性动物&lt;/a&gt;) 均为社会心理学家 Elliot Aronson (埃利奥特·阿伦森) 的著作。前者，为 Aronson 的自传；而后者，则是由 Aronson 编写的社会心理学入门教材。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SocialScience" scheme="https://lazzzis.moe/tags/SocialScience/"/>
    
    <category term="Reading" scheme="https://lazzzis.moe/tags/Reading/"/>
    
    <category term="Psychology" scheme="https://lazzzis.moe/tags/Psychology/"/>
    
  </entry>
  
  <entry>
    <title>工作，生活，以及其它，在 2019 与 2020</title>
    <link href="https://lazzzis.moe/post/the-end-of-2020/"/>
    <id>https://lazzzis.moe/post/the-end-of-2020/</id>
    <published>2021-01-01T03:15:30.000Z</published>
    <updated>2021-01-01T07:40:07.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「明日も明後日も　明々後日も来年も　君を想って言葉を描くだろう」ー　椎名もた「アイケアビコーズ」</p></blockquote><a id="more"></a><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>现实很残酷，根本不会管我做好心理准备了没有。</p><p><img src="https://as2.bitinn.net/uploads/cq/cjn9z685e0000428he9lwuccq.1440p.jpg" alt="工作工作"><span class="image-caption">工作工作</span></p><h2 id="接到-offer-后的喜悦"><a href="#接到-offer-后的喜悦" class="headerlink" title="接到 offer 后的喜悦"></a>接到 offer 后的喜悦</h2><p>就像在上一篇文章里说的那样，我因为在小公司实习待得不开心后，格外想去流程规范，技术先进的大公司。而在这种期待之下，我拿到了一个大公司的 offer。自然是喜悦的不行，于是 2019 年的前半年几乎都在玩，中间也只是去看了点 Angular 相关的技术而已。</p><h2 id="选组的将就"><a href="#选组的将就" class="headerlink" title="选组的将就"></a>选组的将就</h2><p>因为我一直做前端相关的工作，自然也会倾向于选择一个做前端的组，尤其是 web 前端。而 google 一个重要产品就是 chrome，我想当然地与 hr 说想去 chrome 组。而事实很意外，hr 给了三个组都是 Android app 开发的，而我和这三个组的 manager 联系了后，都被拒绝了。而下一个组是 Chrome on Android，经历了前三次的失败后，我心理自然放低了点要求，没多问什么。不出意外地，对面的 manager 很中意。</p><p>那问题来了，我该不该去这个组？</p><p>我当时考虑的是：</p><ol><li>具体技术不重要，重要的是处理问题的能力。</li><li>小组容易晋升。这是我问了几个在 Google 工作几年的朋友告诉我的。我选择相信。另一方面，就像小班教育会比大班教育有优势一样，我也相信小组会比大组好。</li><li>相比于一些开发 Google 内部独有工具的组来说，开发 Android 的经验好歹以后能在其它公司的 App 开发上有用处。</li></ol><p>虽然和最初的 web 前端不一样，但想着以后也早晚走出舒适圈，学习新事物。我就决定选了这个组，虽然心里还是有一点将就的感觉。</p><h2 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h2><p>2019 年下半年开始入职后，我开始反思当初考虑的是不是正确：</p><p>第一点到没什么问题。写一份优秀的设计文档，编写可测试的代码等等，这些能力确实与具体技术关系不大</p><p>第二点的话，容不容易晋升我得不出结论，但小组的优势确实体会到了。现在包括我和 manager 在内，也总共就 6 个组员。比起其它 10 多个组员的组来说，开组会的沟通有效很多。而且 manager 至今坚持一周至少一次的 1:1。我起初认为这没什么，后来了解了几位朋友的情况：实际上，不同组之间在这一点上差异也很大，有的才两周一次。我的 manager 在 WFH 开始期间，还主张一周两次，来询问我们的近况，提供帮助。另一方面是，这个组给我的工作氛围很好，几乎（虽然偶尔还是有例外）没人会在周六或晚上发邮件和交 CL。我也没有感觉到有办公室政治的倾向。所以，总体来说，组内的氛围我目前还是比较喜欢的。</p><p>第三点的话，和我预期完全相反。首先就是现在 Kotlin 已经是 Android 的第一开发语言了，但现在我们还在用 Java 8，同时也是因为 Android 只支持到 Java 8。类似地，也有历史原因的缘故，我们这个组至今没有使用任何 Jetpack 相关的开发组件，也没有 guice 等依赖注入是的管理（虽然没有依赖注入是好事也说不定）。总的来说，和主流是相差甚远了。这里，也打破我当初一个纯粹的假设：既然是自家的东西，自家的技术，当时应该是用自家最新的了咯，不然怎么起带头示范作用？我想错了，事实远比想象复杂。</p><h2 id="关于-Career-Path"><a href="#关于-Career-Path" class="headerlink" title="关于 Career Path"></a>关于 Career Path</h2><p>其实我一直没想好未来几年努力的方向，现在姑且是朝着晋升去的，目标从 L3 升到 L4，然后以此类推。但我还是想找一点更多的意义。</p><p>一方面，当别人已经在一年两年里升级到 L4 了。而我自己总觉得自己的 impact 很小：相比于别人动不动就是多少多少 revenue 的项目，我自己的 UI 组件似乎很难寻找一个量化的，体现自己 impact 的指标。这一点似乎是在量化 UI 效果方面的一个通病。</p><p>另一方面，体会不到自己的成长。似乎每一年的总结里，总上面有这句话，真不清楚是自己不知道自己的成长，还是真的没有成长。</p><p>我猜想，大概是缺少一种正反馈吧，一种看的到自己成长的正反馈吧。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="最后的校园生活"><a href="#最后的校园生活" class="headerlink" title="最后的校园生活"></a>最后的校园生活</h2><p>2019 年上半年是最后一个学期，只有一节课，加上已经确定工作了，真是自在得不行。可惜因为钱大多拿去交学费了，口袋里的钱并不多，不足以支撑我四处游玩。</p><p>唯一的长途旅行是在春假，先后去了 Boston 和 Boise 拜访了几个小伙伴。</p><p><img src="https://i.loli.net/2021/01/01/pj2Ugr4LinPcYWJ.jpg" alt="在 Boston"><span class="image-caption">在 Boston</span></p><p>然后就是经常去对岸的 NYC 了。这大概最没压力的一段时间了吧。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>入职后就买了 Switch。沉迷于动森, Splatoon 2 和塞尔达。这大概是我的第一部游戏机。</p><p><img src="https://i.loli.net/2021/01/01/POKDF7aLuGqW4Ce.jpg" alt="Switch 上的游戏"><span class="image-caption">Switch 上的游戏</span></p><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><p><a href="http://bgm.xiadong.info/report/lazzzis?year=2020">2020 年的番剧</a></p><p>总体上惊喜不是很多</p><ul><li>把 EVA 给补了：其实我小时候没看过《天鹰战士》</li><li>《欢迎来到 NHK》：代入感太强，因为感觉自己曾经差点会变成一个 hikkimori。</li></ul><h2 id="漫画"><a href="#漫画" class="headerlink" title="漫画"></a>漫画</h2><p><a href="http://bgm.tv/subject/214942">月曜日の友達</a></p><p>满分神作。像诗一样优美的对话与独白，精美的分镜，恰到好处的涂黑和留白，童话般的结局 — 一个关于成长与朋友的故事，并不复杂，但在阿部共実老师的创作下，却能直击我的内心。很久没有遇见能令我这么心动的作品了。</p><p>我甚至无法用言语表达对这部作品的喜爱，这简直是我理想中的故事。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul><li>开始阅读与技术无关的，社会人文类的，非文学的书籍，如 <a href="https://www.goodreads.com/book/show/71730.Nonviolent_Communication">Nonviolent Communication: A Language of Life</a>, <a href="https://www.goodreads.com/book/show/6934913-the-shortest-history-of-europe">The Shortest History of Europe</a></li><li>有一段时间，大概长达半年多，因为白天工作，晚上沉迷游戏，并没怎么做和学习开源项目</li><li>把日语过了 N3，算是回应了 18 年总结末尾关于 “学习新语言” 的目标。只是本来可以考 N2 的，但可惜北美考场被取消了。</li><li><del>这两年间除了总结，没有写新文章</del></li></ul><hr><h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p>2020 年年中的时候看了心理医生，谈了两次话。导火索是和一位非常要好的朋友的巨大争执。但深层原因其实是恰好当时的我因为对未来的迷茫以及对自我的极度否定而陷入了深深的低谷和自责，再加上缺少倾诉烦恼的对象，导致了一次内心的极度抑郁。平时 12 点就睡觉的我在那两周每天晚上都熬到 4 点甚至 5 点左右，白天工作也精神恍惚。不过还好，也不是什么疾病，在引导下，很轻松地解决了。更简单地说，这其实是自己对自己的压迫而产生的巨大的焦虑感和挫败感导致了自己内心的一次奔溃。所以现在的话，我会尝试适当放低对自己的要求，避免无意义的比较，因此大概率是不会重蹈覆辙了。</p><p>至此，我也不想立什么奇怪的 flag。仅希望自己能寻找到让自己开心的事情就好，同时祝阅读此文的各位生活愉快！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「明日も明後日も　明々後日も来年も　君を想って言葉を描くだろう」ー　椎名もた「アイケアビコーズ」&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>我的 2018</title>
    <link href="https://lazzzis.moe/post/the-end-of-2018/"/>
    <id>https://lazzzis.moe/post/the-end-of-2018/</id>
    <published>2019-02-14T05:31:23.000Z</published>
    <updated>2019-02-14T05:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「すべて 夢見ることから」ー　椎名もた「夢の値段」</p></blockquote><a id="more"></a><h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>我最初是想把这篇年终总结给鸽了的。</p><p>与前两年一样，又是不算满意的一年，似乎没什么好写的，于是就想：不写了吧！</p><p>也是就这样拖了一个月。</p><p>后来想想，2018 年也是过来了，也得留下点什么。就算不满意，这也是过来了，也是不可否认的事实。</p><p>于是趁着农历新年的尾巴，写了这篇总结。</p><h1 id="夏天"><a href="#夏天" class="headerlink" title="夏天"></a>夏天</h1><p>夏天的暑假是在一个小公司度过的。这是一个在 Brooklyn, NYC 的小公司，小到只有一个办公室。找到这份实习完全是因为机缘巧合认识了一个在这公司的一个中国人。而且他是这公司唯一的前端工程师，因此他有很大的话语权能决定招怎样的前端程序员。因为我的背景比较符合该公司的业务需求，而且该公司也确实在找前端工程师，加上当时很快就暑假了，剩下的机会不多，所以我就去这家公司实习了。</p><p>我在这公司学到了什么嘛？很可惜，并没有。</p><p>我想来想去，收获大概就是：</p><ul><li>简历丰富了一点</li><li>赚了点钱</li><li>让我更想去大公司了</li></ul><p>这个小公司的前端仅仅停留在完成需求上面，没有追求代码的美观，可维护性，运行效率等等方面。可以说，该公司的项目代码里存在各种反模式的设计，就连常说的 DRY 也做不到。举个最简单的例子，这公司的项目里，有很多复制粘贴的代码，这些代码之间仅仅之间仅仅是多一个标签或少一个标签而已。在这明显可以封装成组件的情况下，项目也没有对此进行优化。导致的结果就是，一旦这一部分有一丁点需求改动，就必须找到所有类似代码进行修改，非常费时费力。</p><p><img src="https://as2.bitinn.net/uploads/legacy/yg/cjb04lrij01qdxz5njuy4xcyg.1200.jpg"></p><p>所以想在小公司学到东西，还是得先保证能有何大公司一样的流程，并且有经验丰富从业人员的指导。而这公司明显不符合以上两点。所以这让我对小公司的选择变得更加谨慎，而对大公司更多了一份向往之情。</p><p><img src="https://as2.bitinn.net/uploads/legacy/qj/cjb04g22l01q5xz5nxxpvnoqj.1200.jpg"></p><h1 id="秋天"><a href="#秋天" class="headerlink" title="秋天"></a>秋天</h1><p>紧跟在夏天的实习之后的是紧张的秋招。在 9 月初投了很多大公司。其中报比较大期望的是 Amazon。即使该公司去年（2017）缩招了，今年的流行论调也依旧认为，相比其它大公司而言， Amazon 是招 New Grad 比较多。</p><p>但很失望的是，仅仅几天时间，很多大公司就把我拒了，包括 FaceBook 和 Amazon。而出乎意料地，Google 给了我一次机会，在我完成 OA 后，马上就邀请我去 Onsite。我很吃惊，因为正常情况下，OA 之后是电面才对，而这次电面被 skip 了。</p><p>“这是良机！” 我这么认为。</p><p><img src="https://as2.bitinn.net/uploads/ce/cjs45z370003b1t8h680kjxce.1080p.jpg" alt="不要犹豫 去抓住良机吧"><span class="image-caption">不要犹豫 去抓住良机吧</span></p><p>距离 Onsite 一个月，我开始疯狂刷题。期间也找了很多人帮我 Mock。一直到 Onsite 为止。</p><p>而在这一个月的疯狂刷题间，我不知不觉地下了一个赌注 —— 我几乎放弃了很多中小公司的申请机会。因为这一个月间，我把 Google 的面试看得极其重要，在忙于面经与算法题之间，几乎没有去搜集任何其它公司的招聘信息。那时的我把这次机会看得太重了，因为其它大公司已经把我拒了，我只有这么一个机会去大公司了，失去这次机会的话，我只能怀着不甘的心情去小公司甚至是 ICC 了。</p><p>我清楚地记得在暑假实习时的小公司的痛苦时光。实在不想去流程不规范的，没有大牛的小公司了。而优秀的小公司实在是少，而且招人又少。还有，糟糕地是，一些中小公司的学历筛选，尽管他们没有写在 Job Description 上，但公司内给我内推的人就善意地提醒我不要报太大希望 —— 我就读的学校在美国百名徘徊，离他们期望的前 50 相去甚远。在这种不利情况下，我只能看好只有招人多且相对不存在学历鄙视的大公司了。</p><p>怀着这种心情，我在 10 月底进行了 Onsite。题目也是算法题，中规中矩，不算太难。在 Mountain View 呆了 2 天整，后来就回美东了。</p><p>大概过了几周，结果也出来了。最后是在感恩节前一天签下了 Offer。一切也算是圆满。</p><p>签好之后的第一感觉就是松了一口气，至少未来几年的生活算是有个着落了。</p><p>说起来也确实是幸运，后来知道今年 Google 扩招了不少，很多人借机踏上了这条船，这其中也包括我。换作前几年的话，我想我应该没有这么幸运的吧！</p><h1 id="下一年"><a href="#下一年" class="headerlink" title="下一年"></a>下一年</h1><p>确定了工作了之后，生活似乎轻松了许多。最后一学期的课程也极其轻松。看着空空的时间表，“尝试一些没有过的事情吧” 我这么对自己说。“无论是什么都可以，除了敲代码！”。</p><p>已经花了很多的时间在代码上了，这确实也是我兴趣的一部分。但这似乎太单调了 —— 我的生活还是太宅了，除了敲代码，似乎就是看番了。</p><p>所以走出去吧，跨出这“四叠半”的房间。去哪儿旅行一会，或许是一个不错的选择，不用太远，就算是附近的城市也好，只要不是一直宅着。</p><p>即使是在家的时间，也学点除了代码的东西吧，包括学一门新语言也好。毕竟，等以后工作了，似乎就很难了花大量时间学了。</p><hr><p><img src="https://i.loli.net/2019/02/14/5c64fb2d67b53.jpg" alt="对岸 -- 摄于 2018 年 2 月 13 日"><span class="image-caption">对岸 -- 摄于 2018 年 2 月 13 日</span></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「すべて 夢見ることから」ー　椎名もた「夢の値段」&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>参加初音 2018 纽约演唱会</title>
    <link href="https://lazzzis.moe/post/miku-2018-expo-in-nyc/"/>
    <id>https://lazzzis.moe/post/miku-2018-expo-in-nyc/</id>
    <published>2018-07-19T04:46:34.000Z</published>
    <updated>2018-07-20T02:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周六，7 月 14 日，miku 在纽约城举办了一场演唱会，而这也是我第一次参加 miku 的演唱会。在这里分享一些经历，感悟及收获吧。</p><a id="more"></a><h1 id="关于购票"><a href="#关于购票" class="headerlink" title="关于购票"></a>关于购票</h1><p>很偶然在推特上看到了初音演唱会的消息。纽约演唱会的购票由 ticketmaster 支持，支持网上购票和现场通过手机 APP 入场，所以非常方便。不过购票时注意一下，官方会提供一个保险，价值大约 7 刀。这个保险主要是用于保障你购票和参加演唱会时的安全。当时我没有注意，就把保险一起买下来。所以如果觉得保险没用的话，记得购票时取消购买保险的选项。</p><h1 id="关于预售"><a href="#关于预售" class="headerlink" title="关于预售"></a>关于预售</h1><p>演唱会前，官方在 <a href="https://mikumerch.com/">mikumerch.com</a> 有部分商品的预售。因为是预售，我自然认为这些商品都应该是这对 2018 年演唱会而设计的。但买来后发现，一些衣服和帽子上清楚地印着 <code>miku expo 2016</code>（所以这些应该就是当年的余货了）。</p><p>不过我买的那一根应援棒上面写的倒还是 <code>2018</code>。</p><p>除了上面提供的网站，官方还提供了另一个网站 <a href="https://www.forfansbyfans.com/feature/miku-expo-challenge-designs-from-the-fan-forge.html">miku expo from the fan forge</a>。这些商品全是粉丝设计，但质量一点也不差，在演唱会当天我穿着的衣服就是从这网站购买的（其实是因为只有这里能买到 S 码的衣服了。。）。</p><h1 id="关于排队"><a href="#关于排队" class="headerlink" title="关于排队"></a>关于排队</h1><p>按照时刻表，应该是 8 点开始，7 点入场。当我觉得入场前应该有场贩之类的，所以提早了 2 个半小时到达，也就是 4 点半到达。计划是在入场前好好逛逛场馆。</p><p>然而事实是场馆前已经排起了近以百米的长队。而且他们都不是在等场贩，而全是在等待场馆开门。</p><p>于是在 7 点入场前，我足足等了近 2 个小时。当时太阳还没下山，队伍也都在排街道上，于是这两个小时我也一直在晒太阳。啊，纽约的太阳啊。</p><p>排队的时候，跟旁边几个人尬聊了一会，发现周围几个人里就只有我一个是第一次参加，其他人全部都已经至少参加过一次了。</p><p>队伍越来越长，发现全家出动的不在少数，有很多全家 cos 的前来排队。</p><p><img src="https://i.loli.net/2018/07/20/5b5148b6d5898.jpg" alt="长队"><span class="image-caption">长队</span></p><h1 id="关于入场"><a href="#关于入场" class="headerlink" title="关于入场"></a>关于入场</h1><p>入场检查东西是还被保安拦下了。。原因是我带了 iPad，被要求寄存。我只好乖乖拿去寄存了，寄存还收了我 6 刀。</p><p>不过好处是我不用背着包听演唱会了 – 我可以毫无顾及地跳了。所以我入场时就只拿着一个应援棒了。</p><p>入场后，因为一层全是站的，并没有座位分配，所以需要尽可能往前排，否则只能挤到最后面。</p><p>而且欧美人普遍身高较高，注意选一个视线好一点的位置。或者干脆去购买二层的一些票（有座位分配，保证能看到，但有点距离）。</p><h1 id="关于开场"><a href="#关于开场" class="headerlink" title="关于开场"></a>关于开场</h1><p>时间一到，我就把手机调成飞行模式了，不想被任何人和事打扰。</p><p>在全息影像打开前，一直处于放一些歌曲的状态。计划时间是 8 点整开始，所以 8 点一到，底下的人就已经躁动了。但事实是 8 点之后仍然没有开始，包括机器也还没打开。</p><p>但底下的人仍然耐心等待，很多人已经开始挥动应援棒了。中间不止一次一起喊 “miku miku”。甚至还有一群人喊起了 “USA USA” (这应该是美国特色了把。。)。</p><p>大概 8 点半，机器打开，全场疯狂。</p><p><img src="https://i.loli.net/2018/07/20/5b5148cf16be7.jpg" alt="开场前的呼唤"><span class="image-caption">开场前的呼唤</span></p><h1 id="关于歌单"><a href="#关于歌单" class="headerlink" title="关于歌单"></a>关于歌单</h1><p>歌单其实我在演唱会前一个星期就知道了。因为此处美国巡演中，nyc 是最后一场，而之前的场次的歌单已经在网上有信息了，比如这里 <a href="http://vocaloid.wikia.com/wiki/HATSUNE_MIKU_EXPO_2018_USA_%26_MEXICO">link</a>。只要知道前几场的歌单，基本就能猜到当天的歌单了。</p><h1 id="关于打-CALL"><a href="#关于打-CALL" class="headerlink" title="关于打 CALL"></a>关于打 CALL</h1><p>因为这是我第一次参加日系的演唱会（甚至可能是人生中参加的第一场演唱会），所以知道会有打 CALL，提前就把应援棒准备好了。</p><p>而且非常幸运地是，边上几个亚裔小哥，非常会打 CALL，完全带动了周围的人，所以我当时只要跟着打 CALL 就好了。</p><p>不过，我对打 CALL 仍然准备不充分，并不明白一些打 CALL 的节奏和方式。在演唱会第二天，在知乎推荐下发现了这么一个 B 站的 UP 主，<a href="https://space.bilibili.com/700631/#/">H.Mos</a>。这位 UP 主有一些关于打 CALL 的理论和实践教程，很值得推荐。</p><p>值得一提的是 ルカルカ★ナイトフィーバー (Luka Luka★Night Fever) 这首曲子的打 CALL。这算是全场最好的打 CALL 了（个人感觉）。在刚才推荐的视频教程里也用了这首歌讲例子（要是我能提前看这视频就能在当天更好地打 CALL 了）。</p><p>话说我当时跟跳的时候还踩到了后面小哥的脚 😥。</p><h1 id="关于场贩"><a href="#关于场贩" class="headerlink" title="关于场贩"></a>关于场贩</h1><p>场贩就两个小摊位，人很多，要排队。不过比入场要好多了。排个 5 分钟就好。</p><p>很残念的是轮到我的时候，帽子卖完了。</p><p><img src="https://i.loli.net/2018/07/20/5b514a1f732c8.jpg" alt="现场购买的一张 CD"><span class="image-caption">现场购买的一张 CD</span></p><h1 id="关于-encore"><a href="#关于-encore" class="headerlink" title="关于 encore"></a>关于 encore</h1><p>Encore 有点乱。。因为大家喊的都不同，无法统一起来，喊啥的都有：”miku miku”，”Encore”, “もう一回”，甚至还有 “USA”。</p><h1 id="关于演唱会后"><a href="#关于演唱会后" class="headerlink" title="关于演唱会后"></a>关于演唱会后</h1><p>结束时已经快 11 点了。除了兴奋之余，还感觉到特别的饿。。因为我只吃过午饭。。</p><p>结束后跟几个大佬们去吃饭，找了几家店都发现要不是关门，要么就是人满为患，最后还是在某个麦当劳吃了一餐。</p><p><img src="https://i.loli.net/2018/07/20/5b5148f92332e.jpeg" alt="Thank you, New York City"><span class="image-caption">Thank you, New York City</span></p><h1 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h1><p>非常棒，无法用言语表达。整场演唱会都沉浸于氛围当中，你能做到的就是欣赏和打 CALL，你甚至没有时间拿出手机拍照。</p><p>如果有机会参加，千万不要错过。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>但其实这本来可以是第二次的。初音曾在 2015 年的时候，在上海举办过为期两天的演唱会。</p><p>当时的我其实非常适合去参加这次演唱会：一是当时我在杭州读本科，具体上海很近，可以很方便地在两地往返，而是我票价可以接受，虽然不一定负得起 VIP 票，但普通的票是完全没问题的。</p><p>但是很遗憾的是当时太保守了（认识那天会有事去不了），以及其它一些个人原因，没有买票。到演唱会的第二天，我通过网络直播看完了全场。从看完的那一刻起，我发誓如果还有下次机会，绝对不会再让她溜走了。</p><p>于是，在今年 5 月初的时候，我偶然在 twitter 上看到了 miku 北美演唱会的消息，所以当时的我毫不犹豫地买下了 nyc 那场的票 – 兑现自己曾经的诺言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周六，7 月 14 日，miku 在纽约城举办了一场演唱会，而这也是我第一次参加 miku 的演唱会。在这里分享一些经历，感悟及收获吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Putong OJ v2.0 开发过程中的踩坑记录</title>
    <link href="https://lazzzis.moe/post/issues-in-the-development-of-putongoj-v2/"/>
    <id>https://lazzzis.moe/post/issues-in-the-development-of-putongoj-v2/</id>
    <published>2018-05-28T00:54:46.000Z</published>
    <updated>2018-05-27T21:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学校指导老师的要求下，同时 <a href="https://github.com/Kerminate">Kerminate</a> 想把写 OJ 作为毕业设计的情况下，我和 Kerminate 决定开发 2.0 版本。具体的特性已经在项目地址 <a href="https://github.com/acm309/PutongOJ">PutongOJ</a> 说明。这里主要说一下这次开发中的坑。</p><a id="more"></a><h1 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h1><p>在后端结构上，直接采用了之前的项目文件结构，结果可以看到，几乎所有文件夹都放在项目一级目录下，包括 <code>controller</code>, <code>model</code> 文件夹等。现在看来，应该都把它们放在一个 <code>src</code> 文件夹下的。因为如果采用这种方式，那么使用 <code>babel</code>, <code>tsc</code>, <code>eslint</code> 等工具时，可以更方便的指定需要操作的文件夹。不然现在，如果我要使用这些工具，我需要指定一些需要被工具 <code>ignore</code> 的文件夹，比如 <code>public</code> (里面可能包含一些编译好的前端 js 文件)。</p><h1 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h1><p>原先计划是全用英文的，因为觉得大多数单词都很常见，比如: <code>Problem</code>, <code>Status</code>, <code>Wrong Answer</code> 等。而且，正式比赛里，题面都是英文的，因此正常情况下，使用者对英文是不会排斥的。</p><p>但是这里我想错了。有很多使用者其实会排斥英文界面。究其原因，一是因为指导老师除了在 acm 教学上会使用 OJ，在平时其它授课，比如 C 语言等，仍然会使用这个 OJ：在这个情况下，这些使用者，也就是学生，大多不会参加 ACM，也觉得做英文界面是多次一举。另外就是，很多使用者是大一学生，大部分英文水平还没经过四六级的磨练，而且有些高考英语也不怎么好，因此在英语水平上可能并不是特别理想。</p><p>就像有些人，一看到书上密密麻麻的数学公式时就会选择直接跳过不读一样，一些学生看到英语也会直接跳过不读。</p><p>在这个要求下，我觉得加上 i18n 支持是必要的。而且现在几乎所有现代网站都有 i18n 支持，实现这个功能对增加用户体验也是挺有好处的。如果未来有机会，再实现这个功能吧。</p><h1 id="docker-中允许-ptrace-操作"><a href="#docker-中允许-ptrace-操作" class="headerlink" title="docker 中允许 ptrace 操作"></a>docker 中允许 ptrace 操作</h1><p>OJ 判题端使用到 ptrace 对子进程进行跟踪控制。但是在默认情况下，在 docker 容器内，这项特性是不被支持的。</p><p>起初我注意到了判题端总是 ptrace 失败的问题，但我一直猜测原因出在判题端本身的实现上。直至我偶然情况下，没有在 docker 容器内测试，而是在一台 linux 服务器上测试时，才发现此时判题端并不会出现 ptrace 失败的问题。之后也猜测了是否是 docker 容器的 linux 版本的问题，不过幸运的是，直接在 google 上以 docker ptrace 为关键字搜索就能知道问题原因。</p><p>解决方案就是开启 docker 对 ptrace 的支持。如果是 docker-compose file 的话，只需加上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_PTRACE</span></span><br></pre></td></tr></table></figure><h1 id="前端-UI-库的选择"><a href="#前端-UI-库的选择" class="headerlink" title="前端 UI 库的选择"></a>前端 UI 库的选择</h1><p>在最开始挑选 UI 库的时候，我首先把 Material 风格的给排除了。原因是个人认为 Material 风格不适合 OJ。</p><p>而主要负责前端编写的 Kerminate 首先使用的是 ElementUI，但 Kerminate 反应这个并不好用，因此又选择了 iView (虽然采用了 iView 了后，也抱怨过 iView 有些组件也不好用)。</p><p>记得当时可选范围限定在了 <a href="https://github.com/vuejs/awesome-vue#frameworks">awesome-vue</a> 列表上出现的 UI 库。与当时相比，现在比以前增加了 5 个左右，而且现在增加了 <code>vue-antd-ui</code>。</p><p>目前 UI 库使用的是 iView，至于如果有 v3.0 的话，要不要换 UI 库，就看那时候的 OJ 维护者了。</p><h1 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h1><h2 id="i18n-1"><a href="#i18n-1" class="headerlink" title="i18n"></a>i18n</h2><p>这个上面提过，个人认为有必要支持。</p><h2 id="TypeScript-与-egg-js"><a href="#TypeScript-与-egg-js" class="headerlink" title="TypeScript 与 egg.js"></a>TypeScript 与 egg.js</h2><p>其实 v2.0 就可以用上 TypeScript。只是当时觉得好像这个项目这么小，用不用也无所谓。但现在想想，为后来的维护者们考虑，使用 TypeScript 可能对他们理解和维护项目能有所帮助。</p><p>至于 egg.js 么，虽然我是随意了，不过有很多人向我推荐啦。如果我觉得确实好的话，就考虑未来用上吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在学校指导老师的要求下，同时 &lt;a href=&quot;https://github.com/Kerminate&quot;&gt;Kerminate&lt;/a&gt; 想把写 OJ 作为毕业设计的情况下，我和 Kerminate 决定开发 2.0 版本。具体的特性已经在项目地址 &lt;a href=&quot;https://github.com/acm309/PutongOJ&quot;&gt;PutongOJ&lt;/a&gt; 说明。这里主要说一下这次开发中的坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
    <category term="Projects" scheme="https://lazzzis.moe/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>解析 JavaScript Error 中的 stack 信息</title>
    <link href="https://lazzzis.moe/post/parse-error-stack-in-js/"/>
    <id>https://lazzzis.moe/post/parse-error-stack-in-js/</id>
    <published>2018-05-27T06:51:08.000Z</published>
    <updated>2018-05-27T03:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>对于任意的 Error 对象，如果将其输出，我们可以看见这个异常的堆栈信息。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Error</span><br><span class="line">    at Object.&lt;anonymous&gt; (&#x2F;Users&#x2F;lazzzis&#x2F;Documents&#x2F;Projects&#x2F;Test&#x2F;test.js:10:12)</span><br><span class="line">    at Module._compile (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:702:30)</span><br><span class="line">    at Object.Module._extensions..js (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:713:10)</span><br><span class="line">    at Module.load (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:612:32)</span><br><span class="line">    at tryModuleLoad (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:551:12)</span><br><span class="line">    at Function.Module._load (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:543:3)</span><br><span class="line">    at Function.Module.runMain (internal&#x2F;modules&#x2F;cjs&#x2F;loader.js:744:10)</span><br><span class="line">    at startup (internal&#x2F;bootstrap&#x2F;node.js:238:19)</span><br><span class="line">    at bootstrapNodeJSCore (internal&#x2F;bootstrap&#x2F;node.js:572:3)</span><br></pre></td></tr></table></figure><p>可以看到这个异常来自: <code>test.js</code> 的第 10 行。但现在的需求是要用 <strong>代码</strong> 捕捉报错的来源文件以及行数。</p><a id="more"></a><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="方法一-RegExp"><a href="#方法一-RegExp" class="headerlink" title="方法一: RegExp"></a>方法一: RegExp</h2><p>因为堆栈信息是字符串形式，所以正则表达式在这个场合就非常合适。</p><p>以 <code>at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)</code> 为例，我们首先需要捕捉的是后面括号内的信息。那么 <code>/at\s+(.*)\s+\((.*)\)/i</code>，中第一个的第一个匹配项为行数的方法，第二个匹配项为括号的信息。</p><p>对上述例子执行改正则，可以得到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="string">`at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)`</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="regexp">/at\s+(.*)\s+\((.*)\)/i</span>.exec(info)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">[ <span class="string">&#x27;at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Object.&lt;anonymous&gt;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/lazzzis/Documents/Projects/Test/test.js:10:12&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)&#x27;</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span> ]</span><br><span class="line"><span class="comment">// res[1] 为函数信息，res[2] 为括号的内的信息</span></span><br></pre></td></tr></table></figure><p>而括号的内信息以 <code>:</code> 为分隔符，那么通过 <code>:</code> 又可以的到报错的文件地址，行数，列数。可以用正则表达式: <code>/at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i</code></p><p>执行可以得到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="string">`at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)`</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="regexp">/at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i</span>.exec(info)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line">[ <span class="string">&#x27;at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Object.&lt;anonymous&gt;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;/Users/lazzzis/Documents/Projects/Test/test.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">  index: <span class="number">0</span>,</span><br><span class="line">  input: <span class="string">&#x27;at Object.&lt;anonymous&gt; (/Users/lazzzis/Documents/Projects/Test/test.js:10:12)&#x27;</span>,</span><br><span class="line">  groups: <span class="literal">undefined</span> ]</span><br><span class="line"><span class="comment">// res[1] 和 res [2] 已再之前讲过，不重复</span></span><br><span class="line"><span class="comment">// res[3] 为 行数，res[4] 为列数。</span></span><br></pre></td></tr></table></figure><p>通过上述方法，已经可以拿到该有的基本信息。</p><h2 id="方法二-Error-prepareStackTrace-方法"><a href="#方法二-Error-prepareStackTrace-方法" class="headerlink" title="方法二: Error.prepareStackTrace 方法"></a>方法二: Error.prepareStackTrace 方法</h2><p>node 是基于 v8 实现的，而 v8 给 Error 暴露了一个 prepareStackTrace 方法，因此可以借由这个方法实现我们所需的功能。</p><p>在 v8 中，堆栈信息并不是一开始就是字符串。在变成字符串前，其中一个状态是以一个数组形式存储的，而数组的每个元素是一个 CallSite 对象。简单理解，CallSite 包含了函数名，行数，错误类型等信息，可以简单把每一个 CallSite 对象看作堆栈信息中的每一行。</p><p>在每次将 Error 对象输出到 console 时，Error 会用 prepareStackTrace 方法将其变成字符串。如果我们覆盖此方法，就可以改变其默认行为，让它输出成其它东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>.prepareStackTrace = <span class="function">(<span class="params">error, structuredStackTrace</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> structuredStackTrace</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.getFileName() + <span class="string">&#x27;, &#x27;</span> + item.getFunctionName())</span><br><span class="line">    .join(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// [/Users/lazzzis/Documents/Projects/Test/test.js, null</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, Module._compile</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, Module._extensions..js</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, Module.load</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, tryModuleLoad</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, Module._load</span></span><br><span class="line"><span class="comment">// internal/modules/cjs/loader.js, Module.runMain</span></span><br><span class="line"><span class="comment">// internal/bootstrap/node.js, startup</span></span><br><span class="line"><span class="comment">// internal/bootstrap/node.js, bootstrapNodeJSCore]</span></span><br></pre></td></tr></table></figure><p>可以看到我们通过了另一种方法拿到了堆栈信息中每一个文件和每一个函数名。</p><p>除了 <code>getFileName</code> 和 <code>getFunctionName</code> 方法外，还有 <code>isToplevel</code> 等更多方法。参考 <a href="https://github.com/v8/v8/wiki/Stack-Trace-API">Stack Trace API</a> 可以看到更多。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>那么解析这个堆栈信息可以干嘛呢？目前我所了解到的，主要有两种使用场景: logger 和 test</p><h2 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h2><p>有些 logger，比如 <a href="https://github.com/baryon/tracer/blob/master/lib/console.js">baryon/tracer</a> 在输出 logger 信息的同时还能告诉你发出这条信息的文件地址和函数。</p><p>比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;tracer&#x27;</span>).console()</span><br><span class="line"></span><br><span class="line">logger.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// output:  2018-05-26T22:59:36-0400 &lt;log&gt; test.js:3 (Object.&lt;anonymous&gt;) hello</span></span><br></pre></td></tr></table></figure><p>而这个 log 方法的实现其实就基于 Error 信息的堆栈信息捕捉。可以从项目源码看出，tracer 在 log 方法调用的时声明一个异常（注意，并不是抛出了一个异常）。通过这个异常，使用正则表达式的方式对其捕捉，可以得到报错的函数及方法。</p><p>如果我们自己实现一个 log 方法，可以这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> info = <span class="keyword">new</span> <span class="built_in">Error</span>().stack.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>]</span><br><span class="line">  <span class="keyword">const</span> res = <span class="regexp">/at\s+(.*)\s+\((.*):(\d*):(\d*)\)/i</span>.exec(info)</span><br><span class="line">  <span class="keyword">const</span> [</span><br><span class="line">    functionName,</span><br><span class="line">    filepath,</span><br><span class="line">    linenum,</span><br><span class="line">    colnum</span><br><span class="line">  ] = res.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> filename = path.basename(filepath)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span> &lt;log&gt; <span class="subst">$&#123;filename&#125;</span>:<span class="subst">$&#123;linenum&#125;</span>:<span class="subst">$&#123;colnum&#125;</span> (<span class="subst">$&#123;functionName&#125;</span>) <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pleaseLogThis</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  log(<span class="string">&#x27;this is a message&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pleaseLogThis()</span><br><span class="line"><span class="comment">// output: 5/26/2018, 11:14:39 PM &lt;log&gt; test.js:17:3 (pleaseLogThis) this is a message</span></span><br></pre></td></tr></table></figure><p>其中 <code>log</code> 方法就是 tracer 的 log 的简化版了。其中代码中的 <code>new Error().stack.split(&#39;\n&#39;)[2]</code> 之所以取第三个元素，是因为第一个元素是错误的类型，例如是 <code>Error</code> 还是 <code>TypeError</code> 之类的，第二个元素是 <code>log</code> 方法本身的信息，也就是 Error 被声明的那一行的信息，这是我们不关心的内容。而第三个元素才是 <code>log</code> 方法被调用那一行的信息。</p><p>tracer 使用的正则表达式，而 <a href="https://github.com/klauscfhq/signale/blob/master/signale.js">klauscfhq/signale</a> 使用的则是 <code>Error.prepareStackTrace</code> 方法。同样如果我们自己实现一个 demo 的话，可以这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> orig = <span class="built_in">Error</span>.prepareStackTrace</span><br><span class="line">  <span class="built_in">Error</span>.prepareStackTrace = <span class="function">(<span class="params">_, stack</span>) =&gt;</span> stack</span><br><span class="line">  <span class="keyword">const</span> &#123; stack &#125; = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  <span class="built_in">Error</span>.prepareStackTrace = orig</span><br><span class="line">  <span class="keyword">const</span> info = stack[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span> &lt;log&gt; <span class="subst">$&#123;path.basename(info.getFileName())&#125;</span>:<span class="subst">$&#123;info.getLineNumber()&#125;</span>:<span class="subst">$&#123;info.getColumnNumber()&#125;</span> (<span class="subst">$&#123;info.getFunctionName()&#125;</span>) <span class="subst">$&#123;message&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它不变，即可得到同样的效果。其中 <code>const orig = Error.prepareStackTrace</code> 是将原先的方法保存下来，使用后复原，避免对其它可能抛出异常的代码产生负面影响。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>以 <a href="https://github.com/avajs/ava">ava</a> 为例，它能在测试报告中表明具体测试代码中不通过的那一个测试所在的行，并高亮。</p><p>通过源代码 <a href="https://github.com/avajs/ava/blob/master/lib/beautify-stack.js">lib/beautify-stack.js</a> 可以看到，ava 知道具体哪一行和哪一个文件也是通过对 Error 对象的堆栈信息进行解析，而且使用的是正则表达式匹配的方法。实现基本和 tracer 相似，因此就不多讲了。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>Error.prepareStackTrace 相比于 正则表达式方法有一个致命缺点，就是它仅对 v8 有效。如果说只在 node 环境使用，那没什么问题。但如果也需要在浏览器环境使用的话，那么这个方法也仅在 chrome 上有效，在 Firefox 上会抛出异常。</p><p>因此如果不需要考虑浏览器环境，那么请随意选择一个喜欢的。反之，只能考虑借助正则表达式。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/v8/v8/wiki/Stack-Trace-API">Stack Trace API</a></li><li><a href="https://github.com/avajs/ava">avajs/ava</a></li><li><a href="https://github.com/klauscfhq/signale">klauscfhq/signale</a></li><li><a href="https://github.com/baryon/tracer">baryon/tracer</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;对于任意的 Error 对象，如果将其输出，我们可以看见这个异常的堆栈信息。例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Object.&amp;lt;anonymous&amp;gt; (&amp;#x2F;Users&amp;#x2F;lazzzis&amp;#x2F;Documents&amp;#x2F;Projects&amp;#x2F;Test&amp;#x2F;test.js:10:12)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Module._compile (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:702:30)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Object.Module._extensions..js (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:713:10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Module.load (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:612:32)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at tryModuleLoad (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:551:12)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Function.Module._load (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:543:3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at Function.Module.runMain (internal&amp;#x2F;modules&amp;#x2F;cjs&amp;#x2F;loader.js:744:10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at startup (internal&amp;#x2F;bootstrap&amp;#x2F;node.js:238:19)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    at bootstrapNodeJSCore (internal&amp;#x2F;bootstrap&amp;#x2F;node.js:572:3)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到这个异常来自: &lt;code&gt;test.js&lt;/code&gt; 的第 10 行。但现在的需求是要用 &lt;strong&gt;代码&lt;/strong&gt; 捕捉报错的来源文件以及行数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Vue 组件需要一个 name</title>
    <link href="https://lazzzis.moe/post/name-attribute-in-vue-component/"/>
    <id>https://lazzzis.moe/post/name-attribute-in-vue-component/</id>
    <published>2018-04-11T04:37:58.000Z</published>
    <updated>2018-05-05T21:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>无论是通过 <code>Vue.component</code> 的方式，还是在写 <code>.vue</code> 文件的方式，官方都会推荐你写一个 <code>name</code> 属性。但是好像这个 name 在渲染时又几乎用不到，那么它实际能干嘛呢?</p><a id="more"></a><h1 id="方便调试"><a href="#方便调试" class="headerlink" title="方便调试"></a>方便调试</h1><p>Vue 有一款官方强力推荐的浏览器上的调试插件: <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>。通过打开调试工具，我们可以很轻松的看到已经渲染到页面上的各个组件，以及对应的组件的内部状态。</p><p>例如以下组件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="comment">// Demo.vue</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;Kawaii&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&#x27;val&#x27;</span>],</span></span><br><span class="line">    render (h) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">          &#123; <span class="built_in">this</span>.val &#125;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在 App.vue 里引用的话:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Demo</span> <span class="attr">val</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">&#x27;./components/Demo&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;app&#x27;</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    Demo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么可以在 chrome 的调试界面可以看到:</p><p><img src="https://i.loli.net/2018/04/11/5acd8954c11de.png"></p><p>其中 <code>Kawaii</code> 就是刚才起了名字的组件，如果将其改名为 <code>看不见看不见</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="comment">// Demo.vue</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;看不见看不见&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ...</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么在 chrome 界面则可以直接看到其显示名字就变为 <code>看不见看不见</code> 了。</p><p><img src="https://i.loli.net/2018/04/11/5acd895501f79.png"></p><p>但如果不设置名字，那么 Vue.js 默认会用 tag 名称，也就是这个组件在 <code>template</code> 或者 <code>jsx</code> 里的名字。比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="comment">// Demo.vue</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不设置名字</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// name: &#x27;看不见看不见&#x27;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// ...</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">D</span> <span class="attr">val</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">&#x27;./components/Demo&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;app&#x27;</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="javascript">    <span class="string">&#x27;D&#x27;</span>: Demo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么此时就会显示为 <code>D</code>:</p><p><img src="https://i.loli.net/2018/04/11/5acd895531d51.png"></p><blockquote><p>Note: functional 组件不会显示在 devtools 中，因为 vue 并不会为 functional component 创建实例</p></blockquote><h1 id="递归应用"><a href="#递归应用" class="headerlink" title="递归应用"></a>递归应用</h1><p>在有些时候，我们可以会递归使用自身组件，比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; val &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">Recursive</span> <span class="attr">v-if</span>=<span class="string">&quot;val&quot;</span> <span class="attr">:val</span>=<span class="string">&quot;val - 1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Recursive.vue</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;Recursive&#x27;</span>,</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      val: &#123;</span><br><span class="line"><span class="javascript">        required: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span>: <span class="number">5</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，如果不设置 name，那么 console 就会报错，提示在 Recursive.vue 中找不到名为 <code>Recursive</code> 的组件。因此，如果想要递归应用自身组件的话，就必须设置 name 属性。</p><h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><p>keep-alive 是 Vue 内置的组件，可以将 keep-alive 的子组件运行缓存，用于保存切换 (例如 v-if 的切换) 过程前的状态。</p><p>而 keep-alive 有两个 props 是 <code>include</code> 以及 <code>exclude</code>。前者指明需要缓存的组件的名字。而后者则指明不需要缓存的组件的名字。</p><p>下述例子中，Foo, Bar 两个组件的名字分别为 <code>vue-foo</code>, <code>vue-bar</code>, 且组件均包含一个 input。因为通过 input 可以很轻松的观察到切换前后的状态是否有保存:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; val &#125;&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;m&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Foo.vue</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;vue-foo&#x27;</span>,</span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        val: <span class="string">&#x27;vue-foo&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        m: <span class="string">&#x27;vue-foo&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Bar.vue 跟 Foo.vue 内容几乎一样，除了名字，因此这里就不贴 Bar.vue 的代码了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;vue-foo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Foo</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Bar</span> <span class="attr">v-else</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> @<span class="attr">click</span>=<span class="string">&quot;visible = !visible&quot;</span>&gt;</span></span><br><span class="line">      Visible &#123;&#123; visible &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&#x27;./components/Foo&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&#x27;./components/Bar&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;app&#x27;</span>,</span></span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      visible: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过点击 button 来切换。因为设置了 <code>include</code> 指令，那么只有 <code>Foo</code> 的状态才会被保存:</p><p><img src="https://i.loli.net/2018/04/11/5acd8955d055b.gif"></p><p>通过这张效果图可以看到，在切换过程中，<code>Foo</code> 的状态被保存了，而 <code>Bar</code> 则没有，而是重新生成。</p><p>如果使用 <code>exclude</code> 指令:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;vue-foo&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Foo</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Bar</span> <span class="attr">v-else</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> @<span class="attr">click</span>=<span class="string">&quot;visible = !visible&quot;</span>&gt;</span></span><br><span class="line">      Visible &#123;&#123; visible &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么就会得到一个完全相反的结果: 即 <code>Bar</code> 的状态被保存了，而 <code>Foo</code> 则没有，而是重新生成。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://vuejs.org/v2/api/#keep-alive">api/#keep-alive</a></li><li><a href="https://vuejs.org/v2/api/#name">api/#name</a></li><li><a href="https://github.com/vuejs/vue-devtools/issues/280">vue-devtools/issues/280</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;无论是通过 &lt;code&gt;Vue.component&lt;/code&gt; 的方式，还是在写 &lt;code&gt;.vue&lt;/code&gt; 文件的方式，官方都会推荐你写一个 &lt;code&gt;name&lt;/code&gt; 属性。但是好像这个 name 在渲染时又几乎用不到，那么它实际能干嘛呢?&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>用 vue 写一个单页的 hexo 主题</title>
    <link href="https://lazzzis.moe/post/hexo-theme-of-spa-in-vue/"/>
    <id>https://lazzzis.moe/post/hexo-theme-of-spa-in-vue/</id>
    <published>2018-04-06T04:51:32.000Z</published>
    <updated>2018-05-27T03:49:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2018 年 5 月 5 日更新:</strong> 因为我突然发现如果采用单页的话，就很难处理 SEO 的问题，所以我现在已经基本不再考虑在 hexo 的基础上考虑这个主题。所以我现在也已经在使用别的主题。在未来，我会考虑采用 <a href="https://vuepress.vuejs.org/">vuepress</a> 或者 <a href="https://github.com/egojump/peco">peco</a> 搭建我的博客。</p><hr><p>大概一年以前，我发布过一个主题，名为 <a href="https://github.com/lazzzis/hexo-theme-mls">hexo-theme-mls</a>。这个主题是我当时在学完如何写一个 hexo 主题后完成的。后来在学了 vue 之后，构思着再写一个主题。我非常想把它写成一个单页应用，可是一直没有思绪。直到后来看到了 <a href="https://github.com/EYHN/hexo-theme-one">hexo-theme-one</a>，我才有了思绪，于是开始写一个单页的主题。</p><a id="more"></a><h1 id="restful"><a href="#restful" class="headerlink" title="restful"></a>restful</h1><p>首先一个问题就是，如何生成 json 文件，用于前端的异步数据请求。<a href="https://github.com/yscoder/hexo-generator-restful">hexo-generator-restful</a> 提供了很好的思路，hexo 在执行的时候，会载入主题文件夹下的 scripts 下的文件并执行。而 hexo 提供了一个接口，可以用于在读取所有博客内容之后，生成所有文件之前，添加需要生成的文件。</p><p><a href="https://hexo.io/api/generator.html">generator</a> 接口即是需要的接口。注册一个函数，这个函数可以在执行完后返回一个数组，数组每一个元素即是一个将要生成的文件的信息，这个信息包括:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: post.path, <span class="comment">// 路径</span></span><br><span class="line">    data: post, <span class="comment">// 这个文件的内容</span></span><br><span class="line">    layout: <span class="string">&#x27;post&#x27;</span> <span class="comment">// 布局</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般文件生成后会在 public 文件夹下，那么这个路径只要是相对 public 即可，比如 <code>api/posts.json</code>，则会在 <code>public/api/posts.json</code>。至于文件内容，因为这个 data 一般要求是字符串或流 (stream)，所以我选择用 JSON.stringify() 将需要的数据 (对象) 转化为字符串。</p><h2 id="那么最终需要生成哪些-json-文件呢"><a href="#那么最终需要生成哪些-json-文件呢" class="headerlink" title="那么最终需要生成哪些 json 文件呢?"></a>那么最终需要生成哪些 json 文件呢?</h2><h3 id="所有的-posts-数据"><a href="#所有的-posts-数据" class="headerlink" title="所有的 posts 数据"></a>所有的 posts 数据</h3><p>一个 <code>posts.json</code> 记录了这个博客所有的博客大概信息 (每篇博客的标题，包含的标签，发布日期等)，但不包含博客文章的具体内容，因为如果将所有文章内容放进一个文件的话，那么这个文件可能非常大。因而，准备再生成一个 <code>post/</code> 文件夹，下面存放了各个博客文章的具体信息。如果一篇博文标题为 <code>Foo</code>。那么请求 <code>api/post/Foo.json</code> 可以拿到这篇博文的具体信息。</p><h3 id="所有的-tags-数据"><a href="#所有的-tags-数据" class="headerlink" title="所有的 tags 数据"></a>所有的 tags 数据</h3><p>类似于 posts 数据，一个 <code>tags</code> 用于说明这个博文下所有的 tag，一个 <code>tag/</code> 文件夹包含每一个 tag 的具体信息（这个 tag 下有哪一些文章）。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>一些配置信息，比如 siteConfig，和 themeConfig。另外如果有自定义 page 的话，再放一些信息于 <code>page/</code> 文件夹下。</p><h1 id="404-处理"><a href="#404-处理" class="headerlink" title="404 处理"></a>404 处理</h1><p>这个是我当时最头疼的一个问题，毕竟 hexo 当初又不是为单页设计的，估计也考虑不到这个问题。</p><p>我有一个路由是 <code>/posts</code>。但在 <code>hexo g</code> 运行完后，在 <code>public</code> 目录下面是没有 <code>posts/index.html</code> 这个文件的。因此如果运行 <code>hexo s</code> 的时候，如果直接访问 <code>localhost:4000</code>。那么 hexo 会直接报错，提示 <code>Can not get /posts</code>。如果要解决这个问题，那么我必须在所有可能的路由下生成 <code>index.html</code>。如果我有 100 个路由，那么我需要生成在 100 个文件夹下生成共计 100 个 <code>index.html</code>。</p><p>可是这很明显不符合我对 <code>SPA</code> 的预期。按照最初的想法，我只需要一个 <code>index.html</code>。无论浏览器访问哪个路由，后端都能返回同一个 <code>index.html</code>。这一点可以参考 <code>vue-router</code> 官网上对 404 重定向的一个说明 – <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html">HTML5 History 模式</a>。</p><p>当然我上面这么说的自然原因是我采用了 <code>HTML5 History</code> 模式。我当然可以选择放弃这种模式，采用 URL hash 的方式。也就是说，我的博客地址会变成 <code>/#/post/foo</code> 的样子。但这里又出现了另外一个问题，disqus 对评论的获取是不考虑 <code>#</code> 之后的内容。换句话说，如果用户访问 <code>/#/post/foo</code> 和 <code>/#/post/bar</code> 时，disqus 都会去拿 <code>/</code> 路由对应的评论，所有的页面评论就全部一样了!</p><p>因此我不得不再继续思考如何采用上 <code>HTML5 History</code> 模式。如果只考虑部署的话，GitHub Pages 有 404 重定向的方式 (建立 404.html) 以及 nginx 也有类似功能。所有在部署之后是不会有这问题，我需要做的，是对 <code>hexo s</code> 的扩充。</p><p><code>hexo</code> 确实开放了对 <code>hexo s</code> 的扩充的接口，结合这个 ISSUE: <a href="https://github.com/hexojs/hexo/issues/1030">https://github.com/hexojs/hexo/issues/1030</a>。我可以在 <code>hexo s</code> 中实现在 404 时的重定向了。但有两种方案:</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一:"></a>方案一:</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.filter.register(<span class="string">&#x27;server_middleware&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">_404middleware</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(<span class="function"><span class="keyword">function</span> <span class="title">handle404</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> s = fs.createReadStream(</span><br><span class="line">      path.resolve(__dirname, <span class="string">&#x27;../../../&#x27;</span>, hexo.config.public_dir, <span class="string">&#x27;./index.html&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">    s.pipe(res)</span><br><span class="line">  &#125;, <span class="number">99</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种方法，就是直接读取生成好的 index.html 返回。这种方案在大部分情况下可行。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二:"></a>方案二:</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.filter.register(<span class="string">&#x27;server_middleware&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">_404middleware</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(<span class="function"><span class="keyword">function</span> <span class="title">handle404</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = url.parse(req.url)</span><br><span class="line">    <span class="keyword">if</span> (!pathname.endsWith(<span class="string">&#x27;.json&#x27;</span>)) &#123;</span><br><span class="line">      res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Location&#x27;</span>: url.resolve(hexo.config.root, <span class="string">&#x27;404.html?redirect=&#x27;</span> + req.url)</span><br><span class="line">      &#125;)</span><br><span class="line">      res.end()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">99</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 99 代表 priority。默认 server 的值为 10。priority 越小越先执行。让默认服务先运行，如果出现 404，那么上面的代码才会执行，进行重定向。注意我增加了一个 <code>redirect</code> 的请求参数，专门用于在前端继续跳转一次。如果不跳转，前端 url 就变成了 <code>/404.html</code>。但我想在当前 URL 下也能显示 404 页面，比如在 <code>/post/xx</code> 页面下显示 404 的内容，而不是跳转到 <code>/404.html</code> 显示。其中注意不要对 <code>json</code> 文件进行处理，仅对一般请求处理即可。</p><p>方案二，和方案一相比，两者都不算美观，并不能说是我最满意的方案。但相比之下，方案二，还好一点，原因是方案一一个明显的问题就是，它的成功运行是基于 public 目录下存在 <code>index.html</code> 的前提下。如果这个前提不满足，那么就无法继续。因此我暂时采用了方案二。</p><h1 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h1><p>上面讲的，其实大多是 hexo 相关内容。至于页面设计就简单多了，因为后端路由已经解决了。前端实际上只是样式的问题。因为当时想做的简单一点，于是才用了 <a href="https://milligram.io/">milligram</a> 这么一个纯 css 的极简框架。</p><p>加上 vue 全家桶，以及 axios 用作异步请求工具，前端开发似乎并没有遇到什么大困难。</p><p>唯一可能算的上问题的或许是字体问题吧。原本字体用的是 google fonts 的链接，而总所周知，这在国内体验很不好，因此花了点时间，把字体从网上下载，并写成 css 引用的方式，打包成为主题的一部分。</p><h1 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h1><p>我考虑过要不要加上多语言支持，也就是 <code>i18n</code>。不过感觉没什么必要，并没有那么多需要翻译的。所以这个坑就先留着吧。</p><p>在我写这篇文章的时候，<a href="https://hexo.io/themes">hexo.io/themes</a> 也有了一些其它单页应用的主题，或许未来应该有更多的吧。可能 hexo 未来会对单页应用的博客做一些相关的支持，也可能会出现一款为单页应用博客而定制的博客生成器吧。</p><p>另外，记得刚把这个发布并用在自己博客上的时候，有伙伴吐槽 “有点丑呀”。或许吧，和其它主题比起来，确实“朴素”了太多。不过不知道为什么，现在的我确实喜欢这样的“朴素”了呢。</p><p>顺便贴一下项目地址，<a href="https://github.com/lazzzis/hexo-theme-only">hexo-theme-only</a>。欢迎使用和提供批评意见。</p><hr><p><img src="https://i.loli.net/2018/05/27/5b0a2ad2e3d1f.png" alt="散华礼弥"><span class="image-caption">散华礼弥</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;2018 年 5 月 5 日更新:&lt;/strong&gt; 因为我突然发现如果采用单页的话，就很难处理 SEO 的问题，所以我现在已经基本不再考虑在 hexo 的基础上考虑这个主题。所以我现在也已经在使用别的主题。在未来，我会考虑采用 &lt;a href=&quot;https://vuepress.vuejs.org/&quot;&gt;vuepress&lt;/a&gt; 或者 &lt;a href=&quot;https://github.com/egojump/peco&quot;&gt;peco&lt;/a&gt; 搭建我的博客。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大概一年以前，我发布过一个主题，名为 &lt;a href=&quot;https://github.com/lazzzis/hexo-theme-mls&quot;&gt;hexo-theme-mls&lt;/a&gt;。这个主题是我当时在学完如何写一个 hexo 主题后完成的。后来在学了 vue 之后，构思着再写一个主题。我非常想把它写成一个单页应用，可是一直没有思绪。直到后来看到了 &lt;a href=&quot;https://github.com/EYHN/hexo-theme-one&quot;&gt;hexo-theme-one&lt;/a&gt;，我才有了思绪，于是开始写一个单页的主题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>联系 Koa.js 和 requests 看 HTTP 协议中的重定向</title>
    <link href="https://lazzzis.moe/post/http-protocol-redirecting/"/>
    <id>https://lazzzis.moe/post/http-protocol-redirecting/</id>
    <published>2018-01-05T00:29:09.000Z</published>
    <updated>2018-04-12T19:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 HTTP 协议中，一般 3 开头的状态码，都用于表示 <code>重定向</code>：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。</p><a id="more"></a><h1 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h1><p>为了告诉客户端应改前往哪一个页面，服务器在返回的响应 (response) 的 headers 中用 <code>Location</code> 字段标明具体应该访问的页面。</p><p>例如，访问 <code>http://example.com</code> 时，如果服务器想让浏览器跳转到 <code>http://google.com</code>，可以在 response 中写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 302 Redirect</span><br><span class="line">Location: http:&#x2F;&#x2F;google.com</span><br></pre></td></tr></table></figure><p>一般浏览器收到后，会自动跳转。</p><p>另外，URL 也可以标明为相对路径，比如，在上个例子中，如果跳转到 <code>http://example.com/hello.html</code>，则可以标记为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 302 Redirect</span><br><span class="line">Location: hello.html</span><br></pre></td></tr></table></figure><h1 id="Koa-js"><a href="#Koa-js" class="headerlink" title="Koa.js"></a>Koa.js</h1><p>在 Koa.js 中，context 有一个方法为 <code>redirect</code>，专门用于定向，而这个方法实际委托给了 <code>lib/response.js</code>。</p><p>其具体代码为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">redirect</span>(<span class="params">url, alt</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// location</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;back&#x27;</span> == url) url = <span class="built_in">this</span>.ctx.get(<span class="string">&#x27;Referrer&#x27;</span>) || alt || <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.set(<span class="string">&#x27;Location&#x27;</span>, url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status</span></span><br><span class="line">  <span class="keyword">if</span> (!statuses.redirect[<span class="built_in">this</span>.status]) <span class="built_in">this</span>.status = <span class="number">302</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// html</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.ctx.accepts(<span class="string">&#x27;html&#x27;</span>)) &#123;</span><br><span class="line">    url = <span class="built_in">escape</span>(url);</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.body = <span class="string">`Redirecting to &lt;a href=&quot;<span class="subst">$&#123;url&#125;</span>&quot;&gt;<span class="subst">$&#123;url&#125;</span>&lt;/a&gt;.`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// text</span></span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.body = <span class="string">`Redirecting to <span class="subst">$&#123;url&#125;</span>.`</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果 URL 为 <code>back</code>，那么会跳转回请求来源的方向，比如你在 <code>http://github.com/lazzzis</code> 点击了 <code>lazzzis.github.io</code>，那么在请求 <code>lazzzis.github.io</code> 的 request 的头部中，字段为 <code>Referrer: http://github.com/lazzzis</code>。换句话说，<code>back</code> 的意思就是 “从哪里来，就回哪里去”。</p><p>而 <code>this.set(&#39;Location&#39;, url)</code> 作用则就是之前说的，将头部 headers 中 <code>Location</code> 设置为客户端应该去访问的那个 URL。之后，便是将状态码设置为 302。</p><p>这边，Koa.js 怕浏览器不会自动跳转，因此将也设置了消息主体部分，通知用户应该跳转。</p><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>接下来用 Python 的 requests 做实验。我们先用 Koa.js 写一个简单的服务端:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> koaLogger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(koaLogger())</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.redirect(<span class="string">&#x27;http://lazzzis.github.io&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>然后发起请求:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&quot;http://localhost:5000&quot;</span>)</span><br><span class="line">print(r.url)</span><br><span class="line"><span class="comment"># http://lazzzis.github.io</span></span><br></pre></td></tr></table></figure><p>可以发现，requests 已经帮我们做了自动跳转。如果不想让它跳转的话，可以设置 <code>allow_redirects</code> 参数（默认为 True）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&quot;http://localhost:5000&quot;</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">print(r.url)</span><br><span class="line"><span class="comment"># http://localhost:5000/</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># Redirecting to &lt;a href=&quot;http://lazzzis.github.io&quot;&gt;http://lazzzis.github.io&lt;/a&gt;.</span></span><br></pre></td></tr></table></figure><p>取消跳转后，可以看到它这次停止了跳转。关于限制跳转的相关源码在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py">requests.py</a> (代码太长，所以就不粘贴了)。</p><p>在 653 行: <code>yield_requests=True</code> 使得在 resolve_redirects 中时，不会进入下一步的 send：在 206 - 225 的分支可以看到， 如果 <code>yield_requests=True</code>，那么 requests 会做接下来的请求。</p><h2 id="获取下一个请求的-URL"><a href="#获取下一个请求的-URL" class="headerlink" title="获取下一个请求的 URL"></a>获取下一个请求的 URL</h2><p>在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py">requests.py</a> 的 98 行的 get_redirect_target 的实现中，<code>location = resp.headers[&#39;location&#39;]</code> 表明了这里的处理和 <code>Koa.js</code> 是一样的，也是从 <code>location</code> 字段获取。</p><h2 id="更改请求方式"><a href="#更改请求方式" class="headerlink" title="更改请求方式"></a>更改请求方式</h2><p>另外，还有一个有意思的事情，我在请求的时候，发的是 <code>POST</code> 请求，可是 GitHub Pages 不支持 POST 的呀，那么 requests 一定换了另一种方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&quot;http://localhost:5000&quot;</span>)</span><br><span class="line">print(r.request.method)</span><br><span class="line"><span class="comment"># GET</span></span><br></pre></td></tr></table></figure><p>看的出来，requests 使其变为了 GET。这里的实现在于: <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py">requests.py</a> 的 164 行 <code>self.rebuild_method(prepared_request, resp)</code> 和 292 行开始的 <code>rebuild_method</code> 的实现。尤其是 304 行和 309 行，将请求方法改为了 <code>GET</code>。</p><h2 id="递归请求"><a href="#递归请求" class="headerlink" title="递归请求"></a>递归请求</h2><p>这里想象两种极端情况。</p><p>一是如果服务端 A 实现出错，使得要求客户端依旧跳到 A。那么，requests 请求 A, 而之后有继续请求 A。这样，陷入了一个死循环。</p><p>第二种，类似，但不只一个服务器出错: A 要求跳转到 B，而 B 要求跳转到 C，可是 C 又要求跳转到 A，那么，这里也同样陷入了一个死循环。</p><p>requests 考虑到了这点，做了限制，避免一直跳转:</p><p>先对上面的服务端做一点修改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.redirect(<span class="string">&#x27;http://localhost:5000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.post(<span class="string">&quot;http://localhost:5000&quot;</span>)</span><br><span class="line"><span class="comment"># requests.exceptions.TooManyRedirects: Exceeded 30 redirects.</span></span><br></pre></td></tr></table></figure><p>python 自定义了一个异常，用于说明引起的原因是过多的重定向，并且说明了 requests 最先跳转次数为 30 次。</p><p>可以看到在 <a href="https://github.com/requests/requests/blob/8982efa9e46172b42c8cf6cdcc1a3f4c75e670ce/requests/sessions.py">requests.py</a> 的第 139 行处，requests 本身记录了请求的历史，如果历史条数，也就是请求的次数，大于限制时会抛出异常。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://shop.oreilly.com/product/9781565925090.do">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections">Redirections in HTTP</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 HTTP 协议中，一般 3 开头的状态码，都用于表示 &lt;code&gt;重定向&lt;/code&gt;：因为某些原因，例如目标网页已经存在其它网站，服务器会通知客户端访问另一个网页。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>2017 -&gt; 2018</title>
    <link href="https://lazzzis.moe/post/the-end-of-2017/"/>
    <id>https://lazzzis.moe/post/the-end-of-2017/</id>
    <published>2017-12-29T22:31:46.000Z</published>
    <updated>2018-04-12T19:41:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一年差不多在这时也写了这么一个年终总结，今年也写一个吧。</p><a id="more"></a><h1 id="之前定的目标实现了么"><a href="#之前定的目标实现了么" class="headerlink" title="之前定的目标实现了么"></a>之前定的目标实现了么</h1><h2 id="有些实现了，尽管很不完美。"><a href="#有些实现了，尽管很不完美。" class="headerlink" title="有些实现了，尽管很不完美。"></a>有些实现了，尽管很不完美。</h2><p>申请学校实际上只申请到了保底校，但最后还是接受了并现在在美帝上学。</p><p>乐理的坑没有填玩，最近才学了大概三个月，学得很慢，毕竟自己以前没有受过什么这方面训练。不过欣慰的是，确实看到自己在成长：在三个月前，我才知道音乐中有音乐的存在，原来音符分为四分音符，八分音符等等，到之后知道了一个高音谱表上各条线和间代表了什么音，在到现在能判断两个音之间的音程和初步了解了常用和弦的构造。对于我来说，这是很大成长了。更重要的是，我对音乐有更包容了 – 以前我的音乐大多集中在 ACG 相关音乐，而现在我也愿意去了解其它音乐 – 名摇，后摇，古典，各种摇滚等。这让我有了更大的视野。</p><h2 id="有些依旧是这样"><a href="#有些依旧是这样" class="headerlink" title="有些依旧是这样"></a>有些依旧是这样</h2><p>记得去年说要了解现实世界与未来，结果现在还是很迷茫，有几次都差点失望了。</p><p>说好的继续学习计算机和英语，实际上并没有太大进步，感觉一直在吃老本。尤其是英语，来了美帝之后反而更差了。。</p><h1 id="我做了什么"><a href="#我做了什么" class="headerlink" title="我做了什么"></a>我做了什么</h1><ul><li>写了十三篇博文</li><li>又写了一个 hexo 主题</li><li>把 Putong OJ 完成并上线了</li><li>来了美帝入学</li><li>入了一把电吉它</li><li>参加了一个漫展</li></ul><p>其中没有参加漫展是去年后悔的事，今年弥补了，也算填了一个坑。</p><p>这些算是映像比较深或花了比较多时间的事了，其它小事就略过了。</p><h1 id="我后悔什么"><a href="#我后悔什么" class="headerlink" title="我后悔什么"></a>我后悔什么</h1><p>很少后悔了，倒不是因为没有做错事，而是做事之前有了心理准备，就算做错了也要学会去接受或者挽救，而不是只会后悔。</p><h1 id="我还要做什么"><a href="#我还要做什么" class="headerlink" title="我还要做什么"></a>我还要做什么</h1><p>其实基本还去年一样，坑没有填完：</p><ul><li>乐理才学了不久，希望不会中途断掉</li><li>想法设法提高自己的英语</li><li>希望不再迷茫吧</li></ul><h1 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h1><p>今年这篇很短，确实没什么好说的。如果要像去年一样给自己评个分，那么在总分 5 分的情况下，我会给自己 1.5 分，因为今年除了一般之外，还没有任何的进步：就像上文说的一样，在吃老本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一年差不多在这时也写了这么一个年终总结，今年也写一个吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP 协议中的 ETag 与 If-None-Match</title>
    <link href="https://lazzzis.moe/post/http-protocol-etag-if-none-match/"/>
    <id>https://lazzzis.moe/post/http-protocol-etag-if-none-match/</id>
    <published>2017-12-29T01:26:57.000Z</published>
    <updated>2018-04-14T05:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。</p><a id="more"></a><p>软件开发常常有版本号的概念，比如 <code>1.0</code>, <code>1.1</code>, <code>2.0</code> 等等。软件使用者通常会在客户端版本落后于服务器最新版本时才会去服务器获取新的软件。</p><p>这一理念也用于了浏览器缓存策略中。结合下面这张图为例，浏览器已经缓存了 <code>foo.jpg</code> 且已记录版本号为<code>1.2</code> (这个版本号由服务器生成并告诉浏览器)，那么当浏览器再次请求 <code>foo.jpg</code> 时，就会同时把版本号也放在请求头中。这样，服务器收到请求时，就知道了客户端已缓存的文件的版本。如果服务器中的 <code>foo.jpg</code> 版本也是 <code>1.2</code>，那么服务器就可以说 <code>304 Not Modified</code>，不用再将 <code>foo.jpg</code> 传给了浏览器，因此就节省了带宽。反之，如果服务器端的 <code>foo.jpg</code> 已经 <code>1.3</code> 了，那么就要将新的文件传给浏览器，也同时告诉它版本号为 <code>1.3</code>，浏览器收到后，缓存文件，并记录版本号为 <code>1.3</code>。</p><p><img src="https://i.loli.net/2017/12/29/5a4566269629e.png"></p><p>ETag 是 Response Header 中的一个字段，而与之对应的一个出现在请求头中的字段为 <code>If-None-Match</code>。<code>If-None-Match</code> 对应的值即为浏览器缓存的的文件的版本号。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>使用 Koa 框架为例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> koaLogger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(koaLogger())</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.get(<span class="string">&#x27;if-none-match&#x27;</span>) &amp;&amp; ctx.get(<span class="string">&#x27;if-none-match&#x27;</span>) === <span class="string">&#x27;foobar&#x27;</span>) &#123;</span><br><span class="line">    ctx.status = <span class="number">304</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.status = <span class="number">200</span></span><br><span class="line">    ctx.type = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    ctx.set(<span class="string">&#x27;etag&#x27;</span>, <span class="string">&#x27;foobar&#x27;</span>)</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>这次我们把它标记为 <code>foobar</code>。注意版本号并不一定要像软件开发的版本号具有语义化，相反它可以是任意字符串，只要确保两个版本间的版本号不一样就行。</p><p><img src="https://i.loli.net/2017/12/29/5a45662a0d0de.png"></p><p>如图，第一次向 <code>localhost:5000/package.json</code> 发起请求，返回头中包含了 <code>etag: foobar</code>。因此是第一次请求，所以请求头之中没有 <code>If-None-Match</code> 字段。</p><p>刷新页面继续请求：</p><p><img src="https://i.loli.net/2017/12/29/5a45662a48d5c.png"></p><p>可以发现，这次请求头中多了 <code>if-none-match</code> 字段，其值就是 <code>foobar</code>。因此这次 <code>foobar</code> 和服务器版本相同，因此可以直接返回 304。</p><p>如果，修改本地服务器版本号，比如改成 <code>package</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.get(<span class="string">&#x27;if-none-match&#x27;</span>) &amp;&amp; ctx.get(<span class="string">&#x27;if-none-match&#x27;</span>) === <span class="string">&#x27;package&#x27;</span>) &#123;</span><br><span class="line">    ctx.status = <span class="number">304</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.status = <span class="number">200</span></span><br><span class="line">    ctx.type = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    ctx.set(<span class="string">&#x27;etag&#x27;</span>, <span class="string">&#x27;package&#x27;</span>)</span><br><span class="line">    ctx.body = fs.createReadStream(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再次请求，</p><p><img src="https://i.loli.net/2017/12/29/5a45662a7925b.png"></p><p>如图，这次因为版本号不同了，所以服务端要再次发送文件，并且通知浏览器更新版本号。</p><h2 id="koa-static-cache"><a href="#koa-static-cache" class="headerlink" title="koa-static-cache"></a>koa-static-cache</h2><p>在 <a href="https://github.com/koajs/static-cache">koa-static-cache</a> 这个包中，也使用了 <code>ETag</code> 策略。</p><p>源码中有这么几行代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.md5) ctx.response.etag = file.md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.fresh)</span><br><span class="line">  <span class="keyword">return</span> ctx.status = <span class="number">304</span></span><br></pre></td></tr></table></figure><p>它的意思其实就是将文件的 <code>md5</code> 值作为版本号，因为文件内容一旦改变，那么它的 <code>md5</code> 也一定随之改变。</p><p>而 <code>ctx.fresh</code> 是 koa 实现的一个属性，可以参考文档 <a href="http://koajs.com/">doc</a>。而这个属性就是根据 If-None-Match / ETag, and If-Modified-Since and Last-Modified 判断缓存是否过期。更具体的，Koa 源码中对 <code>fresh</code> 字段的实现又是使用了 <a href="https://github.com/jshttp/fresh">fresh</a> 这个包，源码中可以观察这几行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-none-match</span></span><br><span class="line">  <span class="keyword">if</span> (noneMatch &amp;&amp; noneMatch !== <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> etag = resHeaders[<span class="string">&#x27;etag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!etag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> etagStale = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> matches = parseTokenList(noneMatch)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matches.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> match = matches[i]</span><br><span class="line">      <span class="keyword">if</span> (match === etag || match === <span class="string">&#x27;W/&#x27;</span> + etag || <span class="string">&#x27;W/&#x27;</span> + match === etag) &#123;</span><br><span class="line">        etagStale = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (etagStale) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实现就是的原理就是比较 <code>if-none-match</code> 和 <code>etag</code> 的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://shop.oreilly.com/product/9781565925090.do">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">MDN ETag</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议中的 URL</title>
    <link href="https://lazzzis.moe/post/http-protocol-url/"/>
    <id>https://lazzzis.moe/post/http-protocol-url/</id>
    <published>2017-12-16T23:22:33.000Z</published>
    <updated>2018-04-12T19:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="URL-概念"><a href="#URL-概念" class="headerlink" title="URL 概念"></a>URL 概念</h1><blockquote><p>全称 Uniform Resource Locator (统一资源定位符)，是一种 URI (Uniform Resource Identifier, 统一资源标识符)</p></blockquote><h1 id="URL-作用"><a href="#URL-作用" class="headerlink" title="URL 作用"></a>URL 作用</h1><p>主要用于网络资源的定位。换句话说，当你想告诉 Alice 你的服务器上有一个有趣的文件想要分享时，你就可以告诉这个文件对应的 URL。那么 Alice 就可以根据这个 URL 找到你要分享的文件。而目前 URL 更通俗的被称为网址。</p><a id="more"></a><h2 id="URL-诞生前的故事"><a href="#URL-诞生前的故事" class="headerlink" title="URL 诞生前的故事"></a>URL 诞生前的故事</h2><p>想了解 URL 的意义，那你必须要了解一下在 URL 诞生前，人们是怎么找资源的。同样，你要分享一个文件给 Alice。那么你要说: 使用一个 FTP 软件，连接到 ftp.example.com，然后使用用户名 anonymous 和密码 anonymous，接着切换到 doc 目录，再然后转换到 <code>binary mode</code> (二进制模式)，找到名为 <code>story.doc</code> 的文件下载并打开。</p><p>但现在，你知道的，表示成 URL 就是 <code>ftp://ftp.example.com/doc/story.doc</code>。而且就下载而言，大部分浏览器已经具有 FTP 软件的一些功能。因此，URL 使你分享文件更加简单，因为别人更容易找到你想要分享的文件。</p><h1 id="URL-与请求"><a href="#URL-与请求" class="headerlink" title="URL 与请求"></a>URL 与请求</h1><p>URL 常常出现在 HTTP 请求的 start-line，也就是请求的第一行，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;hello.html HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:3000</span><br><span class="line">User-Agent: ...</span><br></pre></td></tr></table></figure><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure><p>依次解释一下</p><h2 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>指代协议类型，告诉浏览器怎么去访问目标资源。常见的有 <code>FTP</code>, <code>HTTP</code>, <code>HTTPS</code>。 注意它是不区分大小写的，因此 <code>http://example.com</code> 与 <code>HTTP://example.com</code> 是完全等价的。</p><h2 id="User-和-password"><a href="#User-和-password" class="headerlink" title="User 和 password"></a>User 和 password</h2><p>某些协议需要密码，<code>FTP</code> 中就有时可以看到，举上面分享文件的例子，加上用户名密码就是 <code>ftp://anonymous:anonymous@ftp.example.com/doc/story.doc</code>。</p><h2 id="host-和-port"><a href="#host-和-port" class="headerlink" title="host 和 port"></a>host 和 port</h2><p>host 可以有两种表现形式，一种是域名，一种是 IP。不过域名只是为了方便记忆，因为在访问目标地址的时候，域名会通过 DNS 服务器解析为 IP。之后再通过寻找目标地址。</p><p>port 就是端口，平时访问网站之所以不用写端口，是因为它在 HTTP 协议中默认为 80 端口。</p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>就是路径了。指代资源的位置，比如 <code>http://example.com/hello.doc</code>。说得就是 <code>hello.doc</code> 在服务器目录的根目录下。路径表示和 Unix 系统中的路径表示很相似，用 <code>/</code> 分隔。</p><p>但是在如今开发中 path 变得有抽象意义了，像上一个例子比较直白告诉你就是 <code>hello.doc</code>。但当今大多数路径并不能表示在服务器目录中的具体位置，而更像是在逻辑关系中的一种层级关系, 比如 <code>http://github.com/lazzzis/Test</code> 当然不是代表：你要的那个资源是在服务器的一个名为 <code>lazzzis</code> 的目录下的一个叫 <code>Test</code> 的文件。</p><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><code>query</code> 的形式以键值对的形式出现，即: <code>key=value</code>，多个键值对之间以 <code>&amp;</code> 分隔。</p><p><code>query</code>，常用于查询，在请求服务器的时候提供更多的额外信息。</p><h2 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h2><p>有时也被称为 <code>anchor</code> / <code>锚点</code>，指示当前文件内容的一个片段，有点类似于书签。</p><p><code>https://github.com/chancejs/chancejs#packages</code>。<code>#packages</code> 表示文件中代表 <code>packages</code> 的那一段，浏览器一般会自动帮你跳转到那一行。</p><p>注意的是，在发送带有 <code>fragment</code> 的请求时，<code>fragment</code> 其实不会包含在 HTTP 请求里。也就是说，服务器接受到的请求消息里并没有 <code>fragment</code> 这一部分。原因是，服务器通常只能把 <code>https://github.com/chancejs/chancejs</code> 代表的整个资源返回，而不能只返回 <code>#packages</code> 代表的那一段。</p><h1 id="字符的一些限制"><a href="#字符的一些限制" class="headerlink" title="字符的一些限制"></a>字符的一些限制</h1><p>通常情况下，HTTP 协议对可以出现在 URL 的字符作出了限制。比如一般你很难看到 URL 有中文或日文，等非英文字母。一般遇到中文等语言的字符，URL 会对其编码，转换成一个 <code>%</code> 开头的字符串。</p><p>如图，虽然我输入的是中文<code>火狐</code>，但 HTTP 请求消息中出现的是已经对其编码。</p><p><img src="https://i.loli.net/2017/12/17/5a3580135e99d.png"></p><p>除了中文字符，空格，斜杠等字符也会被编码，否则会在 URL 中引起歧义。比如 空格被编码为 <code>%20</code></p><h1 id="URL-潜在的问题"><a href="#URL-潜在的问题" class="headerlink" title="URL 潜在的问题"></a>URL 潜在的问题</h1><p>用 URL 表示资源的一个问题就是资源的对应的 URL 变化时，之前的 URL 就没用了。例如，原先用户 alice 的主页是 <code>http://example.com/alice</code>。但 <code>alice</code> 改名了，变成 <code>eve</code>，那么她的主页变成 <code>http://example.com/eve</code>。这时，她的朋友们可能因为仍旧通过 <code>http://example.com/alice</code> 访问她的主页而导致访问失败。</p><p>不过现在有些网站会提示 <code>alice</code> 已经更名为 <code>eve</code>，然后帮助浏览者跳转至 <code>http://example.com/eve</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">统一资源定位符</a></li><li><a href="http://shop.oreilly.com/product/9781565925090.do">HTTP: The Definitive Guide</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages">HTTP Messages</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web">Identifying resources on the Web</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html">关于URL编码</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;URL-概念&quot;&gt;&lt;a href=&quot;#URL-概念&quot; class=&quot;headerlink&quot; title=&quot;URL 概念&quot;&gt;&lt;/a&gt;URL 概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;全称 Uniform Resource Locator (统一资源定位符)，是一种 URI (Uniform Resource Identifier, 统一资源标识符)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;URL-作用&quot;&gt;&lt;a href=&quot;#URL-作用&quot; class=&quot;headerlink&quot; title=&quot;URL 作用&quot;&gt;&lt;/a&gt;URL 作用&lt;/h1&gt;&lt;p&gt;主要用于网络资源的定位。换句话说，当你想告诉 Alice 你的服务器上有一个有趣的文件想要分享时，你就可以告诉这个文件对应的 URL。那么 Alice 就可以根据这个 URL 找到你要分享的文件。而目前 URL 更通俗的被称为网址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTTP" scheme="https://lazzzis.moe/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序 / topological sort</title>
    <link href="https://lazzzis.moe/post/intro-of-topological-sort/"/>
    <id>https://lazzzis.moe/post/intro-of-topological-sort/</id>
    <published>2017-11-23T04:42:24.000Z</published>
    <updated>2018-04-12T21:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png"></p><p>其中, <code>1 -&gt; 3</code> 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。</p><p>而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 <code>[1, 2, 4, 3, 5, 7, 6]</code>。</p><a id="more"></a><h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>一个显然可以得到的观点就是，对于没有依赖的任务，可以直接将其放入所求的序列中， 比如上图中的 <code>[1, 2]</code>。</p><p>那算法的第一步就是找出所有没有被依赖的任务，并将其移除，此时可以得到一个新的图:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo2.png"></p><p>显然又可以发现，又出现了没有依赖的任务 <code>[4]</code>，那我们继续把它放入所求的序列中，并将其移除，得到的新的图:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo3.png"></p><p>此时又得到新的图，而且同样出现了没有依赖的任务，所以继续把它放入序列中，将其移除。。。以此类推，每次移除没有依赖的点，得到新的图，继续移除没有依赖的点，直到所有的点都被移除了。</p><p>我们首先需要用一种数据结构表示一点任务是否有依赖。那我们可以发现，用依赖的数量来表示是否有依赖非常合适。如最开始的图中:</p><p>方块中的数字即表示旁边的任务的依赖数，如果数字为 0 即表示依赖为 0。而当我们把<code>[1, 2]</code> 移除后，相连的 <code>[3, 4]</code> 的依赖数必定会减少，变成如图所示:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo4.png"></p><p>此时任务 4 的依赖数为 0，将其移除后，任务 3 的依赖数变为 0，任务 6 的依赖变为 2。所有下一次又移除 3。</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo5.png"></p><p>而实际上，这里的依赖数有一个更专业的名词叫 <code>入度</code>。如其字面意思一样，对于某个点，有多少箭头指向它。</p><p>主流的实现方法有两种，BFS 和 DFS 。因为我更喜欢 BFS，所以这里用 BFS 解释。其中 Queue 的实现可以参照<a href="https://gist.github.com/lazzzis/e07499c379bf9ec43066cc6c66b091f0">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * numTasks 表示任务的数量，这里假设任务的 id 从 0 ~ numTasks</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * prerequisites 是一个二维数组</span></span><br><span class="line"><span class="comment"> * 例如 [[3, 1], [4, 2], [3, 4]] 表示:</span></span><br><span class="line"><span class="comment"> * 任务 3 必须在任务 1 之后，任务 4 必须在任务 2 之后，任务 3 必须在任务 4 之后</span></span><br><span class="line"><span class="comment"> * 换言之，1 指向 3，2 指向 4，4 指向 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">topo</span> (<span class="params">numTasks, prerequisites</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> indegrees = <span class="keyword">new</span> <span class="built_in">Array</span>(numTasks).fill(<span class="number">0</span>) <span class="comment">// 入度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> links = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: numTasks &#125;).map(<span class="function"><span class="params">_</span> =&gt;</span> [])</span><br><span class="line">  <span class="comment">// 用一个二维数组表示图</span></span><br><span class="line">  <span class="comment">// 比如数组 links[5] = [6, 7] 表示 5 指向 6 与 7</span></span><br><span class="line"></span><br><span class="line">  prerequisites.forEach(<span class="function">(<span class="params">[second, first]</span>) =&gt;</span> &#123;</span><br><span class="line">    indegrees[second]++</span><br><span class="line">    links[first].push(second)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="keyword">const</span> ans = []</span><br><span class="line">  <span class="comment">// 寻找 入度 为 0 的点</span></span><br><span class="line">  ;[...Array(numTasks).keys()].filter(<span class="function"><span class="params">i</span> =&gt;</span> !indegrees[i]).forEach(<span class="function"><span class="params">x</span> =&gt;</span> q.push(x))</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">const</span> top = q.pop()</span><br><span class="line">    ans.push(top)</span><br><span class="line">    <span class="comment">// 移除这个点的对应的边，所以相连的任务的入度都减一</span></span><br><span class="line">    links[top].forEach(<span class="function"><span class="params">x</span> =&gt;</span> indegrees[x]--)</span><br><span class="line">    <span class="comment">// 入度减小的这些任务中是否有入度为 0 的点</span></span><br><span class="line">    links[top].filter(<span class="function"><span class="params">x</span> =&gt;</span> !indegrees[x]).forEach(<span class="function"><span class="params">x</span> =&gt;</span> q.push(x))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>对于此图的运行结果:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo7.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; topo(<span class="number">7</span>, [[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">4</span>], [<span class="number">6</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>假设顶点数为 V，边的数目为 E，时间复杂度上讲，应该为 O(V + E)。</p><p>因为每一个点仅仅被访问一次，而每条边也都会被移除一次。</p><h2 id="存在环"><a href="#存在环" class="headerlink" title="存在环"></a>存在环</h2><p>如果存在环，那么在某个时刻存在入度不为 0 的点，如下图所示:</p><p><img src="https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo6.png"></p><p>这种情况下，一般需要判断最后的序列长度是否为 <code>numTasks</code>。如果不是，则存在环。所以，这个算法也可以用于判断环的存在与否。</p><p>特别注意的是，即使存在环，上述代码中 <code>while (!q.empty())</code> 也不会陷入死循环，原因是 <code>q</code> 包含的是入度为 0 的点，如果不存在了入度为 0 的点，那么就会终止循环。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol><li><a href="https://leetcode.com/problems/course-schedule/description/">LeetCode 207. Course Schedule</a></li><li><a href="https://leetcode.com/problems/course-schedule-ii/description/">LeetCode 210. Course Schedule II</a></li><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285">HDU 1285 确定比赛名次</a></li><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2094">HDU 2094 产生冠军</a></li></ol><h1 id="最后再说几句"><a href="#最后再说几句" class="headerlink" title="最后再说几句"></a>最后再说几句</h1><p>最初这题是一位 FaceBook 的学长给我做 mock interview 出的题目。当时我知道这是拓扑排序，但没想到的是，我因为长期没有做这类题，已经完全忘记了它的具体做法。在当时的情况下，我并没有想起来怎么去做这题。所以说，平时偶尔还是要刷一些已经刷过的题呀。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://en.wikipedia.org/wiki/Topological_sorting">Wiki Topological Sorting</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题描述: 提供一些以数字为 id 的任务(task)，这些任务存在如下图所示的依赖关系:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/lazzzis/lazzzis.github.io/d123b09acd4b911b40cd9dcbfc0a6a5e36844773/projects/images/topo1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中, &lt;code&gt;1 -&amp;gt; 3&lt;/code&gt; 表示任务 3 必须在任务 1 完成之后才能够开始。如上图中，任务 3 必须在任务 1 和任务 4 之后。而任务 4 又必须在任务 2 之后。&lt;/p&gt;
&lt;p&gt;而要求就是, 提供一个序列，要求按照这个序列能够顺利完成所有任务。这里假设每个时刻只能处理一个任务，而且一旦开始处理某个任务，那么你不能中止或切换到其它任务。这个答案可能不唯一。在上图中，一个可能的答案就是 &lt;code&gt;[1, 2, 4, 3, 5, 7, 6]&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ACM" scheme="https://lazzzis.moe/tags/ACM/"/>
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>思考为什么要用工厂模式</title>
    <link href="https://lazzzis.moe/post/why-factory-method-pattern/"/>
    <id>https://lazzzis.moe/post/why-factory-method-pattern/</id>
    <published>2017-11-09T21:01:59.000Z</published>
    <updated>2018-04-12T21:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>以 JavaScript 为例子发表一下我对工厂模式 (Factory Pattern) 的看法</p><p><strong>为什么不直接 new 呢? 我自己写代码直接 new 自己写的类不就好了么?</strong></p><p>这里不得不提一下设计模式的意义。设计模式并不是凭空捏造的，而是长期开发所形成的经验之谈，当然这些经验自然是成功的，被认可的经验，否则设计模式就不会被那么多人认可和推崇了。</p><a id="more"></a><p>设计模式主要针对的是大项目，也就是多个人的项目。A 并不一定知道 B 写了哪些类。通过工厂模式，A 在调用工厂类生产的实例的时候就不用关心 B 实现了哪些类了。</p><p>举例:</p><p>B 写的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create (type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> A()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> B()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> C()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;&#125; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure><p>A 写的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Factory.create(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> bar = Factory.create(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">await</span> foo.excute()</span><br><span class="line"><span class="keyword">await</span> bar.excute()</span><br></pre></td></tr></table></figure><p>如代码所示，A 只要知道返回回来的实例具有 <code>execute</code> 方法就足够了，不用去记住各种类名, 甚至没有感觉到自己拿到的其实是不同的类。同时，因为没有直接使用 <code>new</code> 具体的某个类，所以如果以后要修改类名的话就会简单很多 – 比如要把 <code>A</code> 改名为 <code>Ace</code>，那么只需额外在 <code>Factory</code> 里把 <code>A</code> 改为 <code>Ace</code> 就行了。</p><p><strong>一般什么情况比较适合用工厂模式?</strong></p><p>一般需要根据外界的一些动态环境选择具体实例哪些类，或者说具体选择实例哪个类需要很繁杂的判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create (config) &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.version &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> BasicApp()</span><br><span class="line">        <span class="keyword">if</span> (config.os === <span class="string">&#x27;linux&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> BashApp()</span><br><span class="line">        <span class="keyword">if</span> (config.os === <span class="string">&#x27;windows&#x27;</span> &amp;&amp; config.online) <span class="keyword">return</span> <span class="keyword">new</span> OnlineApp()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> LocalApp()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，如果要决定实例哪个类要许多复杂的判断，那么用工厂模式封装就会轻松很多。需要做判断的事情已经交给了写 <code>Factory</code> 的人，使要实例的开发者也不用去了解判断规则, 并且这在未来修改判断规则提供了便利。</p><p>另外，有些人认为 <code>new</code> 一个具体的实例也是种硬编码。如果在一个项目里太多的地方用 <code>new</code>, 比如 <code>new Foo()</code>。那么 <code>Foo</code> 就与项目的多个地方有了紧密的联系。而为了使联系不那么紧密 (decouple)，将工厂作为两者之间的一个缓冲，使具体的类和需要类的地方被间接地连起来。我个人认为这个有一定道理，在一些大项目上可以考虑，但在小项目中似乎显得没那么必要。因为就算要改名，用 IDE 就可以替换掉几个文件中的所要替换的类名。</p><p><strong>使用工厂模式有什么注意的么?</strong></p><p>其实如上面看到的一样，<code>Factory</code> 返回回来的实例是实现了相同接口 / 功能的，因为这样才能使调用 <code>Factory</code> 的开发者真地只需要关心功能而可以忽略用了自己拿到的是具体什么类。例如，在 Java 之类的语言中，一般有大量的子类是继承了某抽象类，或实现了某接口，以此保证具有同一的方法名。</p><p>如果返回回来的实例有实现功能的不同接口，那么工厂模式的效用将大打折扣。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create (type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> A()</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> B()</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">new</span> C()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="function"><span class="title">output</span>(<span class="params"></span>)</span> &#123;&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="function"><span class="title">echo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;</span><br></pre></td></tr></table></figure><p>如代码所示，虽然 A, B, C 都实现了输出的功能。但是方法名不同，这导致多次调用 Factory 的开发者不得不时时刻刻提醒自己同样是从 Factory 拿到的对象为什么会有不同。这种设计或多或少会带来潜在的 bug。</p><p><strong>什么时候不要用工厂模式?</strong></p><p>设计模式是好东西，但不是万能的，只有特定的场合解决特定的问题。一般来讲，如果你的开发场景中没有出现本文前面所讲的 <em>复杂的实例过程</em> 或 <em>相同的接口</em> 的话，我个人就不建议使用了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/">Learning JavaScript Design Patterns</a></li><li><a href="https://www.zhihu.com/question/24843188">知乎: 工厂设计模式有什么用？</a></li><li><a href="https://www.zhihu.com/question/42975862">知乎: 工厂模式（factory Method）的本质是什么？为什么引入工厂模式</a></li><li><a href="https://stackoverflow.com/questions/69849/factory-pattern-when-to-use-factory-methods">Factory Pattern. When to use factory methods?</a></li><li><a href="https://msdn.microsoft.com/en-us/library/ee817667.aspx">Exploring the Factory Design Pattern</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;以 JavaScript 为例子发表一下我对工厂模式 (Factory Pattern) 的看法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不直接 new 呢? 我自己写代码直接 new 自己写的类不就好了么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里不得不提一下设计模式的意义。设计模式并不是凭空捏造的，而是长期开发所形成的经验之谈，当然这些经验自然是成功的，被认可的经验，否则设计模式就不会被那么多人认可和推崇了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>简单谈谈 Node.js 对 ESM 的几种支持方案</title>
    <link href="https://lazzzis.moe/post/words-on-the-support-of-esm-in-node/"/>
    <id>https://lazzzis.moe/post/words-on-the-support-of-esm-in-node/</id>
    <published>2017-10-18T06:18:10.000Z</published>
    <updated>2018-04-12T21:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。</p><h1 id="主流的方案"><a href="#主流的方案" class="headerlink" title="主流的方案"></a>主流的方案</h1><ol><li>在文件开头添加 <code>&quot;use module&quot;;</code> 或类似字段</li><li>新的文件后缀名，如 <code>.mjs</code></li><li>通过源代码内容自动区分</li><li>在 <code>package.json</code> 指明采用 <code>ESM</code> 的文件</li></ol><a id="more"></a><p>这四个方案都已经满足了一些基本要求:</p><ul><li>对现有的 <code>package</code> (几乎全是 CJS) 不造成影响</li><li>不需要知道 <code>package</code> 采用的是哪种形式就可以直接导入</li></ul><p>在这个基础上，第 2 个方案接受的比较多，而且在当前版本 <code>8.7.0</code> 中，可以通过在命令行中增加 <code>--experimental-modules</code> 运行。<br>比如 <code>node --experimental-modules main.mjs</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;ramda&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>其实我最初想到的也是这种方案, 因为我以前在其它语言中接触过一些类似的做法。</p><p>在一些脚本语言中，会采用类似与 <code>#!foo</code> 这种特殊的注释用于说明执行该脚本的程序，比如 <code>#!/usr/bin/env python3</code>。</p><p>而在 <code>python2</code> 中，也会在文件的开头注释说明该语言的编码形式: <code># -*- coding: &lt;encoding name&gt; -*-</code>，比如 <code># -*- coding: utf-8 -*-</code>。</p><p>既然其它语言有类似做法，那这种方案对 node 来说也行吧？</p><p>虽然这种方式很清晰，不过最后还是被否决了。</p><p>其中一个原因就是用户体验太差了。。。因为未来会是 <code>ESM</code> 的天下，既然是 <code>ESM</code> 的天下，那我为什么还要在每个文件开头写 <code>&quot;use modules&quot;;</code> 这样的代码。虽然现在还好，但这在以后势必会显得十分的冗余。</p><p>另一个原因是一些工具链为了区分不得不需要有一定的 <code>parse</code> 文件的能力。实现这个的成本明显比检测文件后缀名的成本要高的多。</p><p>主要由于以上两点，这个方案被否决了。</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>比起另外的方案，采用新的后缀 <code>.mjs</code>, 这个方案也算一个对程序员友好的方案。因为对于每个文件，只需多一个字母 <code>m</code> 在后缀名上 (<code>.js</code> -&gt; <code>.mjs</code>) 即可采用 <code>ESM</code>。</p><p>同时，不论从实现 <code>node</code> 解释器本身或者相关工具链角度来说，这个方案实现很容易就实现。</p><p>至于缺点，同样也是检测后缀名，很多相关工具仅仅把 <code>.js</code> 认为 <code>JavaScript</code> 文件，遇到 <code>.mjs</code> 可能就不认识了。</p><p>不过考虑到最近 <code>JavaScript</code> 相关后缀名不断增多，比如近几年出现的 <code>.jsx</code>, <code>.ts</code>。再增加一个 <code>.mjs</code> 似乎也没什么问题吧。<code>ヘ(￣ー￣ヘ)</code></p><p>另外，为什么采用 <code>.mjs</code> 而不是 <code>.es</code>, <code>.m.js</code> 呢？据了解，在可能想到的后缀名里，<code>.mjs</code> 和现有其它软件的后缀名的冲突最小。</p><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>这个方案最直接了，如果可以。我当然愿意接受这种方案：全部交给 <code>node</code> 自动根据源码判断，比如有 <code>import</code> 就认为是 <code>ESM</code>，有 <code>require</code> 就认为是 <code>CJS</code>。</p><p>不过这个实现起来却非常困难。因为 <code>node</code> 源码开发者们不得不对现有 <code>parsing API</code> 进行更改，改进。这个的改动量是巨大的。而且，就算实现了，因为每次都需要对源码内容解析，可能会对性能产生潜在的影响，尤其是在分析大文件的时候。所以由于这个明显的缺点，这个方案也被否决了。</p><h1 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h1><p>这个方案的好处，就是不用对采用 <code>ESM</code> 的文件做任何修改就能辨认出是 <code>ESM</code>。</p><p>不过说实话，这个一听就对开发者有点不友好。要把所有 ESM 都指明，似乎有点累呀。</p><p>比如这样子:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;lib/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;old/index.js&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// files:</span></span><br><span class="line">  <span class="attr">&quot;modules&quot;</span>: [<span class="string">&quot;lib/hello.js&quot;</span>, <span class="string">&quot;bin/hello.js&quot;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// directories:</span></span><br><span class="line">  <span class="attr">&quot;modules&quot;</span>: [<span class="string">&quot;lib&quot;</span>, <span class="string">&quot;bin&quot;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// files and directories:</span></span><br><span class="line">  <span class="attr">&quot;modules&quot;</span>: [<span class="string">&quot;lib&quot;</span>, <span class="string">&quot;bin&quot;</span>, <span class="string">&quot;special.js&quot;</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if package never uses CJS Modules</span></span><br><span class="line">  <span class="attr">&quot;modules&quot;</span>: [<span class="string">&quot;.&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个比较实在的问题，就是如果要运行 <code>ESM</code> 的文件的话，那岂不是要把 js 文件和 package.json 一起使用？也就是说，单个 <code>ESM</code> 文件是不是不能运行。</p><p>同样这个对现有的某些工具链不友好，需要阅读 <code>package.json</code> 才能确定是不是 <code>ESM</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的而言，虽然方案二有些缺点，但确实是方案二更优一点。另外，有一篇对方案四的<a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md">正名</a>文章，值得读一读。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/nodejs/node/wiki/ES6-Module-Detection-in-Node">ES6 Module Detection in Node</a></li><li><a href="http://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a></li><li><a href="https://github.com/bmeck/node-eps/blob/es6-module/002-es6-modules.md#es-consuming-commonjs">node-eps</a></li><li><a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md">defense-of-dot-js</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。&lt;/p&gt;
&lt;h1 id=&quot;主流的方案&quot;&gt;&lt;a href=&quot;#主流的方案&quot; class=&quot;headerlink&quot; title=&quot;主流的方案&quot;&gt;&lt;/a&gt;主流的方案&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在文件开头添加 &lt;code&gt;&amp;quot;use module&amp;quot;;&lt;/code&gt; 或类似字段&lt;/li&gt;
&lt;li&gt;新的文件后缀名，如 &lt;code&gt;.mjs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过源代码内容自动区分&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;package.json&lt;/code&gt; 指明采用 &lt;code&gt;ESM&lt;/code&gt; 的文件&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>借助 Proxy 实现一个 DefaultDict</title>
    <link href="https://lazzzis.moe/post/defaultdict-in-js/"/>
    <id>https://lazzzis.moe/post/defaultdict-in-js/</id>
    <published>2017-10-01T05:44:12.000Z</published>
    <updated>2018-04-12T21:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里的 <code>DefaultDict</code> 指的是类似于 Python 中的 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict"><code>defaultdict</code></a> 的一种类。其基本特点就是当某个属性不存在于该对象中时，该对象会自动为这个属性创建一个默认值。这个默认值是由用户在创建 <code>DefaultDict</code> 时指定的。</p><p>举个例子，现在需要一个对象，如果某个属性不在这个对象时，在为这个属性赋值为 0.</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;please&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> defaultDict = defaultDictFactory(&#123;&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">    defaultDict[word]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(defaultDict)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; hello: 3,</span></span><br><span class="line"><span class="comment">  world: 2,</span></span><br><span class="line"><span class="comment">  please: 2,</span></span><br><span class="line"><span class="comment">  say: 4&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个例子其实就是非常简单的一个统计单词数量的一个例子，如果不使用 <code>defaultDict</code>, 那么估计就会这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;please&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> defaultDict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">    defaultDict[word] = defaultDict[word] == <span class="literal">null</span> ? <span class="number">1</span> : defaultDict[word] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得那个更美观或实用一点呢？ 这个其实见仁见智，至少前者确实带来了一些便利。</p><p>回到正题，这里开始讲怎么去实现它。</p><h1 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h1><p>实现的方法很多，不一定必须要 <code>Proxy</code> 对象，但它最为 ES6 推出的一个类，有必要去尝试一下。简单的说，<code>Proxy</code> 可以改变对象的一些默认行为，包括增删改查。</p><p>举个例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, prop)</span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; foo: 1 &#125; &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可见，<code>Proxy</code> 对对象属性的获取进行了一点修改。在这里 <code>obj.foo = 1</code>  不属于对 <code>foo</code> 属性的获取，而是对 <code>foo</code> 属性的赋值(set)，所以在执行 <code>obj.foo = 1</code> 时，<code>get: function (target, prop) &#123; ... &#125;</code> 并没有被执行。</p><p>更多的可以参考 <a href="http://es6.ruanyifeng.com/#docs/proxy">ECMAScript 6 入门: Proxy</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里先定义个 <code>handler</code>，也就是对对象的属性获取进行拦截。那么这里需要思考，需要哪些参数呢？</p><p>首先一个，如何确认默认值，那么默认值的产生需要用户定义。所以我们需要一个 <code>defaultFactory</code> 函数用于生成默认值，这里使用了函数，为了有更多的可操作空间。</p><p>另外，如何判断一个属性在不在这个对象中呢？大部分用 <code>&#39;foo&#39; in obj</code> 判断，但极少时候用其它方式。所以这里就设置一个默认操作，如果用户没有指定，我们就用 <code>in</code> 操作符判断属性是否存在。</p><p>这么到这里可以基本实现了 <code>defaultDict</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultDictFactory</span> (<span class="params">initials, defaultFactory, validator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (validator == <span class="literal">null</span>) &#123;</span><br><span class="line">    validator = <span class="function">(<span class="params">prop, object</span>) =&gt;</span> prop <span class="keyword">in</span> object</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(initials, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!validator(prop, target)) &#123;</span><br><span class="line">        target[prop] = defaultFactory(target, prop)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>defaultDictFactory</code> 作为一个工厂函数，专门生产 <code>defaultDict</code>。本来我想用 <code>class</code> 实现，不过遇到了瓶颈，所以改为工厂模式。<br><code>initials</code> 为初始对象，因为用户或许会将一个非空对象转化为 <code>defaultDict</code>。<br><code>defaultFactory</code> 函数用于生产默认值。<br><code>validator</code> 判断属性是否存在，可以有用户自定义判断属性是否存在的规则。</p><p>但为了安全起见，可以加一些对参数的检查。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultDictFactory</span> (<span class="params">initials, defaultFactory, validator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (defaultFactory == <span class="literal">null</span> || <span class="keyword">typeof</span> defaultFactory !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`defaultFactory must be a function`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (validator != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> validator !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`validator must be a function`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (validator == <span class="literal">null</span>) &#123;</span><br><span class="line">    validator = <span class="function">(<span class="params">prop, object</span>) =&gt;</span> prop <span class="keyword">in</span> object</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(initials, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, prop</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!validator(prop, target)) &#123;</span><br><span class="line">        target[prop] = defaultFactory(prop, target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子基本就完成了 <code>defaultDictFactory</code> 的定义。</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>这里还是以统计单词为例，增加 1 个要求: 单词的默认值为单词的长度</p><p>那么只需要设置 <code>defaultFactory</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;please&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;say&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> defaultDict = defaultDictFactory(&#123;&#125;, <span class="function">(<span class="params">prop</span>) =&gt;</span> prop.length)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">of</span> words) &#123;</span><br><span class="line">  defaultDict[word]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(defaultDict))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[ [ &#x27;hello&#x27;, 7 ], [ &#x27;world&#x27;, 6 ], [ &#x27;please&#x27;, 7 ], [ &#x27;say&#x27;, 6 ] ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>建立 <code>defaultDict</code> 的最初想法一方面来自于 Python 的 <a href="https://docs.python.org/3/library/collections.html#collections.defaultdict"><code>defaultdict</code></a>，因为这确实挺方便的。另一方面则来自于对平时刷题时经常遇到的 <code>obj.foo = obj.foo == null ? 1 : obj.foo + 1</code> 的这种写法觉得不美观的写法，所以试图改变一下。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://gist.github.com/thomasboyt/5987633">http://es6.ruanyifeng.com/#docs/proxy</a></li><li><a href="https://gist.github.com/thomasboyt/5987633">https://gist.github.com/thomasboyt/5987633</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里的 &lt;code&gt;DefaultDict&lt;/code&gt; 指的是类似于 Python 中的 &lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.defaultdict&quot;&gt;&lt;code&gt;defaultdict&lt;/code&gt;&lt;/a&gt; 的一种类。其基本特点就是当某个属性不存在于该对象中时，该对象会自动为这个属性创建一个默认值。这个默认值是由用户在创建 &lt;code&gt;DefaultDict&lt;/code&gt; 时指定的。&lt;/p&gt;
&lt;p&gt;举个例子，现在需要一个对象，如果某个属性不在这个对象时，在为这个属性赋值为 0.&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>node-thunkify 的实现及源码阅读</title>
    <link href="https://lazzzis.moe/post/source-code-of-thunkify/"/>
    <id>https://lazzzis.moe/post/source-code-of-thunkify/</id>
    <published>2017-06-29T22:52:32.000Z</published>
    <updated>2018-04-12T21:44:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了些项目的源码，其中就包括 <code>thunkify</code>。虽然 <code>thunkify</code> 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 <a href="https://github.com/tj/node-thunkify/tree/0bd83e29df1bb0653230724f072cff96b0ab684e">0bd83e</a>。</p><h1 id="功能陈述"><a href="#功能陈述" class="headerlink" title="功能陈述"></a>功能陈述</h1><p>将一个函数转换为一个为 Thunk 函数，这个函数被调用后会返回一个以回调函数为参数的函数。可以参考 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0">Thunk 函数</a>。</p><a id="more"></a><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><p>因为需求比较简单，所以我自己先实现了一下，然后比较与官方仓库的差异，可以发现一些源码的特点。呢</p><p>我自己的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      fn(...args, callback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从测试看问题"><a href="#从测试看问题" class="headerlink" title="从测试看问题"></a>从测试看问题</h2><p>源码有 test 文件，可以将源码的测试文件 clone 到本地后测试。将上面的代码测试后可以发现 3 个测试未通过:</p><ol><li>thunkify(fn) should maintain the receiver</li><li>thunkify(fn) should catch errors</li><li>thunkify(fn) should ignore multiple callbacks</li></ol><h3 id="maintain-the-receiver"><a href="#maintain-the-receiver" class="headerlink" title="maintain the receiver"></a>maintain the receiver</h3><p>通过 test 文件代码发现，这里主要涉及到一个关于 <code>this</code> 的问题:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn(<span class="literal">null</span>, <span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    name: <span class="string">&#x27;tobi&#x27;</span>,</span><br><span class="line">    load: thunkify(load)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.load()(<span class="function"><span class="keyword">function</span> (<span class="params">err, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> done(err)</span><br><span class="line">    assert(name === <span class="string">&#x27;tobi&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原函数 f 可能是某个对象的方法，所以要保证 thunkify 后的函数，称它为 tf, 仍然能正常访问 <code>this</code> ，所以 tf 函数里需要能引用到原函数 f 里 <code>this</code> 的值，<code>thunkify</code> 源码中用 <code>ctx</code> 变量对其表示原函数 f 的 <code>this</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">this</span>; <span class="comment">// line 27</span></span><br><span class="line">fn.apply(ctx, args); <span class="comment">// line 43</span></span><br></pre></td></tr></table></figure><h3 id="catch-errors"><a href="#catch-errors" class="headerlink" title="catch errors"></a>catch errors</h3><p>尽管原函数 f 是需要一个回调函数做参数，理论上这个回调函数应该能捕捉异常了，但有些时候，这个回调函数可能没有正常 catch，例如测试文件中的样例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 作为回调函数却没有捕捉这个异常</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;boom&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load = thunkify(load)</span><br><span class="line"></span><br><span class="line">load()(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    assert(err)</span><br><span class="line">    assert(err.message === <span class="string">&#x27;boom&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而 thunkify 则 “帮” 其捕捉了。当发现原函数 f 抛出异常时，源码中自动用用户传进的回调函数捕捉了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line 42 - 47</span></span><br><span class="line"><span class="comment">// done 代表用户传进的回调函数</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fn.apply(ctx, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  done(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ignore-multiple-callbacks"><a href="#ignore-multiple-callbacks" class="headerlink" title="ignore multiple callbacks"></a>ignore multiple callbacks</h3><p>理论上讲，一个回调函数 callback 只能被调用一次，但在实际情况中，仍然会存在被调用多次的意外情况，例如测试文件中的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line">    fn(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">    fn(<span class="literal">null</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load = thunkify(load)</span><br><span class="line"></span><br><span class="line">load()(done)</span><br></pre></td></tr></table></figure><p>为了确保回调函数 callback 只被调用了一次，<code>thunkify</code> 对回调函数进行了一次封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line 34 - 40</span></span><br><span class="line"><span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>called</code> 作为一个 flag，第一次调用时，if 语句会把 called 当作否定值，所以 <code>return</code> 不会被执行。但从第二次开始，<code>called</code> 都会变成 <code>true</code>，所以 <code>return</code> 都会执行，确保了回调函数 callback 只会被调用一次。</p><p>这里需要注意一下 <code>args</code> 这个变量，它每次都会 <code>push</code> 一下，因为 <code>thunkify</code> 后的函数 tf 可能被引用调用多次:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">  done(<span class="literal">null</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tf = thunkify(fn)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1, c2, c3</span><br><span class="line">c1 = c2 = c3 = <span class="function">(<span class="params">err, value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)</span><br><span class="line"></span><br><span class="line">tf(c1)</span><br><span class="line">tf(c2)</span><br><span class="line">tf(c3)</span><br></pre></td></tr></table></figure><p>这个程序最后只会输出一次值。因为根据闭包规则，第二次调用 tf 开始，回调函数就被 <code>push</code> 进 <code>args</code> 里了。当第三次调用 tf 时，此时的 args 等价为 <code>[c1, c2, c3]</code>，根据源码， <code>tf(c3)</code> 相当于调用 <code>tf.apply(ctx, [c1, c2, c3])</code>。所以此时真正执行的回调是 <code>c1</code>，如前文所说，这个 <code>c1</code> 是被源码封装过的，里面的内容只会被执行一次。</p><h3 id="自己的实现（改进后）"><a href="#自己的实现（改进后）" class="headerlink" title="自己的实现（改进后）"></a>自己的实现（改进后）</h3><p>结合 ES6，自己在解决上述问题后又实现了一遍，功能上没有改变，全是增加鲁棒性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  assert(<span class="string">&#x27;function&#x27;</span> === <span class="keyword">typeof</span> fn, <span class="string">&#x27;function required&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="built_in">this</span> <span class="comment">// fix test &#x27;should maintain the receiver&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> refinedCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> first = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!first) <span class="keyword">return</span></span><br><span class="line">          first = <span class="literal">false</span></span><br><span class="line">          callback(...args)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      args.push(refinedCallback(callback))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.call(ctx, ...args)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        callback(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从-Commit-看改进"><a href="#从-Commit-看改进" class="headerlink" title="从 Commit 看改进"></a>从 Commit 看改进</h2><p>查看各个 commit，以及以前的代码，可以发现一些有趣的事。</p><h3 id="crankshaft"><a href="#crankshaft" class="headerlink" title="crankshaft"></a>crankshaft</h3><p>在 <a href="https://github.com/tj/node-thunkify/commit/d537460eb23e3d556c4f726eb04bef189dd3994f">d53746</a> 这个 commit 中，提交者改变了 arguments 变成了数组的方式，从简单的 slice 方法，变成了声明一个数组然后一一赋值的方法。</p><p>第一次看到 <code>crankshaft</code> 还不知道是什么，后来才知道是指代 Chrome 的一个引擎。<a href="https://github.com/tj/node-thunkify/pull/12">Pull request #12</a> 有提到这个优化，虽然我还是觉得这个优化在某种程度牺牲了部分可读性。</p><h3 id="remove-memoization"><a href="#remove-memoization" class="headerlink" title="remove memoization"></a>remove memoization</h3><p>参考 <a href="https://github.com/tj/node-thunkify/commit/30f25adebf79f4793fd5c8b6f873d5e093dfaf6d">30f25a</a> 移除了一个记忆化操作。</p><p>在这个版本之前的代码，如果执行下面的程序，会发现这三次执行都输出同样的结果，这多多少少有点反直觉，所以 commit 上 tj 也说 <code>promises have different expectations</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">  done(<span class="literal">null</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dtn = thunkify(fn)()</span><br><span class="line"></span><br><span class="line">dtn(<span class="function">(<span class="params">err, value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">dtn(<span class="function">(<span class="params">err, value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">dtn(<span class="function">(<span class="params">err, value</span>) =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure><p>所以这个改进后，执行上述程序只会输出一次结果。</p><h3 id="add-assert-fn"><a href="#add-assert-fn" class="headerlink" title="add assert(fn)"></a>add assert(fn)</h3><p>在 <a href="https://github.com/tj/node-thunkify/commit/05abda9cba45b8669caebbeab4fbe5f4a666336b">05abda</a> 处增加了一个 assert 调用避免被 thunkify 的参数不是函数 – 一个提高函数鲁棒性的功能。</p><h3 id="remove-support-for-eager-execution"><a href="#remove-support-for-eager-execution" class="headerlink" title="remove support for eager execution"></a>remove support for eager execution</h3><p><a href="https://github.com/tj/node-thunkify/commit/a504b918a93d04aaa62f467ae7213a25f47d0f69">a504b9</a> 算一次比较大的改进，发现这个 commit 大大缩减了代码。不过这次删去了避免回调函数被多次执行的代码，也就是对回调函数的封装。在这之后的几个 commit 里，维护者又把这一层封装添加了回去。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在没有看过 <code>thunkify</code> 源码的情况下，这个功能的实现并不算难。但 <code>thunkify</code> 代码比在本文开始我自己写的代码更优秀的地方就在于代码的鲁棒性，这一点从测试文件和 commit 日志中可见一斑，确实考虑了生产环境中可能出现的众多复杂情况，更适合日常使用。同时，阅读 <code>thunkify</code> 源码的目的也并不限于代码的实现，更多的是学习维护和增加代码的鲁棒性。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://es6.ruanyifeng.com/#docs/generator-async">Generator 函数的异步应用</a></li><li><a href="https://blog.daraw.cn/2016/11/11/notes-about-node-thunkify/">node-thunkify源码阅读笔记</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了些项目的源码，其中就包括 &lt;code&gt;thunkify&lt;/code&gt;。虽然 &lt;code&gt;thunkify&lt;/code&gt; 代码简单，很快就读完了，不过看看项目的测试文件和提交历史，也还是能看出很多事物的。这次阅读的代码是当前最新版本，commit 编号 &lt;a href=&quot;https://github.com/tj/node-thunkify/tree/0bd83e29df1bb0653230724f072cff96b0ab684e&quot;&gt;0bd83e&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;功能陈述&quot;&gt;&lt;a href=&quot;#功能陈述&quot; class=&quot;headerlink&quot; title=&quot;功能陈述&quot;&gt;&lt;/a&gt;功能陈述&lt;/h1&gt;&lt;p&gt;将一个函数转换为一个为 Thunk 函数，这个函数被调用后会返回一个以回调函数为参数的函数。可以参考 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0&quot;&gt;Thunk 函数&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>终于完成了一个 OJ -- Putong OJ</title>
    <link href="https://lazzzis.moe/post/notes-of-putongoj/"/>
    <id>https://lazzzis.moe/post/notes-of-putongoj/</id>
    <published>2017-06-02T06:53:12.000Z</published>
    <updated>2018-05-05T21:57:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Putong OJ</strong> – 一个看上去很普通的 Online Judge，现已<a href="http://acm.cjlu.edu.cn/">上线</a></p><h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><p>说一些我自认为可以称得上特性的”特性”</p><h2 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h2><p>估计现在没有一个 OJ 采用的是单页应用吧。</p><a id="more"></a><p>其实最初开发单页应用的一个初衷是尽可能减轻服务器的压力，因为学校的服务器不是很好，这一点我后面还会说明。所以我觉得相比于后端渲染，前端渲染能减轻服务器压力。</p><p>另外，采用单页应用，那么后端就可以采用 restful 设计，后端的编写压力就减少了不少。前端方面因为采用的是 Vue 作为框架，开发上相对简单点，毕竟 vue 的学习难度比 react 要小一点，而且现在与 vue 相关的现成组件也不少，因此 <del>偷懒</del> 短期开发也是相对比较简单的。而且，我一个毕业狗，考虑到未来学弟学妹的维护难度，或许选择 vue 会好一点吧。</p><h2 id="Koa-v2-Restful"><a href="#Koa-v2-Restful" class="headerlink" title="Koa v2 + Restful"></a>Koa v2 + Restful</h2><p>后端上采用了 Node.js，而且采用了 koa v2 框架，摆脱了 callback hell，并且用上 <code>async / await</code>，因此在代码编写给人的快感自然要大于 Express。并且摆脱了后端渲染，restful 的后端框架说实话真的轻松了不少。</p><h2 id="干死-IE8"><a href="#干死-IE8" class="headerlink" title="干死 IE8"></a>干死 IE8</h2><p>在这里我还是 <strong>激进</strong> 了一点。保守一点说，现在大学内有一部分机子其实仍在坚持 IE8，而且是仅有一个 IE8 浏览器。如果从保证运行的角度看，我其实有责任兼容 IE8 的。但是从另一个角度看，我为何要兼容 IE8:</p><ol><li>现在都 2017 年，IE8 本来就该被淘汰，再怎么说 IE10 以上也是要的，而且学校这边有些机房的机子已经配备了 Chrome，那么其它机子同样配置 Chrome 也是早晚的事。</li><li>我何必要拿 IE8 折磨自己？如果要兼容 IE8，那么我至少 vue 都不能用了。既然连 vue 都不能用了，那写单页应用的难度就增加的不是一点半点。总不能让我用 jQuery 去写单页应用吧。。</li><li>跟上一条类似，一是保证我开发轻松，二是保证后来的学弟学妹维护轻松，我使用了很多一些现成的且简单易用的前端库，二这些前端库对浏览器的兼容性不一，但要保证全部都能正常运行，那么 IE 还是别想了。。</li></ol><h2 id="redis-mongodb"><a href="#redis-mongodb" class="headerlink" title="redis + mongodb"></a>redis + mongodb</h2><p>严格意义上说不上特性。但是确实觉得 redis + mongodb 确实省了不少力气。最直接的一点是 mongodb 的字段属性可以是数组，我可以用一个列表即可表示一个比赛内所有题目的 id，如果换作 mysql 的话，估计又多一张表了吧。有时感觉数据里的表就和代码行数一样，越多越容易出问题，所以还是尽量控制在可承受的范围内。</p><h1 id="开发杂想"><a href="#开发杂想" class="headerlink" title="开发杂想"></a>开发杂想</h1><h2 id="开发初衷"><a href="#开发初衷" class="headerlink" title="开发初衷"></a>开发初衷</h2><p>我写的这个 OJ 应该是第三代了。第一代是一名学长在 hustoj 起初上改写的 OJ。这个 OJ 用了大概 7，8 年了吧，而且还是部署在一台实体机里。估计跟机器老旧也有点关系，这台机器在某次拿去办比赛之后突然损坏了，而且是硬件损坏了，但幸运地是硬盘没问题，还可以把里面的数据取出来。</p><p>在这种情况下，上一届某学长决定重新写一个 OJ，而且为了表决心，毕业设计的题目就是作一个 OJ。在他的毕业设计任务书里也清楚写到要用 Golang + vue 的组合写一个 OJ。不过最后，他跑路了。。。他因为某些原因，并没有开发出一个新的 OJ，而是拿了 Github 上的一个用 Golang 写的但没用 vue 的 OJ 充当毕业设计了。然后这个 OJ 最后部署到了学校的云服务器上，并且还是用 docker 部署，就这样开始使用了。不过一个问题是，这位学长没有同步以前的数据，所以这个 OJ 部署上去后并没有以前的题目，而是全新的只有一道 A+B 的题目。这个 OJ 就是第二代 OJ 了，就这样用了一年，直到我重写。</p><p>第二代 OJ 其实也还好，毕竟这项目在 Github 上也维护了一段时间了，开发者也在生产环境上使用了一段时间了。因此，重写 OJ 更多的是出于我们自身的原因。一个比较直接但也有点尴尬的原因是这个 OJ 是用 Golang 写的。如果没人会 Golang，那么维护这个 OJ 就有点难了，因为指导老师会时不时要求对 OJ 做些改动。我不想否认 Golang 是一门优秀的语言，但问题是放在我所在的校园内，愿意学习 Golang 的人太少，包括我自己。我不想为了一个 OJ 而去学 Golang，更何况在我已经想用 Node 改写的情况下。另外，至少目前 Golang 的工作岗位相对较少，对某些人来说，学习 Golang 的动力略有不足。同样是学校不会教的语言，学习 PHP, Java, JavaScript, Python 对学生还是主流。</p><p>另一个改写的原因是，就是我单纯地想写一个 JS 前后端全包的网站了。这一点确实是出于自身利益。</p><h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><p>语言选择是第一道坎。如上文所说，其实有四个比较好的选择: PHP, Java, JavaScript, Python。一个首先排除 Java，尽管很多人写过 Java，但我个人对 Java 已经有点反感，不认同这一门废话多和设计模式多的语言; 对于 PHP，我没有学过 PHP，而且从我个人的理解看，PHP7 + Laravel 或许是可以考虑的，其它 PHP 版本和 PHP 框架似乎显得不怎么样; 对于 JavaScript 和 Python，我个人还是比较喜欢的，对于前者，只要搞前端的人都会，对于后者，学习成本低，而且学习的人也多，毕竟 Python 不止能用于 Web 开发。之所以选择 JavaScript 而不是 Python，只是单纯地认为 Node.js 性能会优于 Python，毕竟要考虑到学校给的机器挺一般的。另外选择 JS 的话，前后端都是 JS，对于维护者来说，或许也会轻松点吧。</p><h2 id="学校的服务器"><a href="#学校的服务器" class="headerlink" title="学校的服务器"></a>学校的服务器</h2><p>虽然平时用用是放在学校的云服务器上，可能还好点。但是到了比赛，为了搞起局域网，不得不把 OJ 弄到一个实体机并搬到比赛场地来，然而这个实体机真心不行。至少上一年的比赛就出了大问题，学生访问机器时，会出现“阻塞”，有时能访问，有时显示无响应。然后看机器上的 log，也没抛出异常，据学长说是并发可能有问题。</p><p>虽然不知道是不是真的是并发问题，但如果考虑到并发的话，目前除了 Golang，应该也只有 Node 是一个好的选择了吧。</p><h2 id="版本维护"><a href="#版本维护" class="headerlink" title="版本维护"></a>版本维护</h2><p>版本维护确实有点糟糕。或者说最初的版本维护根本说不上版本维护吧，感觉像打工作报告似的，每天写写今天做了啥。后来出现的一个问题是，版本控制形同虚设，后来我就几乎没做，然后更糟糕的是，我同时在两三台机器上开发，导致三台机器上的版本又不同步，此时我又想起了同步的好处 (╯°□°）╯︵ ┻━┻。</p><p>后来伴随着 koa v1 到 koa v2 的重写，以及前端增加 vuex，我干脆把 Github 上的项目删了重建，重新做了一个版本控制。这次做版本控制前又温习了一遍 git 的常用命令，开始搞起分支。而且发现 git 还有 archive 这个好用的命令。</p><h2 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h2><p>本来也想用 docker 部署的，无奈发现 npm 在 docker 里的速度实在是感人(。ヘ°)</p><p><img src="https://i.loli.net/2018/05/06/5aee28c9b9b89.png" alt="Github Issue"><span class="image-caption">Github Issue</span></p><p>最后用 docker 打包只有 redis 和 mongodb。</p><h2 id="起名"><a href="#起名" class="headerlink" title="起名"></a>起名</h2><p>其实我挺不想用学校的名义给 OJ 起名字，不想叫它 XX 大学 OJ，总觉得这样起名总有一种强调这是 XX 大学的 OJ，不是其它大学的 OJ 一样。但实际上，作为一个开源项目，至少别人想用就用，何必到处在 OJ 里强调大学。这让我想起来 Chrome 刚出来的时候，Chrome 刚出来的时候，界面完全找不到 Google 和 Chrome 标识的字样，让你感觉你就是单纯的使用一个优秀的浏览器，甚至让你不在意这是什么浏览器。所以我不用大学的名字起名，也有一丝这种想法，</p><p>另外，我也像想取个奇特点的名字嘛＼（Ｔ∇Ｔ）／</p><p>Putong 其实就是<code>普通</code>，想法就是来自于 <code>普通 Disco</code></p><p><embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=2129461&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></embed></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>虽然开发上线了，不过有一些不足也是肯定了，争取毕业前把一些坑给填一下，比如多写点有意义的注释，留点有意义的文档之类的。还有一个给题目加标签的功能也没加，可能要留给后来维护的学弟学妹了吧。</p><p>OJ 后端的开发有很多参考了 <a href="http://acdream.info/">Acdream</a> 和 <a href="http://acm.zjgsu.edu.cn/">GoOnlineJudge</a> 的设计。这两个 OJ 都是优秀的 OJ。</p><hr><p><img src="/projects/images/48134921.jpg" alt="Pixiv ID 48134921"><span class="image-caption">Pixiv ID 48134921</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Putong OJ&lt;/strong&gt; – 一个看上去很普通的 Online Judge，现已&lt;a href=&quot;http://acm.cjlu.edu.cn/&quot;&gt;上线&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Features&quot;&gt;&lt;/a&gt;Features&lt;/h1&gt;&lt;p&gt;说一些我自认为可以称得上特性的”特性”&lt;/p&gt;
&lt;h2 id=&quot;单页应用&quot;&gt;&lt;a href=&quot;#单页应用&quot; class=&quot;headerlink&quot; title=&quot;单页应用&quot;&gt;&lt;/a&gt;单页应用&lt;/h2&gt;&lt;p&gt;估计现在没有一个 OJ 采用的是单页应用吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="https://lazzzis.moe/tags/JavaScript/"/>
    
    <category term="Projects" scheme="https://lazzzis.moe/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>杭州白马湖漫展一行</title>
    <link href="https://lazzzis.moe/post/anime-convention-in-hangzhou/"/>
    <id>https://lazzzis.moe/post/anime-convention-in-hangzhou/</id>
    <published>2017-04-29T04:51:02.000Z</published>
    <updated>2018-04-12T21:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名在杭州读书的学生，其实从大一开始，我就一直想去这个展会了。第一次和第二次“太乖”，遇上了点学院的事，听了辅导员和学生会的建议，给他们做苦力去了。第三次正忙于升学考试，故自愿放弃了那次机会。但今年，我在杭州，又没有理由不去，所以还是去了。之所以选择这个日子（4月28日），主要还是因为听说“山下智博”也会来展，想去见见，所以选择了今天。</p><a id="more"></a><h1 id="无聊的-A-馆一层"><a href="#无聊的-A-馆一层" class="headerlink" title="无聊的 A 馆一层"></a>无聊的 A 馆一层</h1><p>本次展会分两个馆，A 馆与 B 馆。进门直接进的是 A 馆，而且 A 馆一层这些的“好位置”都给了“官媒” – CCTV，浙江卫视等媒体。相对来说，这些展位的内容显得无聊枯燥，这点从人数上就可以看出</p><p><img src="https://c1.staticflickr.com/3/2879/33512656613_cd0fb22bc0_c.jpg" alt="入口处观望"><span class="image-caption">入口处观望</span></p><h1 id="热闹的-A-馆二层"><a href="#热闹的-A-馆二层" class="headerlink" title="热闹的 A 馆二层"></a>热闹的 A 馆二层</h1><p>而二层则相对好多了。网易在二层占了两个展位 —- 一个给阴阳师，一个给网易的代理游戏（如守望先锋，星际，魔兽等）。我与小伙伴们在后一个展台前站了一会，看了看水友赛。不过可惜我也就凑凑热闹了，因为我压根不玩这些游戏。</p><p>阴阳师展位相当热闹。展位上同样有水友赛，但还有几个 COSer 作为主播在网易的 CC 直播上做直播。而这个展会最热闹的莫过于下午两点的“山下”登场时了。正如微博上所说，山下真的女装了，COS 了某个式神（原谅我连阴阳师也没玩过）。在活动的两个小时里，在主持人的主持下，山下与台下的观众做了些游戏，然后山下现场抽卡。总体来说，都是以阴阳师为主题的游戏。对于那些又爱山下又爱阴阳师的人来说最喜欢这种活动了。</p><p><img src="https://c1.staticflickr.com/3/2814/33512766803_663ae5457d_c.jpg" alt="阴阳师"><span class="image-caption">阴阳师</span></p><p>虽然我参观此展的目的之一是为了见山下智博，但我在看了一个小时后，默默地离开了一会。一方面如前文所说，我不爱也不玩阴阳师，听不懂主持人的话，不懂游戏的内容。另一方面，前面的人太高了！– 我看不到智博了。。。 <code>(╯︵╰,)</code></p><p><img src="https://c1.staticflickr.com/3/2890/33938820510_2ca58cc829_c.jpg" alt="阴阳师"><span class="image-caption">阴阳师</span></p><p>二楼另外的展位也都是游戏了，比如电魂等。对我这种不怎么看游戏的人来说，看了看一会就走了。</p><h1 id="更多精彩的-B-馆一层"><a href="#更多精彩的-B-馆一层" class="headerlink" title="更多精彩的 B 馆一层"></a>更多精彩的 B 馆一层</h1><p>或许 B 馆一层更符合参加漫展的人吧，这里云集了国外的展方，比如东京电视台，Disney。东京电视台的馆内还摆了各式的手办，标价大多 100 或 150，少数600，800。大多手版是 V 家，物语之类的，相对来说受众面还是比较宽的。馆外还摆了一排的扭蛋，10 RMB 一次。不过不管是扭蛋还是手办，我都没有入手。</p><p><img src="https://c1.staticflickr.com/3/2822/33512857933_f9ab1f14a3_c.jpg" alt="手办们"><span class="image-caption">手办们</span></p><p><img src="https://c1.staticflickr.com/5/4157/34323109655_990cf7229d_c.jpg" alt="兔斯基（注意背景是东京电视台展区）"><span class="image-caption">兔斯基（注意背景是东京电视台展区）</span></p><p><img src="https://c1.staticflickr.com/5/4166/33481472564_2c0cac72a9_c.jpg" alt="星战"><span class="image-caption">星战</span></p><p>除了国外的，也有国内的。展馆中心一眼就能看到 B 站的直播台，不过这个直播台对我来说又是一个没有吸引力的地方了。因为这里并没有多少活动，除了正午 12 点会有几名舞见来馆接受采访。</p><p><img src="https://c1.staticflickr.com/5/4182/33481242074_040d12d9f9_c.jpg" alt="B 站直播台"><span class="image-caption">B 站直播台</span></p><p><strong>最吸引我的</strong> 或许是 B 站旁边的天文角川了。在其它馆都在用大音箱放音乐的时候，只有天文角川默默地呆在那。馆内罗列了较多的书籍，从画册到小说，角川的主要卖品都有身影。大多数书籍都已塑封，因此很少有人对着一本书看太长时间。在这些书籍中，《冰菓》很好地吸引了我的目光。就在前几天，我就有想买《冰菓》第 5 册的冲动，但苦于线上的商家无货。而我在线下却见到了实体书籍，自然让我兴奋了好一会。原价 25 的书籍，实付 20，同时附赠了一张海报。买书是在早上，在快结束展会的时候，我还是回到了天文角川看了一会，犹豫着是不是要再买些书。尽管有一些 5 元特价书，如 灼眼的夏娜，但我仔细思考下，从以前的经历看，我就算买了这书估计也不会太喜欢看。因此第二次去天文角川并没有买什么物品。</p><h1 id="乱七八糟的-B-馆二层"><a href="#乱七八糟的-B-馆二层" class="headerlink" title="乱七八糟的 B 馆二层"></a>乱七八糟的 B 馆二层</h1><p>B 馆二层显得无序一点。这里有一些奇怪的官方展位 – 比如阿里云（你来混脸熟么？），也有部分不知名的小商铺。在二层仍能看到 B 站的身影 – B 站的店铺。不过 B 站内的商品与淘宝上的 B 站店别无二致，价格也无多少优惠，再者实用性或是装饰性也略差，我觉得我还没到给 B 站充信仰的程度，故而没在此购物。</p><h1 id="全是小商铺的-B-馆三层"><a href="#全是小商铺的-B-馆三层" class="headerlink" title="全是小商铺的 B 馆三层"></a>全是小商铺的 B 馆三层</h1><p>这里几乎全是小商铺。本以为会有各种新奇的周边，但仅逛了一会就发现我还是想错了。这里的商铺 <strong>同质化</strong> 有点严重。80 % 以上的商品分为 4 类 – 手办类，抱枕类，挂画类，福袋类。其中后三种几乎会同时在同一个商铺内，因此这么算的话，也就两种商铺了。而我对挂画和抱枕比较挑剔，又不信福袋。这么一算也就只能看看手办了。然而，相对竞争力而言，这些商铺的手办尽管自称官方，但似乎从每种角度上比不上国外方展馆所卖的更具官方性。况且手办的受众其实不如抱枕之类的，一个“滑稽”抱枕几乎男女通吃，只要玩表情的路人几乎都会心动一下。总的来讲，商家间的区别在品类上已经不算大，在加上抱枕挂画之类的主题几乎也有很大一部分的重叠，商家与商家的区别只能体现在福袋的大小与价格上了。因此，这里的商铺并不算多样与精彩。</p><p><img src="https://c1.staticflickr.com/5/4168/34282275796_0d6234e1c1_c.jpg" alt="商铺内的手办"><span class="image-caption">商铺内的手办</span></p><p>即使如此，却还是有一个与周围“格格不入”的商铺 – 一家卖 CD 的商铺。这家商铺也主要以 ACG 为主，而且还包含了东方同人！（这个馆内东方的数量并不多，甚至稀有）在价格上，商家已经打出了买一送一的策略，而且一张的价格收 90 RMB，看起来是比较划算的。我挑选了一张化物语的CD（刚好最近在补化物语），然后挑了一张蝶 P 的碟。这次消费算已经是我在这次行程中最大的消费了。除了这些 CD 能吸引我的兴趣外，其它真的很少了。</p><h1 id="无存在感的-B-馆四层"><a href="#无存在感的-B-馆四层" class="headerlink" title="无存在感的 B 馆四层"></a>无存在感的 B 馆四层</h1><p>除了“朱德庸”展区有点意思，其它展区（儿童画，法制题材画）实在没啥人看。</p><p><img src="https://c1.staticflickr.com/3/2858/34192123471_62f52f2c35_c.jpg" alt="漫画家朱德庸的作品"><span class="image-caption">漫画家朱德庸的作品</span></p><h1 id="一些吐槽"><a href="#一些吐槽" class="headerlink" title="一些吐槽"></a>一些吐槽</h1><p>尽管这次的展会是以动漫为主题，不过 BAT 也还是齐了 – 腾讯动漫，阿里云，以及百度外卖。。。</p><p>馆内居然还有 vipabc，英孚教育的商铺。别人买了亲子票带孩子来玩，孩子很高兴，然后父母却又给他们报了个班？</p><p>没怎么看清山下智博，除了前面的观众挡住我的视线外，一个做直播的刚好也挡住了我的视线。</p><p>优酷，qq 等展位上都放了自家的或流行的动漫角色，而旁边的乐视放了消防教育动漫展（你为何不与法制教育主题展放到同一个展区呢？）。</p><p>还真有老年人来参观的，估计是陪孩子吧，还真是辛苦了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大学最后一次漫展，但却也是我参与的第一次漫展，也总算在毕业前完成了“参观漫展”这个任务。以后还会不会参加呢？如果有的话，我还是会考虑参加的。</p><p>最后，贴张照片，拍摄于 B 站展区内(暂时不想露脸)：</p><p><img src="https://c1.staticflickr.com/3/2811/34282503846_622ff1db53_c.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为一名在杭州读书的学生，其实从大一开始，我就一直想去这个展会了。第一次和第二次“太乖”，遇上了点学院的事，听了辅导员和学生会的建议，给他们做苦力去了。第三次正忙于升学考试，故自愿放弃了那次机会。但今年，我在杭州，又没有理由不去，所以还是去了。之所以选择这个日子（4月28日），主要还是因为听说“山下智博”也会来展，想去见见，所以选择了今天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ACG" scheme="https://lazzzis.moe/tags/ACG/"/>
    
  </entry>
  
  <entry>
    <title>一周面试小结</title>
    <link href="https://lazzzis.moe/post/recent-interviews-in-march-2017/"/>
    <id>https://lazzzis.moe/post/recent-interviews-in-march-2017/</id>
    <published>2017-03-25T04:38:09.000Z</published>
    <updated>2018-05-05T21:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景及摘要"><a href="#背景及摘要" class="headerlink" title="背景及摘要"></a>背景及摘要</h1><p>3 月 15 日，浙大玉泉校区举办了一场招聘会，近几百家单位参加。虽然我不是浙大本校生，但是外校学生若携带学生证件也是可以进入的。我总共带了 12 份简历前往，并全部投出。我的目标岗位为 Web 前端开发，但也对 Python / Node.js 后端有意向。目前我已进行了 3 次面试，分别是 <a href="https://www.lagou.com/gongsi/137471.html">数聚科技</a>, <a href="https://www.lagou.com/gongsi/178043.html">谷神星</a>, <a href="https://www.lagou.com/gongsi/210.html">企朋</a> （点击可查看拉钩网上的信息）。我想在这篇文章里分享一下我这几次的面试过程，谈谈我的一些想法，希望对大家有帮助。</p><a id="more"></a><h1 id="招聘会"><a href="#招聘会" class="headerlink" title="招聘会"></a>招聘会</h1><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>这是我的 <a href="https://drive.google.com/file/d/0B46-8KBsYVBpcUZuemJqLXhFalk/view?usp=sharing">简历</a> 。因为这份简历仅用于交流，因此我故意抹去了一些信息，比如真实姓名，联系方式，就读的大学等。同时这份简历是我在招聘会后稍作了修改的简历（增加了专业，意向岗位，将 “Java实习生” 改为 “Web 实习生”，其它均未改动）。</p><p>事实上这是我第一次做招聘用的简历，直接套用了 Google Docs 的一个 Resume 模板。但是有几个细节在编辑时没有注意，在招聘会后或面试时我才发现这些是个问题：</p><ol><li><p><strong>没有标注专业</strong>。尽管现在有很多公司也不会太在意你是否是计算机专业出生，但专业本身仍然是 HR 关注的一个重要信息。其次，有些公司在招聘要求上也明确说明需要计算机相关专业的应聘者。因此专业作为一个关键信息仍不能忽视。</p></li><li><p><strong>没有写明目标岗位</strong>。在最初的（也就是用于投递的那一版的）简历里，我没有明确说明意向。招聘会上，有些 HR 会将收到的简历按岗位分开存放。但有些 HR 则不然。或者说，在人多的情况下， HR 也难免会忘记你的意向。注意，我在最初的简历中有写 “Java” 实习生的经历。这本来没问题，但是在我没写清岗位的情况下，有几位 HR 错以为我对 “Java工程师” 有意向。因此，目标岗位也是极重要的信息。</p></li><li><p><strong>简历或许可以再紧凑一点</strong>。看了一些他人的简历，大多有表格辅助，而且空间利用率明显比我的简历要高。或许可以再思考一下如何再打扮一下我的简历。</p></li></ol><h2 id="现场"><a href="#现场" class="headerlink" title="现场"></a>现场</h2><p><strong>请务必先详细了解招聘场所内的具体分布！</strong></p><p>当我到招聘会现场时，计划时长 3 小时的招聘会已经举办了半小时了。我当时也没注意 3 个场所内公司的分布，所以我一到现场时就先跑进了第一个分会场。看完第一个会场后我就前往了第二个会场。而当时的我仅知道有 3 个会场的存在，但不清楚 3 个会场中公司摊位的数量。结果就是，我在第 2 个会场花了近一个小时。而到了第 3 个会场，我呆了，这里比第 2 个会场有更多的企业。这时，距离结束大约剩余 1 小时。而且在最后大约 20 分钟，我惊奇地发现，这个场所（一个排球馆）的某处有一个不长的通道，通向同一场所的另一个区域 – 这里还有将近 100 家企业。更糟糕的是，<strong>他们已经开始收摊</strong> 了。更更糟糕的是，此时的我。。。手头已经 <strong>没有剩余的简历了</strong>。</p><h1 id="数聚科技"><a href="#数聚科技" class="headerlink" title="数聚科技"></a>数聚科技</h1><p>我应聘了这家公司的前端，是第二个联系了我的公司（第一个公司以为我要应聘 Java 。。。所以我在电话上就拒绝了 HR）。HR 与我约好周五见面，时间是 3 点到 4 点。</p><p>公司位于浙大科技园（浙大玉泉校区附近）。园内环境可以，但园外。。。背后是丘陵。</p><p><img src="https://farm1.staticflickr.com/973/28044133508_b6a828b244_k.jpg" alt="园内"><span class="image-caption">园内</span></p><p><img src="https://farm1.staticflickr.com/947/28044133518_55c6b368ec_k.jpg" alt="园外"><span class="image-caption">园外</span></p><p>面试者是两人，分别是 HR 以及一名技术员工（该员工并没详细介绍自己，但从年龄和谈话上看，应该不是 CTO 或 PM）。</p><p>对话首先以我简历上的项目为重点，主要问了我采用了哪些工具（框架以及包）。接着聊了一下我何时毕业以及我的住处问题。最后商讨薪水。</p><p>整个过程中没有询问任何 <strong>技术上的问题</strong>。谈话中仅仅是说我怎么做项目。但没有问我如何解决一些问题，比如：如何解决高并发问题，也没有问我任何关于 JavaScript 语言的相关问题。</p><p>其次，这个 HR 对技术不是很了解。虽然对于 HR 应不应该懂技术这个问题我保留意见，但我还是想吐槽一下。我在谈项目时我把 <code>Vue</code> 念作单词发音，而不是读成 3 个字母 (<code>V-U-E</code>)。但当我讲完项目后，HR 还是问了一句：你既然对这个 “wei you” 框架这么熟悉，那你对 <code>V-U-E</code> (读这 3 个字母) 熟不熟悉呢？ 我: (；￣Д￣） 这不同一个玩意么。。。</p><p>还想吐槽一点，这个技术员工 <strong>似乎也不是特懂技术</strong>。因为我在简历里写了 SCSS (可以参考 <a href="http://sass-lang.com/">Link</a>)，但这技术人员却说：这里是不是写错了，SCSS 是什么，应该是 CSS 吧？ 我: ヘ(゜Д、゜)ノ 你不是技术人员么？</p><p>另外，目前这个公司前端业务不算特别重。据悉，该公司近期做的一个项目是调查问卷。这也难怪他们问我是否用过 E-Charts。不过当时我也完全不知道 E-Charts 是什么。</p><p>总的来说，我个人对这家公司的面试感觉一般。因为我对面试也报了一种 <strong>学习</strong> 的态度，希望能在面试中也能了解一些自己的不足。但是这次面试恰恰相反，我反倒看到了他们的一些不足。</p><p>关于薪水，我当时没有提，因为我还真没认真想这事，以为公司会主动提供数字再让我做决定。所以当时只是说之后电话联系。</p><p>这是星期五（3 月 17 日）的面试，在这之后的第 3 天（星期一），我接到了 HR 的电话。电话中 HR 通知了我被录取的消息，不过在 HR 提出薪资前，我就回绝了。不管这个公司是否真的有前景，但至少我觉得我极不适合这个公司。</p><h1 id="企朋"><a href="#企朋" class="headerlink" title="企朋"></a>企朋</h1><p>先上结论，这是我目前面试中 <strong>最满意</strong> 的公司，无论从面试过程还是公司本身来说。</p><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>笔试总体分三部分: 网络相关知识，算法编程知识，语言相关知识。可以看出该测试偏概念与算法，比如快排或 GC，没有考某某对象的使用或某某方法的使用。至于具体题目，我觉得还是不要透露的好。总之，对于这份试卷，虽然有几题明显可以看出是非原创的（就是从网上抄的），但总体上还是比较能反映一个编程者的基本素养的。</p><h2 id="一面（技术面）"><a href="#一面（技术面）" class="headerlink" title="一面（技术面）"></a>一面（技术面）</h2><p>本以为前端工程师会问我关于 <code>prototype</code> 或 <code>Object</code> 相关的问题，但事实上这一位工程师没有注重这方面，而是问了我一些关于 <code>yield</code>，以及 <code>async await</code> 的一些问题。</p><p>同时也问了一些关于 <code>session</code> 的概念或实现。我对 <code>session</code> 的理解程度仅仅是用 <code>Node.Js</code> 的某个包实现的程度。所以这方面我确实不懂，反而是工程师教导了我。</p><p>再者，工程师和我聊了一些我项目上的事，针对我项目中写的提问，比如 restful 理解之类的。</p><p>总体上讲，前端工程师并没有问那些 <code>JavaScript</code> 中的那些坑，而是注重我在项目上的实际能力，因为工程师多次对我如何理解和解决问题发问。</p><h2 id="二面-CTO"><a href="#二面-CTO" class="headerlink" title="二面 (CTO)"></a>二面 (CTO)</h2><p>技术面之后，马上就安排了 CTO 前来面试。</p><p>不得不说，CTO 整个人显示的气场就很不一样。第一眼看上去，CTO 和蔼可亲，同时有温文尔雅；而在提问和聊天时，又显得沉着睿智。</p><p>和 CTO 的聊天中，我也明显感觉他的表达能力比我更甚一筹。举个例子，在聊项目时，我提到我对排行榜的处理是先以分数排序，再按时间顺序排序。而 CTO 一转述，则变成: <strong>此排序以分数为第一维度，以时间为第二维度</strong>。这种表述便显得书面化，也不容易被人误解。</p><p>CTO 也问了我一些关于 <code>情怀</code> 的题，比如你崇拜的人之类的。（P.S. 这个问题好像有很多公司问呀，我在招聘会上就被一个公司问过了，还同样是一个招前端的公司 ((´д｀)) ）</p><p>CTO 的具体问题细节同样就不透露了，但 CTO 的问题的出发点比前端工程师的站在一个更高的角度，包含了我对项目整个过程中出现的问题以及我个人的一些修养（比如对于 <code>Open Source</code> 和 <code>新技术</code> 的看法）。</p><p>当然，这面试并不是单向的，最后 CTO 允许我问他一些问题。CTO 对我的问题进行了耐心详细的解答，而不是一句两句带过。这让我感觉 CTO 是真心希望我能问问题的，而不是出于某些礼貌说的客套话。</p><h2 id="三面-HR"><a href="#三面-HR" class="headerlink" title="三面 (HR)"></a>三面 (HR)</h2><p>和 HR 的聊天集中于待遇和我的需求。HR 给的关于实习薪资就蛮高的，是一些工资的 1.5 ~ 2 倍。（我认为薪资是一种隐私，所以具体数字就不提了）</p><p>另外，同 HR 的聊天中我也了解到这家公司也很注重效率和协作。HR 跟我解释了目前公司使用的协同工具和技术。从这个角度看，在这家公司工作，<strong>沟通不是问题</strong>。</p><p>和 HR 的整体过程很愉快，尤其当 HR 说我有 <strong>极客范</strong> 的时候 ＼(^▽^＠)ノ。真的，这句话足以让我高兴一整天；<strong>对于目前的我来说，这几乎是最大的认可</strong>。并且，这名 HR 是第一个这么评价我的人。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>这个公司的环境很棒！</strong></p><p>一进门就感觉这很有 google 的风范。办公室边上有零食架，健身器材，以及其它游戏措施。按 HR 的说法，<strong>这是为了让员工专注于手头的任务</strong>。</p><p><img src="https://i.loli.net/2018/05/06/5aee271dd81c5.jpg" alt="公司一角"><span class="image-caption">公司一角</span></p><p><img src="https://farm1.staticflickr.com/971/28044133418_7c1edf041e_k.jpg" alt="公司一角"><span class="image-caption">公司一角</span></p><p><img src="https://i.loli.net/2018/05/06/5aee271dda139.jpg" alt="公司一角 -- 吃饭啦！"><span class="image-caption">公司一角 -- 吃饭啦！</span></p><p>另外，在面完 CTO 后，刚好是午饭时间，CTO 和 HR 很友好地请我在公司吃饭。我刚开始出于礼貌而委婉地拒绝了，不过在几次邀请下还是放开吃了。。。嗯，味道不错！ლ(⌒▽⌒ლ)</p><h2 id="谷神星"><a href="#谷神星" class="headerlink" title="谷神星"></a>谷神星</h2><p>首先我表示一下我对这个公司的歉意，因为我迟到了一个小时。以至于到了之后，技术人员有事不在了，所以面试我的反而是一名销售人员。</p><p>销售人员看了简历之后让我介绍自己并讲讲简历上的项目。不过讲到一半时，他打断了对话。他很坦诚的表示，自己只是销售，不懂技术。说罢，还给了我一些建议，比如简历上还是缺少点亮点，说话不够简洁。可能有人觉得这名销售有点无理，但我却不这么认为。从当时销售的语气和表情看，销售确实是出于好意所以打断对话并给我建议，因为我继续讲技术也是对牛弹琴，同时我也确实有表现不好的地方。</p><p>与销售聊完后，HR 与我约好，（当天为周二）过一两天后，我将会与现位于温哥华的一名技术人员进行电话面试。</p><p>周四早上，我与技术人员进行了约好的（微信）电话面试。</p><p>从通话开始，技术便开始提问，首先是关于 <code>Java</code> 的，比如 <code>Spring</code> 的特点。但说实话，我对 <code>Java</code> 并不在行，所以回答得支支吾吾。</p><p>后来又问了一些 <code>JavaScript</code> 的问题，比如 <code>Synchronous vs Asynchronous</code>，<code>Promise</code> 等。因为这与前端相关，所以我比刚才表达更加流利了。</p><p>接着，对 database 又提问了一些，比如 <code>transaction</code>，几条 <code>SQL</code> 语句等。我对数据库只会基本使用，但一些特点却不然。因此这里回答的也很一般。</p><p>最后，技术让我介绍自己做的一个项目。我自然讲了我最近做的那个在线评测系统。</p><p>若让我作个评价，我会说这个技术也确实懂点技术的，对我的提问也明显注重于一些语法的细节和特点。但对我个人如何实现整个项目以及实现项目的能力过问的很少。</p><p>至于我对这个公司的看法，主要是薪资水平太低了。实习生工资也才 3K，而且之前销售还没讲转正后的具体薪资的，只说工资是看实习表现再决定的。初次之外，这个公司并没有专门的前后端，换句话说，我要同时处理前后端认为。这对我来说是不可接受的，毕竟我在之前的一次实习中已经体验过这种开发了。一般这种做法对开发者的负担还是有点大， 不能专心于一件事情之中。因此，我决定拒绝掉这个公司。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前面试了就这几家，剩下几家要么没通知，要么已经预约了面试但还没到时间。如果后续还有面试，我大概会写一篇新的文章来分享自己的经历和想法。</p><p>但就这几家而言，我个人认为面试是可以准备的，某种程度上也类似与应试考试，允许你临时抱佛脚。但，面试的最终表现还是基于你的真实水平的，依你平时的水平已经基本决定了面试的表现。面试前多做些细节准备能增加面试官的好感度，但并不能仅凭借这些就获得面试官的芳心。</p><p>所以，一方面平时必须要做些项目。这些项目最好与你期望的岗位相关，同时最好是具备一定复杂程度的，比如一个单纯的获取在线时间的爬虫是不够的，但如果是一个能够爬多个网站并能根据比较数据给出建议的爬虫则相对高级很多，则可以显得你能组织代码以及分析问题。同时，对于一个较大的项目，最好是能正式上线的，因为这可以体现你有能力维护代码。另外，我个人认为项目的数量不在多，而在精 —- 你有时间写 10 个冒泡排序还不如写 1 个快速排序来提升算法能力。</p><p>至少，我这几个面试基本上是靠项目 <code>在线评测系统</code> 来与面试官进行交流的（或者是说靠”吹”的 ﾍ(￣ ￣;ﾍ)），如果这个项目不够，简历上的实习也基本能充当谈资了。至于另外的几个项目 – 个人博客 之类的，就是用来凑篇幅的 – 面试官很少提它们，我也几乎不会主动靠它们彰显自己的能力。不过，我不得不说我在简历里的一个遗憾，我没有发布过任何一个包 – 无论是 Python 还是 Node.js 。发布一个好用可维护的包已经添加到 2017 的 Todo-List 里了。</p><p>最后，希望我的这篇文章能给大家一些帮助；同时，祝大家都能拿到满意的 Offer。</p><hr><p><img src="https://i.loli.net/2018/05/06/5aee271de1c06.jpg" alt="Pixiv ID: 49916912"><span class="image-caption">Pixiv ID: 49916912</span></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景及摘要&quot;&gt;&lt;a href=&quot;#背景及摘要&quot; class=&quot;headerlink&quot; title=&quot;背景及摘要&quot;&gt;&lt;/a&gt;背景及摘要&lt;/h1&gt;&lt;p&gt;3 月 15 日，浙大玉泉校区举办了一场招聘会，近几百家单位参加。虽然我不是浙大本校生，但是外校学生若携带学生证件也是可以进入的。我总共带了 12 份简历前往，并全部投出。我的目标岗位为 Web 前端开发，但也对 Python / Node.js 后端有意向。目前我已进行了 3 次面试，分别是 &lt;a href=&quot;https://www.lagou.com/gongsi/137471.html&quot;&gt;数聚科技&lt;/a&gt;, &lt;a href=&quot;https://www.lagou.com/gongsi/178043.html&quot;&gt;谷神星&lt;/a&gt;, &lt;a href=&quot;https://www.lagou.com/gongsi/210.html&quot;&gt;企朋&lt;/a&gt; （点击可查看拉钩网上的信息）。我想在这篇文章里分享一下我这几次的面试过程，谈谈我的一些想法，希望对大家有帮助。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
