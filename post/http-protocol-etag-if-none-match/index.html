<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>lazzzis</title>
  <link rel="icon" href="favicon.ico"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="/css/ionicons.min.css">
  <link rel="stylesheet" href="/css/milligram.min.css">
  <link rel="stylesheet" href="/css/comfortaa.css">
  <link rel="stylesheet" href="/css/source-sans-pro.css">
  <link rel="stylesheet" href="/css/animate.min.css">
  <link rel="stylesheet" href="/css/nprogress.css">
  <link rel="stylesheet" href="/css/loaders.min.css">
  <link rel="stylesheet" href="/css/atom-one-light.css">
  <link rel="stylesheet" href="/css/app.css">
</head>
<body>
  <div id="app"></div>
  <template>
    <template>
    <p>ETag 是 HTTP 头的一个字段，出现在 Response Header 之中，用于标记一个资源的版本，是 HTTP 缓存策略的一种手段。</p>
<p>软件开发常常有版本号的概念，比如 <code>1.0</code>, <code>1.1</code>, <code>2.0</code> 等等。软件使用者通常会在客户端版本落后于服务器最新版本时才会去服务器获取新的软件。</p>
<p>这一理念也用于了浏览器缓存策略中。结合下面这张图为例，浏览器已经缓存了 <code>foo.jpg</code> 且已记录版本号为<code>1.2</code> (这个版本号由服务器生成并告诉浏览器)，那么当浏览器再次请求 <code>foo.jpg</code> 时，就会同时把版本号也放在请求头中。这样，服务器收到请求时，就知道了客户端已缓存的文件的版本。如果服务器中的 <code>foo.jpg</code> 版本也是 <code>1.2</code>，那么服务器就可以说 <code>304 Not Modified</code>，不用再将 <code>foo.jpg</code> 传给了浏览器，因此就节省了带宽。反之，如果服务器端的 <code>foo.jpg</code> 已经 <code>1.3</code> 了，那么就要将新的文件传给浏览器，也同时告诉它版本号为 <code>1.3</code>，浏览器收到后，缓存文件，并记录版本号为 <code>1.3</code>。</p>
<p><img src="https://i.loli.net/2017/12/29/5a4566269629e.png" alt=""></p>
<p>ETag 是 Response Header 中的一个字段，而与之对应的一个出现在请求头中的字段为 <code>If-None-Match</code>。<code>If-None-Match</code> 对应的值即为浏览器缓存的的文件的版本号。</p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>使用 Koa 框架为例:</p>

    <pre><code class="lang-js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa'</span>)
<span class="hljs-keyword">const</span> koaLogger = <span class="hljs-keyword">require</span>(<span class="hljs-string">'koa-logger'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()

app.<span class="hljs-keyword">use</span>(koaLogger())

app.<span class="hljs-keyword">use</span>(async (ctx, next) =&gt; {
  <span class="hljs-keyword">if</span> (ctx.get(<span class="hljs-string">'if-none-match'</span>) &amp;&amp; ctx.get(<span class="hljs-string">'if-none-match'</span>) === <span class="hljs-string">'foobar'</span>) {
    ctx.status = <span class="hljs-number">304</span>
  } <span class="hljs-keyword">else</span> {
    ctx.status = <span class="hljs-number">200</span>
    ctx.type = <span class="hljs-string">'json'</span>
    ctx.set(<span class="hljs-string">'etag'</span>, <span class="hljs-string">'foobar'</span>)
    ctx.body = fs.createReadStream(<span class="hljs-string">'package.json'</span>)
  }
})

app.listen(<span class="hljs-number">5000</span>)
</code></pre>
<p>这次我们把它标记为 <code>foobar</code>。注意版本号并不一定要像软件开发的版本号具有语义化，相反它可以是任意字符串，只要确保两个版本间的版本号不一样就行。</p>
<p><img src="https://i.loli.net/2017/12/29/5a45662a0d0de.png" alt=""></p>
<p>如图，第一次向 <code>localhost:5000/package.json</code> 发起请求，返回头中包含了 <code>etag: foobar</code>。因此是第一次请求，所以请求头之中没有 <code>If-None-Match</code> 字段。</p>
<p>刷新页面继续请求：</p>
<p><img src="https://i.loli.net/2017/12/29/5a45662a48d5c.png" alt=""></p>
<p>可以发现，这次请求头中多了 <code>if-none-match</code> 字段，其值就是 <code>foobar</code>。因此这次 <code>foobar</code> 和服务器版本相同，因此可以直接返回 304。</p>
<p>如果，修改本地服务器版本号，比如改成 <code>package</code>:</p>

    <pre><code class="lang-js">app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-keyword">get</span>(<span class="hljs-string">'if-none-match'</span>) &amp;&amp; ctx.<span class="hljs-keyword">get</span>(<span class="hljs-string">'if-none-match'</span>) === <span class="hljs-string">'package'</span>) {
    ctx.status = <span class="hljs-number">304</span>
  } <span class="hljs-keyword">else</span> {
    ctx.status = <span class="hljs-number">200</span>
    ctx.type = <span class="hljs-string">'json'</span>
    ctx.<span class="hljs-keyword">set</span>(<span class="hljs-string">'etag'</span>, <span class="hljs-string">'package'</span>)
    ctx.body = fs.createReadStream(<span class="hljs-string">'package.json'</span>)
  }
})
</code></pre>
<p>再次请求，</p>
<p><img src="https://i.loli.net/2017/12/29/5a45662a7925b.png" alt=""></p>
<p>如图，这次因为版本号不同了，所以服务端要再次发送文件，并且通知浏览器更新版本号。</p>
<h2 id="koa-static-cache"><a href="#koa-static-cache" class="headerlink" title="koa-static-cache"></a>koa-static-cache</h2><p>在 <a href="https://github.com/koajs/static-cache" target="_blank" rel="noopener">koa-static-cache</a> 这个包中，也使用了 <code>ETag</code> 策略。</p>
<p>源码中有这么几行代码:</p>

    <pre><code class="lang-js"><span class="hljs-keyword">if</span> (file.md5) ctx<span class="hljs-selector-class">.response</span><span class="hljs-selector-class">.etag</span> = file<span class="hljs-selector-class">.md5</span>

<span class="hljs-keyword">if</span> (ctx.fresh)
  return ctx<span class="hljs-selector-class">.status</span> = <span class="hljs-number">304</span>
</code></pre>
<p>它的意思其实就是将文件的 <code>md5</code> 值作为版本号，因为文件内容一旦改变，那么它的 <code>md5</code> 也一定随之改变。</p>
<p>而 <code>ctx.fresh</code> 是 koa 实现的一个属性，可以参考文档 <a href="http://koajs.com/" target="_blank" rel="noopener">doc</a>。而这个属性就是根据 If-None-Match / ETag, and If-Modified-Since and Last-Modified 判断缓存是否过期。更具体的，Koa 源码中对 <code>fresh</code> 字段的实现又是使用了 <a href="https://github.com/jshttp/fresh" target="_blank" rel="noopener">fresh</a> 这个包，源码中可以观察这几行:</p>

    <pre><code class="lang-js"><span class="hljs-comment">// if-none-match</span>
  <span class="hljs-keyword">if</span> (noneMatch &amp;&amp; noneMatch !== <span class="hljs-string">'*'</span>) {
    <span class="hljs-keyword">var</span> etag = resHeaders[<span class="hljs-string">'etag'</span>]

    <span class="hljs-keyword">if</span> (!etag) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">var</span> etagStale = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> matches = parseTokenList(noneMatch)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; matches.length; i++) {
      <span class="hljs-keyword">var</span> match = matches[i]
      <span class="hljs-keyword">if</span> (match === etag || match === <span class="hljs-string">'W/'</span> + etag || <span class="hljs-string">'W/'</span> + match === etag) {
        etagStale = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">break</span>
      }
    }

    <span class="hljs-keyword">if</span> (etagStale) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
  }
</code></pre>
<p>其实现就是的原理就是比较 <code>if-none-match</code> 和 <code>etag</code> 的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://shop.oreilly.com/product/9781565925090.do" target="_blank" rel="noopener">HTTP: The Definitive Guide</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag" target="_blank" rel="noopener">MDN ETag</a></li>
</ol>

</template>

  </template>
  <script type="text/javascript">
    window.root = "/"
  </script>
  <script src="/js/manifest.js"></script>
  <script src="/js/vendor.js"></script>
  <script src="/js/app.js"></script>
</body>
</html>
