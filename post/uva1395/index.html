<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>lazzzis</title>
  <link rel="icon" href="favicon.ico"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="/css/ionicons.min.css">
  <link rel="stylesheet" href="/css/milligram.min.css">
  <link rel="stylesheet" href="/css/comfortaa.css">
  <link rel="stylesheet" href="/css/source-sans-pro.css">
  <link rel="stylesheet" href="/css/animate.min.css">
  <link rel="stylesheet" href="/css/nprogress.css">
  <link rel="stylesheet" href="/css/loaders.min.css">
  <link rel="stylesheet" href="/css/atom-one-light.css">
  <link rel="stylesheet" href="/css/app.css">
</head>
<body>
  <div id="app"></div>
  <template>
    <template>
    <h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先有一点是可以确定的：对于任何一连通图，必有一生成树（简直废话）。<br>对于这一题，关键的问题是确定最大与最小。对于这种寻找两个相关变量的题，其实一般可以先试着确定一个，然后再去寻找另一个。<br>比如在这题中，可以迭代每一个边 L，同时把这条边 L 当做最小的边，用比它大的边去试着连同一幅图，知道找到边 R， 使得加上这条边 R 后刚好可以凑成一幅联通图。<br>因此，从上述思路可以看出，排序是必不可少了。所有排序是第一步。<br>排序好后进行遍历 L，建立 N （顶点数） 个并查集 S，每加入一条边就将该边的端点对应的并查集合并（前提是两个端点对应不同的并查集）。<br>直到刚好加入边 R 后，并查集只剩一个，且大小刚好与顶点数相等。此时对于 L 来说，R － L 极为其 “苗条度”。<br>因此对所有求得的“苗条度”求一个最小值即可。如果连一个“苗条度”都没有，那结果自然就是找不到合适的答案了。</p>
<a id="more"></a>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1>
    <pre><code class="lang-cpp"><span class="hljs-comment">/*
 * Run Time : 0.033s
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> first, second;
    <span class="hljs-keyword">int</span> len;
};

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>{
    <span class="hljs-keyword">return</span> a.len &lt; b.len;
}

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">1000000</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">100</span> + <span class="hljs-number">50</span>;
<span class="hljs-keyword">int</span> N, M;
<span class="hljs-built_in">vector</span>&lt;Node&gt; nodes;
<span class="hljs-keyword">int</span> size[MAXN], root[MAXN];

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> a, b, k;
    nodes.clear();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M; ++ i) {
        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; k;
        Node n;
        n.first = a; n.second = b; n.len = k;
        nodes.push_back(n);
    }
}

<span class="hljs-keyword">int</span> ans;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (root[n] == n) {
        <span class="hljs-keyword">return</span> n;
    }
    <span class="hljs-keyword">return</span> root[n] = Find(root[n]);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>{
    sort(nodes.begin(), nodes.end(), cmp);
    ans = INF;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j; i &lt; M; ++ i) {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= N; ++ j) {
            size[j] = <span class="hljs-number">1</span>;
            root[j] = j;
        }
        <span class="hljs-keyword">for</span> (j = i; j &lt; M; ++ j) {
            <span class="hljs-keyword">int</span> ra = Find(nodes[j].first);
            <span class="hljs-keyword">int</span> rb = Find(nodes[j].second);
            <span class="hljs-keyword">if</span> (ra != rb) {
                root[rb] = ra;
                size[ra] += size[rb];
            }
            <span class="hljs-keyword">if</span> (size[Find(<span class="hljs-number">1</span>)] == N) {
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> (size[Find(<span class="hljs-number">1</span>)] == N) {
            ans = min(nodes[j].len - nodes[i].len, ans);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size[Find(<span class="hljs-number">1</span>)] &lt; N) {
            <span class="hljs-keyword">break</span>;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    ios::sync_with_stdio(<span class="hljs-literal">false</span>);
    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; (N + M)) {
        read();
        work();
        <span class="hljs-built_in">cout</span> &lt;&lt; (ans == INF ? <span class="hljs-number">-1</span> : ans) &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最近没怎么练习，在做这题时犯了一个低级错误。刚开始使用了一个 set （集合）代替并查集。当 set 大小为 N 时，即可计算“苗条度”<br>这种想法当然是<strong>错误</strong>的！！！很明贤，顶点数达到要求了，但并不一定代表图已经连通！</p>

</template>

  </template>
  <script type="text/javascript">
    window.root = "/"
  </script>
  <script src="/js/manifest.js"></script>
  <script src="/js/vendor.js"></script>
  <script src="/js/app.js"></script>
</body>
</html>
