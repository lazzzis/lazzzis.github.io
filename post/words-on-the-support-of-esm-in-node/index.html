<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>lazzzis</title>
  <link rel="icon" href="favicon.ico"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="/css/ionicons.min.css">
  <link rel="stylesheet" href="/css/milligram.min.css">
  <link rel="stylesheet" href="/css/comfortaa.css">
  <link rel="stylesheet" href="/css/source-sans-pro.css">
  <link rel="stylesheet" href="/css/animate.min.css">
  <link rel="stylesheet" href="/css/nprogress.css">
  <link rel="stylesheet" href="/css/loaders.min.css">
  <link rel="stylesheet" href="/css/atom-one-light.css">
  <link rel="stylesheet" href="/css/app.css">
</head>
<body>
  <div id="app"></div>
  <template>
    <template>
    <p>简单谈谈目前 (2017 年 10 月), Node.js 对 ESM (ES6 Module) 的支持情况，并且发表一点自己的看法。</p>
<h1 id="主流的方案"><a href="#主流的方案" class="headerlink" title="主流的方案"></a>主流的方案</h1><ol>
<li>在文件开头添加 <code>&quot;use module&quot;;</code> 或类似字段</li>
<li>新的文件后缀名，如 <code>.mjs</code></li>
<li>通过源代码内容自动区分</li>
<li>在 <code>package.json</code> 指明采用 <code>ESM</code> 的文件</li>
</ol>
<a id="more"></a>
<p>这四个方案都已经满足了一些基本要求:</p>
<ul>
<li>对现有的 <code>package</code> (几乎全是 CJS) 不造成影响</li>
<li>不需要知道 <code>package</code> 采用的是哪种形式就可以直接导入</li>
</ul>
<p>在这个基础上，第 2 个方案接受的比较多，而且在当前版本 <code>8.7.0</code> 中，可以通过在命令行中增加 <code>--experimental-modules</code> 运行。<br>比如 <code>node --experimental-modules main.mjs</code>:</p>

    <pre><code class="lang-js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'ramda'</span>

<span class="hljs-built_in">console</span>.log(_.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
</code></pre>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>其实我最初想到的也是这种方案, 因为我以前在其它语言中接触过一些类似的做法。</p>
<p>在一些脚本语言中，会采用类似与 <code>#!foo</code> 这种特殊的注释用于说明执行该脚本的程序，比如 <code>#!/usr/bin/env python3</code>。</p>
<p>而在 <code>python2</code> 中，也会在文件的开头注释说明该语言的编码形式: <code># -*- coding: &lt;encoding name&gt; -*-</code>，比如 <code># -*- coding: utf-8 -*-</code>。</p>
<p>既然其它语言有类似做法，那这种方案对 node 来说也行吧？</p>
<p>虽然这种方式很清晰，不过最后还是被否决了。</p>
<p>其中一个原因就是用户体验太差了。。。因为未来会是 <code>ESM</code> 的天下，既然是 <code>ESM</code> 的天下，那我为什么还要在每个文件开头写 <code>&quot;use modules&quot;;</code> 这样的代码。虽然现在还好，但这在以后势必会显得十分的冗余。</p>
<p>另一个原因是一些工具链为了区分不得不需要有一定的 <code>parse</code> 文件的能力。实现这个的成本明显比检测文件后缀名的成本要高的多。</p>
<p>主要由于以上两点，这个方案被否决了。</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>比起另外的方案，采用新的后缀 <code>.mjs</code>, 这个方案也算一个对程序员友好的方案。因为对于每个文件，只需多一个字母 <code>m</code> 在后缀名上 (<code>.js</code> -&gt; <code>.mjs</code>) 即可采用 <code>ESM</code>。</p>
<p>同时，不论从实现 <code>node</code> 解释器本身或者相关工具链角度来说，这个方案实现很容易就实现。</p>
<p>至于缺点，同样也是检测后缀名，很多相关工具仅仅把 <code>.js</code> 认为 <code>JavaScript</code> 文件，遇到 <code>.mjs</code> 可能就不认识了。</p>
<p>不过考虑到最近 <code>JavaScript</code> 相关后缀名不断增多，比如近几年出现的 <code>.jsx</code>, <code>.ts</code>。再增加一个 <code>.mjs</code> 似乎也没什么问题吧。<code>ヘ(￣ー￣ヘ)</code></p>
<p>另外，为什么采用 <code>.mjs</code> 而不是 <code>.es</code>, <code>.m.js</code> 呢？据了解，在可能想到的后缀名里，<code>.mjs</code> 和现有其它软件的后缀名的冲突最小。</p>
<h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>这个方案最直接了，如果可以。我当然愿意接受这种方案：全部交给 <code>node</code> 自动根据源码判断，比如有 <code>import</code> 就认为是 <code>ESM</code>，有 <code>require</code> 就认为是 <code>CJS</code>。</p>
<p>不过这个实现起来却非常困难。因为 <code>node</code> 源码开发者们不得不对现有 <code>parsing API</code> 进行更改，改进。这个的改动量是巨大的。而且，就算实现了，因为每次都需要对源码内容解析，可能会对性能产生潜在的影响，尤其是在分析大文件的时候。所以由于这个明显的缺点，这个方案也被否决了。</p>
<h1 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h1><p>这个方案的好处，就是不用对采用 <code>ESM</code> 的文件做任何修改就能辨认出是 <code>ESM</code>。</p>
<p>不过说实话，这个一听就对开发者有点不友好。要把所有 ESM 都指明，似乎有点累呀。</p>
<p>比如这样子:</p>

    <pre><code class="lang-json">{
  <span class="hljs-attr">"module"</span>: <span class="hljs-string">"lib/index.js"</span>,
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"old/index.js"</span>,
}
</code></pre>
<p>或</p>

    <pre><code class="lang-json">{
  <span class="hljs-string">//</span> <span class="hljs-string">...</span>
  <span class="hljs-string">//</span> files:
  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib/hello.js"</span>, <span class="hljs-string">"bin/hello.js"</span>],

  <span class="hljs-string">//</span> directories:
  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib"</span>, <span class="hljs-string">"bin"</span>],

  <span class="hljs-string">//</span> files and directories:
  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"lib"</span>, <span class="hljs-string">"bin"</span>, <span class="hljs-string">"special.js"</span>],

  <span class="hljs-string">//</span> <span class="hljs-keyword">if</span> package never uses CJS Modules
  <span class="hljs-string">"modules"</span>: [<span class="hljs-string">"."</span>],
}
</code></pre>
<p>另一个比较实在的问题，就是如果要运行 <code>ESM</code> 的文件的话，那岂不是要把 js 文件和 package.json 一起使用？也就是说，单个 <code>ESM</code> 文件是不是不能运行。</p>
<p>同样这个对现有的某些工具链不友好，需要阅读 <code>package.json</code> 才能确定是不是 <code>ESM</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的而言，虽然方案二有些缺点，但确实是方案二更优一点。另外，有一篇对方案四的<a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md" target="_blank" rel="noopener">正名</a>文章，值得读一读。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/nodejs/node/wiki/ES6-Module-Detection-in-Node" target="_blank" rel="noopener">ES6 Module Detection in Node</a></li>
<li><a href="http://2ality.com/2017/05/es-module-specifiers.html" target="_blank" rel="noopener">Module specifiers: what’s new with ES modules?</a></li>
<li><a href="https://github.com/bmeck/node-eps/blob/es6-module/002-es6-modules.md#es-consuming-commonjs" target="_blank" rel="noopener">node-eps</a></li>
<li><a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md" target="_blank" rel="noopener">defense-of-dot-js</a></li>
</ol>

</template>

  </template>
  <script type="text/javascript">
    window.root = "/"
  </script>
  <script src="/js/manifest.js"></script>
  <script src="/js/vendor.js"></script>
  <script src="/js/app.js"></script>
</body>
</html>
