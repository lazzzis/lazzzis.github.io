<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>lazzzis</title>
  <link rel="icon" href="favicon.ico"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="/css/ionicons.min.css">
  <link rel="stylesheet" href="/css/milligram.min.css">
  <link rel="stylesheet" href="/css/comfortaa.css">
  <link rel="stylesheet" href="/css/source-sans-pro.css">
  <link rel="stylesheet" href="/css/animate.min.css">
  <link rel="stylesheet" href="/css/nprogress.css">
  <link rel="stylesheet" href="/css/loaders.min.css">
  <link rel="stylesheet" href="/css/atom-one-light.css">
  <link rel="stylesheet" href="/css/app.css">
</head>
<body>
  <div id="app"></div>
  <template>
    <template>
    <p>在我知道wait() 与 notify() 以前，我常常用一种看似很 low 的方式控制线程同步</p>

    <pre><code class="lang-java"><span class="hljs-keyword">while</span>(condition) {
  <span class="hljs-keyword">return</span> ;
}
</code></pre>
<p>实际上这个线程是一直在运行的，并没有操作系统概念中的阻塞（Block）。而要实现阻塞（Block）则要借助 Java 线程中的 wait() 操作 与 notify() 操作。</p>
<a id="more"></a>
<h1 id="相对简单的例子"><a href="#相对简单的例子" class="headerlink" title="相对简单的例子"></a>相对简单的例子</h1><p>wait() 操作与 notify() 操作必须在临界区内进行。而 synchronized 需要一个对象用作锁，以区分各个不同的临界区。比如临界区 A 中进行了 wait() 操作，在也必须在临界区A 中进行 notify() 操作。</p>
<p>现看一个例子：</p>

    <pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        TestThread testThread = <span class="hljs-keyword">new</span> TestThread();
        testThread.start();
        <span class="hljs-keyword">synchronized</span> (testThread) {
            System.out.println(<span class="hljs-string">"Before wait"</span>);
            <span class="hljs-keyword">try</span> {
                testThread.wait();
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(<span class="hljs-string">"All completed!"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">try</span> {
                Thread.sleep(<span class="hljs-number">5000</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(<span class="hljs-string">"notify() Completed"</span>);
            notify();
        }
    }
}
</code></pre>
<p>例子中用了两次 <code>synchronized</code> ，但两次对应的参数是相同的，所以这两块代码都属于同一个临界区。当执行 wait 操作时，程序进入阻塞状态，在进行 notify 操作前，不会进行下一步，即不会输出<code>All completed!</code>。当 sleep 完成，即过了 5 秒钟后，触发 notify() 操作，打印<code>notify() Completed</code>。此时程序从阻塞状态进入就绪状态，然后进入运行状态，输出<code>All completed!</code>。</p>
<p><em>注意点</em>:</p>
<ol>
<li>切记 wait 操作和 notify 操作要在同一个临界区中进行。</li>
<li>在执行 wait 操作时会抛出一个 InterruptedException 的异常，记得捕获。</li>
</ol>
<p>输出结果参考：</p>

    <pre><code class="lang-java">Before wait
<span class="hljs-function"><span class="hljs-title">notify</span><span class="hljs-params">()</span></span> Completed
All completed!
</code></pre>
<h1 id="相对复杂的例子"><a href="#相对复杂的例子" class="headerlink" title="相对复杂的例子"></a>相对复杂的例子</h1><p>从上面一个例子看出，wait 和 notify 操作实现了进程同步，类似于播放器的暂停(wait)与继续(notify)。只有在 notify 的情况下才能继续 wait 之后的内容，可以保证一些临界值的准确性。</p>
<p>在操作系统概念中，有一个典型的 <em>消费者与生产者</em> 的模型。在一块区域中，最多存放 5 个 unit 的物品，当区域中的物品少于 5 个时，生产者就会生产 1 个 unit 的物品放在区域内；当区域中的物品大于 0 个时，消费者就会从区域中取走 1 个 unit 的物品。</p>
<p>如果用 wait 与 notify 模拟的话，那就是要控制好两者的出现时机。</p>
<p>先看代码：</p>

    <pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.Vector;
<span class="hljs-comment">/**
* Created by lazzzis on 2/9/16.
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Producer producer = <span class="hljs-keyword">new</span> Producer();
        producer.start();
        <span class="hljs-keyword">new</span> Consumer(producer).start();
        <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">80</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
        System.exit(<span class="hljs-number">0</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXQUEUE = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">private</span> Vector messages = <span class="hljs-keyword">new</span> Vector();
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                <span class="hljs-keyword">this</span>.putMessage();
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{
        <span class="hljs-keyword">while</span> (messages.size() == MAXQUEUE) {
            System.out.println(<span class="hljs-string">"I\'m waiting!"</span>);
            wait();
        }
        messages.addElement(<span class="hljs-keyword">new</span> Date().toString());
        System.out.println(<span class="hljs-string">"put message"</span>);
        notify();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{
        notify();
        <span class="hljs-keyword">while</span> (messages.size() == <span class="hljs-number">0</span>) {
            wait();
        }
        String message = (String) messages.firstElement();
        messages.removeElement(message);
        <span class="hljs-keyword">return</span> message;
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    Producer producer;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(Producer p)</span> </span>{
        producer = p;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                String message = producer.getMessage();
                System.out.println(<span class="hljs-string">"Got message: "</span> + message);
            }
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><em>注意点:</em></p>
<ol>
<li><code>synchronized</code>对于同一对象的不同方法，算作同样的临界区</li>
<li>两个方法中 notify 和 wait 的顺序相反，如果相同，极有可能发生两者同时处于wait状态，而导致无法触发 notify 的情况。</li>
<li>在 getMessage 中触发 notify 会使触发 wait 的 putMessage 继续运行，相当于一旦有物品被取走，就会通知生产者马上生产一个</li>
<li>在 putMessage 中触发 notify 会使触发 wait 的 getMessage 继续运行，相当于一旦有物品被生产，就会通知消费者马上取走一个。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.programcreek.com/2009/02/notify-and-wait-example/" target="_blank" rel="noopener">Java Thread: notify() and wait() examples</a></li>
<li><a href="http://stackoverflow.com/questions/886722/how-to-use-wait-and-notify-in-java" target="_blank" rel="noopener">How to use wait and notify in Java?</a></li>
</ol>

</template>

  </template>
  <script type="text/javascript">
    window.root = "/"
  </script>
  <script src="/js/manifest.js"></script>
  <script src="/js/vendor.js"></script>
  <script src="/js/app.js"></script>
</body>
</html>
